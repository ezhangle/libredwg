/* ex: set ro ft=c: -*- mode: c; buffer-read-only: t -*- */
/*****************************************************************************/
/*  LibreDWG - free implementation of the DWG file format                    */
/*                                                                           */
/*  Copyright (C) 2019 Free Software Foundation, Inc.                        */
/*                                                                           */
/*  This library is free software, licensed under the terms of the GNU       */
/*  General Public License as published by the Free Software Foundation,     */
/*  either version 3 of the License, or (at your option) any later version.  */
/*  You should have received a copy of the GNU General Public License        */
/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.    */
/*****************************************************************************/
/* dynapi coverage tests, generated by gen-dynapi.pl from dynapi_test.c.in
   do not modify */
/* written by: Reini Urban */

#line 16 "dynapi_test.c.in"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <math.h>
#include <sys/stat.h>

#define DWG_LOGLEVEL DWG_LOGLEVEL_NONE
#include "dwg.h"
#include "dwg_api.h"
#include "../../src/dynapi.h"
#include "../../src/common.h"
CLANG_DIAG_IGNORE(-Wformat-nonliteral)
CLANG_DIAG_IGNORE(-Wmissing-prototypes)
#include <dejagnu.h>
CLANG_DIAG_RESTORE
CLANG_DIAG_RESTORE

/* for all objects/entities/header_vars:
   compare direct api vs dynapi values
*/
static int test_header (const Dwg_Data *dwg)
{
  int error = 0;
  BITCODE_RL rl;
  BITCODE_RC rc;
  BITCODE_BLL bll;
  BITCODE_BD bd;
  BITCODE_TV tv;

  /*for (i=0; i<ARRAY_SIZE(_dwg_header_variables_fields)-1; i++) {
    const Dwg_DYNAPI_field *f = &_dwg_header_variables_fields[0];
    const char *name = f->name;
  }*/
#if 0
  if (dwg_dynapi_header_value(dwg, "unknown_0", &bd, NULL) &&
      dwg->header_vars.unknown_0 == bd) {
    pass ("HEADER.unknown_0");
  }  else {
    fail ("HEADER.unknown_0 %g != %g", dwg->header_vars.unknown_0, bd); error++;
  }
  if (dwg_dynapi_header_value(dwg, "unknown_text1", &tv, NULL) &&
      tv && dwg->header_vars.unknown_text1 &&
      !strcmp(dwg->header_vars.unknown_text1, tv)) {
    pass ("HEADER.unknown_text1");
  } else {
    fail ("HEADER.unknown_0 %s != %s", dwg->header_vars.unknown_text1, tv); error++;
  }
#endif
  /* ... */
#line 63 "dynapi_test.c"
  /* @@for test_HEADER@@ */
  {
    unsigned int size;
    if (dwg_dynapi_header_value(dwg, "size", &size, NULL) &&
        size == dwg->header_vars.size)
      pass ("HEADER.size [unsigned int]");
    else
      {
        fail ("HEADER.size [unsigned int] %u != %u", dwg->header_vars.size, size); error++;
      }
  }
  {
    unsigned int bitsize_hi;
    if (dwg_dynapi_header_value(dwg, "bitsize_hi", &bitsize_hi, NULL) &&
        bitsize_hi == dwg->header_vars.bitsize_hi)
      pass ("HEADER.bitsize_hi [unsigned int]");
    else
      {
        fail ("HEADER.bitsize_hi [unsigned int] %u != %u", dwg->header_vars.bitsize_hi, bitsize_hi); error++;
      }
  }
  {
    unsigned int bitsize;
    if (dwg_dynapi_header_value(dwg, "bitsize", &bitsize, NULL) &&
        bitsize == dwg->header_vars.bitsize)
      pass ("HEADER.bitsize [unsigned int]");
    else
      {
        fail ("HEADER.bitsize [unsigned int] %u != %u", dwg->header_vars.bitsize, bitsize); error++;
      }
  }
  {
    unsigned char acadmaintver;
    if (dwg_dynapi_header_value(dwg, "ACADMAINTVER", &acadmaintver, NULL) &&
        acadmaintver == dwg->header_vars.ACADMAINTVER)
      pass ("HEADER.ACADMAINTVER [unsigned char]");
    else
      {
        fail ("HEADER.ACADMAINTVER [unsigned char] %c != %c", dwg->header_vars.ACADMAINTVER, acadmaintver); error++;
      }
  }
  {
    long requiredversions;
    if (dwg_dynapi_header_value(dwg, "REQUIREDVERSIONS", &requiredversions, NULL) &&
        requiredversions == dwg->header_vars.REQUIREDVERSIONS)
      pass ("HEADER.REQUIREDVERSIONS [long]");
    else
      {
        fail ("HEADER.REQUIREDVERSIONS [long] %l != %l", dwg->header_vars.REQUIREDVERSIONS, requiredversions); error++;
      }
  }
  {
    char* dwgcodepage;
    if (dwg_dynapi_header_value(dwg, "DWGCODEPAGE", &dwgcodepage, NULL)
        && !memcmp(&dwgcodepage, &dwg->header_vars.DWGCODEPAGE, sizeof(dwg->header_vars.DWGCODEPAGE))
       )
      pass ("HEADER.DWGCODEPAGE [char*]");
    else
      {
        fail ("HEADER.DWGCODEPAGE [char*]"); error++;
      }
  }
  {
    unsigned short int* lastsavedby;
    if (dwg_dynapi_header_value(dwg, "LASTSAVEDBY", &lastsavedby, NULL)
        && !memcmp(&lastsavedby, &dwg->header_vars.LASTSAVEDBY, sizeof(dwg->header_vars.LASTSAVEDBY))
       )
      pass ("HEADER.LASTSAVEDBY [unsigned short int*]");
    else
      {
        fail ("HEADER.LASTSAVEDBY [unsigned short int*]"); error++;
      }
  }
  {
    double unknown_0;
    if (dwg_dynapi_header_value(dwg, "unknown_0", &unknown_0, NULL) &&
        unknown_0 == dwg->header_vars.unknown_0)
      pass ("HEADER.unknown_0 [double]");
    else
      {
        fail ("HEADER.unknown_0 [double] %g != %g", dwg->header_vars.unknown_0, unknown_0); error++;
      }
  }
  {
    double unknown_1;
    if (dwg_dynapi_header_value(dwg, "unknown_1", &unknown_1, NULL) &&
        unknown_1 == dwg->header_vars.unknown_1)
      pass ("HEADER.unknown_1 [double]");
    else
      {
        fail ("HEADER.unknown_1 [double] %g != %g", dwg->header_vars.unknown_1, unknown_1); error++;
      }
  }
  {
    double unknown_2;
    if (dwg_dynapi_header_value(dwg, "unknown_2", &unknown_2, NULL) &&
        unknown_2 == dwg->header_vars.unknown_2)
      pass ("HEADER.unknown_2 [double]");
    else
      {
        fail ("HEADER.unknown_2 [double] %g != %g", dwg->header_vars.unknown_2, unknown_2); error++;
      }
  }
  {
    double unknown_3;
    if (dwg_dynapi_header_value(dwg, "unknown_3", &unknown_3, NULL) &&
        unknown_3 == dwg->header_vars.unknown_3)
      pass ("HEADER.unknown_3 [double]");
    else
      {
        fail ("HEADER.unknown_3 [double] %g != %g", dwg->header_vars.unknown_3, unknown_3); error++;
      }
  }
  {
    char* unknown_text1;
    if (dwg_dynapi_header_value(dwg, "unknown_text1", &unknown_text1, NULL)
        && !memcmp(&unknown_text1, &dwg->header_vars.unknown_text1, sizeof(dwg->header_vars.unknown_text1))
       )
      pass ("HEADER.unknown_text1 [char*]");
    else
      {
        fail ("HEADER.unknown_text1 [char*]"); error++;
      }
  }
  {
    char* unknown_text2;
    if (dwg_dynapi_header_value(dwg, "unknown_text2", &unknown_text2, NULL)
        && !memcmp(&unknown_text2, &dwg->header_vars.unknown_text2, sizeof(dwg->header_vars.unknown_text2))
       )
      pass ("HEADER.unknown_text2 [char*]");
    else
      {
        fail ("HEADER.unknown_text2 [char*]"); error++;
      }
  }
  {
    char* unknown_text3;
    if (dwg_dynapi_header_value(dwg, "unknown_text3", &unknown_text3, NULL)
        && !memcmp(&unknown_text3, &dwg->header_vars.unknown_text3, sizeof(dwg->header_vars.unknown_text3))
       )
      pass ("HEADER.unknown_text3 [char*]");
    else
      {
        fail ("HEADER.unknown_text3 [char*]"); error++;
      }
  }
  {
    char* unknown_text4;
    if (dwg_dynapi_header_value(dwg, "unknown_text4", &unknown_text4, NULL)
        && !memcmp(&unknown_text4, &dwg->header_vars.unknown_text4, sizeof(dwg->header_vars.unknown_text4))
       )
      pass ("HEADER.unknown_text4 [char*]");
    else
      {
        fail ("HEADER.unknown_text4 [char*]"); error++;
      }
  }
  {
    unsigned int unknown_8;
    if (dwg_dynapi_header_value(dwg, "unknown_8", &unknown_8, NULL) &&
        unknown_8 == dwg->header_vars.unknown_8)
      pass ("HEADER.unknown_8 [unsigned int]");
    else
      {
        fail ("HEADER.unknown_8 [unsigned int] %u != %u", dwg->header_vars.unknown_8, unknown_8); error++;
      }
  }
  {
    unsigned int unknown_9;
    if (dwg_dynapi_header_value(dwg, "unknown_9", &unknown_9, NULL) &&
        unknown_9 == dwg->header_vars.unknown_9)
      pass ("HEADER.unknown_9 [unsigned int]");
    else
      {
        fail ("HEADER.unknown_9 [unsigned int] %u != %u", dwg->header_vars.unknown_9, unknown_9); error++;
      }
  }
  {
    unsigned short int unknown_10;
    if (dwg_dynapi_header_value(dwg, "unknown_10", &unknown_10, NULL) &&
        unknown_10 == dwg->header_vars.unknown_10)
      pass ("HEADER.unknown_10 [unsigned short int]");
    else
      {
        fail ("HEADER.unknown_10 [unsigned short int] %hu != %hu", dwg->header_vars.unknown_10, unknown_10); error++;
      }
  }
  {
    Dwg_Object_Ref* vport_entity_header;
    if (dwg_dynapi_header_value(dwg, "vport_entity_header", &vport_entity_header, NULL)
        && !memcmp(&vport_entity_header, &dwg->header_vars.vport_entity_header, sizeof(dwg->header_vars.vport_entity_header))
       )
      pass ("HEADER.vport_entity_header [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.vport_entity_header [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    unsigned char dimaso;
    if (dwg_dynapi_header_value(dwg, "DIMASO", &dimaso, NULL) &&
        dimaso == dwg->header_vars.DIMASO)
      pass ("HEADER.DIMASO [unsigned char]");
    else
      {
        fail ("HEADER.DIMASO [unsigned char] %c != %c", dwg->header_vars.DIMASO, dimaso); error++;
      }
  }
  {
    unsigned char dimsho;
    if (dwg_dynapi_header_value(dwg, "DIMSHO", &dimsho, NULL) &&
        dimsho == dwg->header_vars.DIMSHO)
      pass ("HEADER.DIMSHO [unsigned char]");
    else
      {
        fail ("HEADER.DIMSHO [unsigned char] %c != %c", dwg->header_vars.DIMSHO, dimsho); error++;
      }
  }
  {
    unsigned char dimsav;
    if (dwg_dynapi_header_value(dwg, "DIMSAV", &dimsav, NULL) &&
        dimsav == dwg->header_vars.DIMSAV)
      pass ("HEADER.DIMSAV [unsigned char]");
    else
      {
        fail ("HEADER.DIMSAV [unsigned char] %c != %c", dwg->header_vars.DIMSAV, dimsav); error++;
      }
  }
  {
    unsigned char plinegen;
    if (dwg_dynapi_header_value(dwg, "PLINEGEN", &plinegen, NULL) &&
        plinegen == dwg->header_vars.PLINEGEN)
      pass ("HEADER.PLINEGEN [unsigned char]");
    else
      {
        fail ("HEADER.PLINEGEN [unsigned char] %c != %c", dwg->header_vars.PLINEGEN, plinegen); error++;
      }
  }
  {
    unsigned char orthomode;
    if (dwg_dynapi_header_value(dwg, "ORTHOMODE", &orthomode, NULL) &&
        orthomode == dwg->header_vars.ORTHOMODE)
      pass ("HEADER.ORTHOMODE [unsigned char]");
    else
      {
        fail ("HEADER.ORTHOMODE [unsigned char] %c != %c", dwg->header_vars.ORTHOMODE, orthomode); error++;
      }
  }
  {
    unsigned char regenmode;
    if (dwg_dynapi_header_value(dwg, "REGENMODE", &regenmode, NULL) &&
        regenmode == dwg->header_vars.REGENMODE)
      pass ("HEADER.REGENMODE [unsigned char]");
    else
      {
        fail ("HEADER.REGENMODE [unsigned char] %c != %c", dwg->header_vars.REGENMODE, regenmode); error++;
      }
  }
  {
    unsigned char fillmode;
    if (dwg_dynapi_header_value(dwg, "FILLMODE", &fillmode, NULL) &&
        fillmode == dwg->header_vars.FILLMODE)
      pass ("HEADER.FILLMODE [unsigned char]");
    else
      {
        fail ("HEADER.FILLMODE [unsigned char] %c != %c", dwg->header_vars.FILLMODE, fillmode); error++;
      }
  }
  {
    unsigned char qtextmode;
    if (dwg_dynapi_header_value(dwg, "QTEXTMODE", &qtextmode, NULL) &&
        qtextmode == dwg->header_vars.QTEXTMODE)
      pass ("HEADER.QTEXTMODE [unsigned char]");
    else
      {
        fail ("HEADER.QTEXTMODE [unsigned char] %c != %c", dwg->header_vars.QTEXTMODE, qtextmode); error++;
      }
  }
  {
    unsigned char psltscale;
    if (dwg_dynapi_header_value(dwg, "PSLTSCALE", &psltscale, NULL) &&
        psltscale == dwg->header_vars.PSLTSCALE)
      pass ("HEADER.PSLTSCALE [unsigned char]");
    else
      {
        fail ("HEADER.PSLTSCALE [unsigned char] %c != %c", dwg->header_vars.PSLTSCALE, psltscale); error++;
      }
  }
  {
    unsigned char limcheck;
    if (dwg_dynapi_header_value(dwg, "LIMCHECK", &limcheck, NULL) &&
        limcheck == dwg->header_vars.LIMCHECK)
      pass ("HEADER.LIMCHECK [unsigned char]");
    else
      {
        fail ("HEADER.LIMCHECK [unsigned char] %c != %c", dwg->header_vars.LIMCHECK, limcheck); error++;
      }
  }
  {
    unsigned char blipmode;
    if (dwg_dynapi_header_value(dwg, "BLIPMODE", &blipmode, NULL) &&
        blipmode == dwg->header_vars.BLIPMODE)
      pass ("HEADER.BLIPMODE [unsigned char]");
    else
      {
        fail ("HEADER.BLIPMODE [unsigned char] %c != %c", dwg->header_vars.BLIPMODE, blipmode); error++;
      }
  }
  {
    unsigned char unknown_11;
    if (dwg_dynapi_header_value(dwg, "unknown_11", &unknown_11, NULL) &&
        unknown_11 == dwg->header_vars.unknown_11)
      pass ("HEADER.unknown_11 [unsigned char]");
    else
      {
        fail ("HEADER.unknown_11 [unsigned char] %c != %c", dwg->header_vars.unknown_11, unknown_11); error++;
      }
  }
  {
    unsigned char usrtimer;
    if (dwg_dynapi_header_value(dwg, "USRTIMER", &usrtimer, NULL) &&
        usrtimer == dwg->header_vars.USRTIMER)
      pass ("HEADER.USRTIMER [unsigned char]");
    else
      {
        fail ("HEADER.USRTIMER [unsigned char] %c != %c", dwg->header_vars.USRTIMER, usrtimer); error++;
      }
  }
  {
    unsigned char skpoly;
    if (dwg_dynapi_header_value(dwg, "SKPOLY", &skpoly, NULL) &&
        skpoly == dwg->header_vars.SKPOLY)
      pass ("HEADER.SKPOLY [unsigned char]");
    else
      {
        fail ("HEADER.SKPOLY [unsigned char] %c != %c", dwg->header_vars.SKPOLY, skpoly); error++;
      }
  }
  {
    unsigned char angdir;
    if (dwg_dynapi_header_value(dwg, "ANGDIR", &angdir, NULL) &&
        angdir == dwg->header_vars.ANGDIR)
      pass ("HEADER.ANGDIR [unsigned char]");
    else
      {
        fail ("HEADER.ANGDIR [unsigned char] %c != %c", dwg->header_vars.ANGDIR, angdir); error++;
      }
  }
  {
    unsigned char splframe;
    if (dwg_dynapi_header_value(dwg, "SPLFRAME", &splframe, NULL) &&
        splframe == dwg->header_vars.SPLFRAME)
      pass ("HEADER.SPLFRAME [unsigned char]");
    else
      {
        fail ("HEADER.SPLFRAME [unsigned char] %c != %c", dwg->header_vars.SPLFRAME, splframe); error++;
      }
  }
  {
    unsigned char attreq;
    if (dwg_dynapi_header_value(dwg, "ATTREQ", &attreq, NULL) &&
        attreq == dwg->header_vars.ATTREQ)
      pass ("HEADER.ATTREQ [unsigned char]");
    else
      {
        fail ("HEADER.ATTREQ [unsigned char] %c != %c", dwg->header_vars.ATTREQ, attreq); error++;
      }
  }
  {
    unsigned char attdia;
    if (dwg_dynapi_header_value(dwg, "ATTDIA", &attdia, NULL) &&
        attdia == dwg->header_vars.ATTDIA)
      pass ("HEADER.ATTDIA [unsigned char]");
    else
      {
        fail ("HEADER.ATTDIA [unsigned char] %c != %c", dwg->header_vars.ATTDIA, attdia); error++;
      }
  }
  {
    unsigned char mirrtext;
    if (dwg_dynapi_header_value(dwg, "MIRRTEXT", &mirrtext, NULL) &&
        mirrtext == dwg->header_vars.MIRRTEXT)
      pass ("HEADER.MIRRTEXT [unsigned char]");
    else
      {
        fail ("HEADER.MIRRTEXT [unsigned char] %c != %c", dwg->header_vars.MIRRTEXT, mirrtext); error++;
      }
  }
  {
    unsigned char worldview;
    if (dwg_dynapi_header_value(dwg, "WORLDVIEW", &worldview, NULL) &&
        worldview == dwg->header_vars.WORLDVIEW)
      pass ("HEADER.WORLDVIEW [unsigned char]");
    else
      {
        fail ("HEADER.WORLDVIEW [unsigned char] %c != %c", dwg->header_vars.WORLDVIEW, worldview); error++;
      }
  }
  {
    unsigned char wireframe;
    if (dwg_dynapi_header_value(dwg, "WIREFRAME", &wireframe, NULL) &&
        wireframe == dwg->header_vars.WIREFRAME)
      pass ("HEADER.WIREFRAME [unsigned char]");
    else
      {
        fail ("HEADER.WIREFRAME [unsigned char] %c != %c", dwg->header_vars.WIREFRAME, wireframe); error++;
      }
  }
  {
    unsigned char tilemode;
    if (dwg_dynapi_header_value(dwg, "TILEMODE", &tilemode, NULL) &&
        tilemode == dwg->header_vars.TILEMODE)
      pass ("HEADER.TILEMODE [unsigned char]");
    else
      {
        fail ("HEADER.TILEMODE [unsigned char] %c != %c", dwg->header_vars.TILEMODE, tilemode); error++;
      }
  }
  {
    unsigned char plimcheck;
    if (dwg_dynapi_header_value(dwg, "PLIMCHECK", &plimcheck, NULL) &&
        plimcheck == dwg->header_vars.PLIMCHECK)
      pass ("HEADER.PLIMCHECK [unsigned char]");
    else
      {
        fail ("HEADER.PLIMCHECK [unsigned char] %c != %c", dwg->header_vars.PLIMCHECK, plimcheck); error++;
      }
  }
  {
    unsigned char visretain;
    if (dwg_dynapi_header_value(dwg, "VISRETAIN", &visretain, NULL) &&
        visretain == dwg->header_vars.VISRETAIN)
      pass ("HEADER.VISRETAIN [unsigned char]");
    else
      {
        fail ("HEADER.VISRETAIN [unsigned char] %c != %c", dwg->header_vars.VISRETAIN, visretain); error++;
      }
  }
  {
    unsigned char delobj;
    if (dwg_dynapi_header_value(dwg, "DELOBJ", &delobj, NULL) &&
        delobj == dwg->header_vars.DELOBJ)
      pass ("HEADER.DELOBJ [unsigned char]");
    else
      {
        fail ("HEADER.DELOBJ [unsigned char] %c != %c", dwg->header_vars.DELOBJ, delobj); error++;
      }
  }
  {
    unsigned char dispsilh;
    if (dwg_dynapi_header_value(dwg, "DISPSILH", &dispsilh, NULL) &&
        dispsilh == dwg->header_vars.DISPSILH)
      pass ("HEADER.DISPSILH [unsigned char]");
    else
      {
        fail ("HEADER.DISPSILH [unsigned char] %c != %c", dwg->header_vars.DISPSILH, dispsilh); error++;
      }
  }
  {
    unsigned char pellipse;
    if (dwg_dynapi_header_value(dwg, "PELLIPSE", &pellipse, NULL) &&
        pellipse == dwg->header_vars.PELLIPSE)
      pass ("HEADER.PELLIPSE [unsigned char]");
    else
      {
        fail ("HEADER.PELLIPSE [unsigned char] %c != %c", dwg->header_vars.PELLIPSE, pellipse); error++;
      }
  }
  {
    unsigned short int saveimages;
    if (dwg_dynapi_header_value(dwg, "SAVEIMAGES", &saveimages, NULL) &&
        saveimages == dwg->header_vars.SAVEIMAGES)
      pass ("HEADER.SAVEIMAGES [unsigned short int]");
    else
      {
        fail ("HEADER.SAVEIMAGES [unsigned short int] %hu != %hu", dwg->header_vars.SAVEIMAGES, saveimages); error++;
      }
  }
  {
    unsigned short int proxygraphics;
    if (dwg_dynapi_header_value(dwg, "PROXYGRAPHICS", &proxygraphics, NULL) &&
        proxygraphics == dwg->header_vars.PROXYGRAPHICS)
      pass ("HEADER.PROXYGRAPHICS [unsigned short int]");
    else
      {
        fail ("HEADER.PROXYGRAPHICS [unsigned short int] %hu != %hu", dwg->header_vars.PROXYGRAPHICS, proxygraphics); error++;
      }
  }
  {
    unsigned short int dragmode;
    if (dwg_dynapi_header_value(dwg, "DRAGMODE", &dragmode, NULL) &&
        dragmode == dwg->header_vars.DRAGMODE)
      pass ("HEADER.DRAGMODE [unsigned short int]");
    else
      {
        fail ("HEADER.DRAGMODE [unsigned short int] %hu != %hu", dwg->header_vars.DRAGMODE, dragmode); error++;
      }
  }
  {
    unsigned short int treedepth;
    if (dwg_dynapi_header_value(dwg, "TREEDEPTH", &treedepth, NULL) &&
        treedepth == dwg->header_vars.TREEDEPTH)
      pass ("HEADER.TREEDEPTH [unsigned short int]");
    else
      {
        fail ("HEADER.TREEDEPTH [unsigned short int] %hu != %hu", dwg->header_vars.TREEDEPTH, treedepth); error++;
      }
  }
  {
    unsigned short int lunits;
    if (dwg_dynapi_header_value(dwg, "LUNITS", &lunits, NULL) &&
        lunits == dwg->header_vars.LUNITS)
      pass ("HEADER.LUNITS [unsigned short int]");
    else
      {
        fail ("HEADER.LUNITS [unsigned short int] %hu != %hu", dwg->header_vars.LUNITS, lunits); error++;
      }
  }
  {
    unsigned short int luprec;
    if (dwg_dynapi_header_value(dwg, "LUPREC", &luprec, NULL) &&
        luprec == dwg->header_vars.LUPREC)
      pass ("HEADER.LUPREC [unsigned short int]");
    else
      {
        fail ("HEADER.LUPREC [unsigned short int] %hu != %hu", dwg->header_vars.LUPREC, luprec); error++;
      }
  }
  {
    unsigned short int aunits;
    if (dwg_dynapi_header_value(dwg, "AUNITS", &aunits, NULL) &&
        aunits == dwg->header_vars.AUNITS)
      pass ("HEADER.AUNITS [unsigned short int]");
    else
      {
        fail ("HEADER.AUNITS [unsigned short int] %hu != %hu", dwg->header_vars.AUNITS, aunits); error++;
      }
  }
  {
    unsigned short int auprec;
    if (dwg_dynapi_header_value(dwg, "AUPREC", &auprec, NULL) &&
        auprec == dwg->header_vars.AUPREC)
      pass ("HEADER.AUPREC [unsigned short int]");
    else
      {
        fail ("HEADER.AUPREC [unsigned short int] %hu != %hu", dwg->header_vars.AUPREC, auprec); error++;
      }
  }
  {
    unsigned short int osmode;
    if (dwg_dynapi_header_value(dwg, "OSMODE", &osmode, NULL) &&
        osmode == dwg->header_vars.OSMODE)
      pass ("HEADER.OSMODE [unsigned short int]");
    else
      {
        fail ("HEADER.OSMODE [unsigned short int] %hu != %hu", dwg->header_vars.OSMODE, osmode); error++;
      }
  }
  {
    unsigned short int attmode;
    if (dwg_dynapi_header_value(dwg, "ATTMODE", &attmode, NULL) &&
        attmode == dwg->header_vars.ATTMODE)
      pass ("HEADER.ATTMODE [unsigned short int]");
    else
      {
        fail ("HEADER.ATTMODE [unsigned short int] %hu != %hu", dwg->header_vars.ATTMODE, attmode); error++;
      }
  }
  {
    unsigned short int coords;
    if (dwg_dynapi_header_value(dwg, "COORDS", &coords, NULL) &&
        coords == dwg->header_vars.COORDS)
      pass ("HEADER.COORDS [unsigned short int]");
    else
      {
        fail ("HEADER.COORDS [unsigned short int] %hu != %hu", dwg->header_vars.COORDS, coords); error++;
      }
  }
  {
    unsigned short int pdmode;
    if (dwg_dynapi_header_value(dwg, "PDMODE", &pdmode, NULL) &&
        pdmode == dwg->header_vars.PDMODE)
      pass ("HEADER.PDMODE [unsigned short int]");
    else
      {
        fail ("HEADER.PDMODE [unsigned short int] %hu != %hu", dwg->header_vars.PDMODE, pdmode); error++;
      }
  }
  {
    unsigned short int pickstyle;
    if (dwg_dynapi_header_value(dwg, "PICKSTYLE", &pickstyle, NULL) &&
        pickstyle == dwg->header_vars.PICKSTYLE)
      pass ("HEADER.PICKSTYLE [unsigned short int]");
    else
      {
        fail ("HEADER.PICKSTYLE [unsigned short int] %hu != %hu", dwg->header_vars.PICKSTYLE, pickstyle); error++;
      }
  }
  {
    unsigned int unknown_12;
    if (dwg_dynapi_header_value(dwg, "unknown_12", &unknown_12, NULL) &&
        unknown_12 == dwg->header_vars.unknown_12)
      pass ("HEADER.unknown_12 [unsigned int]");
    else
      {
        fail ("HEADER.unknown_12 [unsigned int] %u != %u", dwg->header_vars.unknown_12, unknown_12); error++;
      }
  }
  {
    unsigned int unknown_13;
    if (dwg_dynapi_header_value(dwg, "unknown_13", &unknown_13, NULL) &&
        unknown_13 == dwg->header_vars.unknown_13)
      pass ("HEADER.unknown_13 [unsigned int]");
    else
      {
        fail ("HEADER.unknown_13 [unsigned int] %u != %u", dwg->header_vars.unknown_13, unknown_13); error++;
      }
  }
  {
    unsigned int unknown_14;
    if (dwg_dynapi_header_value(dwg, "unknown_14", &unknown_14, NULL) &&
        unknown_14 == dwg->header_vars.unknown_14)
      pass ("HEADER.unknown_14 [unsigned int]");
    else
      {
        fail ("HEADER.unknown_14 [unsigned int] %u != %u", dwg->header_vars.unknown_14, unknown_14); error++;
      }
  }
  {
    unsigned short int useri1;
    if (dwg_dynapi_header_value(dwg, "USERI1", &useri1, NULL) &&
        useri1 == dwg->header_vars.USERI1)
      pass ("HEADER.USERI1 [unsigned short int]");
    else
      {
        fail ("HEADER.USERI1 [unsigned short int] %hu != %hu", dwg->header_vars.USERI1, useri1); error++;
      }
  }
  {
    unsigned short int useri2;
    if (dwg_dynapi_header_value(dwg, "USERI2", &useri2, NULL) &&
        useri2 == dwg->header_vars.USERI2)
      pass ("HEADER.USERI2 [unsigned short int]");
    else
      {
        fail ("HEADER.USERI2 [unsigned short int] %hu != %hu", dwg->header_vars.USERI2, useri2); error++;
      }
  }
  {
    unsigned short int useri3;
    if (dwg_dynapi_header_value(dwg, "USERI3", &useri3, NULL) &&
        useri3 == dwg->header_vars.USERI3)
      pass ("HEADER.USERI3 [unsigned short int]");
    else
      {
        fail ("HEADER.USERI3 [unsigned short int] %hu != %hu", dwg->header_vars.USERI3, useri3); error++;
      }
  }
  {
    unsigned short int useri4;
    if (dwg_dynapi_header_value(dwg, "USERI4", &useri4, NULL) &&
        useri4 == dwg->header_vars.USERI4)
      pass ("HEADER.USERI4 [unsigned short int]");
    else
      {
        fail ("HEADER.USERI4 [unsigned short int] %hu != %hu", dwg->header_vars.USERI4, useri4); error++;
      }
  }
  {
    unsigned short int useri5;
    if (dwg_dynapi_header_value(dwg, "USERI5", &useri5, NULL) &&
        useri5 == dwg->header_vars.USERI5)
      pass ("HEADER.USERI5 [unsigned short int]");
    else
      {
        fail ("HEADER.USERI5 [unsigned short int] %hu != %hu", dwg->header_vars.USERI5, useri5); error++;
      }
  }
  {
    unsigned short int splinesegs;
    if (dwg_dynapi_header_value(dwg, "SPLINESEGS", &splinesegs, NULL) &&
        splinesegs == dwg->header_vars.SPLINESEGS)
      pass ("HEADER.SPLINESEGS [unsigned short int]");
    else
      {
        fail ("HEADER.SPLINESEGS [unsigned short int] %hu != %hu", dwg->header_vars.SPLINESEGS, splinesegs); error++;
      }
  }
  {
    unsigned short int surfu;
    if (dwg_dynapi_header_value(dwg, "SURFU", &surfu, NULL) &&
        surfu == dwg->header_vars.SURFU)
      pass ("HEADER.SURFU [unsigned short int]");
    else
      {
        fail ("HEADER.SURFU [unsigned short int] %hu != %hu", dwg->header_vars.SURFU, surfu); error++;
      }
  }
  {
    unsigned short int surfv;
    if (dwg_dynapi_header_value(dwg, "SURFV", &surfv, NULL) &&
        surfv == dwg->header_vars.SURFV)
      pass ("HEADER.SURFV [unsigned short int]");
    else
      {
        fail ("HEADER.SURFV [unsigned short int] %hu != %hu", dwg->header_vars.SURFV, surfv); error++;
      }
  }
  {
    unsigned short int surftype;
    if (dwg_dynapi_header_value(dwg, "SURFTYPE", &surftype, NULL) &&
        surftype == dwg->header_vars.SURFTYPE)
      pass ("HEADER.SURFTYPE [unsigned short int]");
    else
      {
        fail ("HEADER.SURFTYPE [unsigned short int] %hu != %hu", dwg->header_vars.SURFTYPE, surftype); error++;
      }
  }
  {
    unsigned short int surftab1;
    if (dwg_dynapi_header_value(dwg, "SURFTAB1", &surftab1, NULL) &&
        surftab1 == dwg->header_vars.SURFTAB1)
      pass ("HEADER.SURFTAB1 [unsigned short int]");
    else
      {
        fail ("HEADER.SURFTAB1 [unsigned short int] %hu != %hu", dwg->header_vars.SURFTAB1, surftab1); error++;
      }
  }
  {
    unsigned short int surftab2;
    if (dwg_dynapi_header_value(dwg, "SURFTAB2", &surftab2, NULL) &&
        surftab2 == dwg->header_vars.SURFTAB2)
      pass ("HEADER.SURFTAB2 [unsigned short int]");
    else
      {
        fail ("HEADER.SURFTAB2 [unsigned short int] %hu != %hu", dwg->header_vars.SURFTAB2, surftab2); error++;
      }
  }
  {
    unsigned short int splinetype;
    if (dwg_dynapi_header_value(dwg, "SPLINETYPE", &splinetype, NULL) &&
        splinetype == dwg->header_vars.SPLINETYPE)
      pass ("HEADER.SPLINETYPE [unsigned short int]");
    else
      {
        fail ("HEADER.SPLINETYPE [unsigned short int] %hu != %hu", dwg->header_vars.SPLINETYPE, splinetype); error++;
      }
  }
  {
    unsigned short int shadedge;
    if (dwg_dynapi_header_value(dwg, "SHADEDGE", &shadedge, NULL) &&
        shadedge == dwg->header_vars.SHADEDGE)
      pass ("HEADER.SHADEDGE [unsigned short int]");
    else
      {
        fail ("HEADER.SHADEDGE [unsigned short int] %hu != %hu", dwg->header_vars.SHADEDGE, shadedge); error++;
      }
  }
  {
    unsigned short int shadedif;
    if (dwg_dynapi_header_value(dwg, "SHADEDIF", &shadedif, NULL) &&
        shadedif == dwg->header_vars.SHADEDIF)
      pass ("HEADER.SHADEDIF [unsigned short int]");
    else
      {
        fail ("HEADER.SHADEDIF [unsigned short int] %hu != %hu", dwg->header_vars.SHADEDIF, shadedif); error++;
      }
  }
  {
    unsigned short int unitmode;
    if (dwg_dynapi_header_value(dwg, "UNITMODE", &unitmode, NULL) &&
        unitmode == dwg->header_vars.UNITMODE)
      pass ("HEADER.UNITMODE [unsigned short int]");
    else
      {
        fail ("HEADER.UNITMODE [unsigned short int] %hu != %hu", dwg->header_vars.UNITMODE, unitmode); error++;
      }
  }
  {
    unsigned short int maxactvp;
    if (dwg_dynapi_header_value(dwg, "MAXACTVP", &maxactvp, NULL) &&
        maxactvp == dwg->header_vars.MAXACTVP)
      pass ("HEADER.MAXACTVP [unsigned short int]");
    else
      {
        fail ("HEADER.MAXACTVP [unsigned short int] %hu != %hu", dwg->header_vars.MAXACTVP, maxactvp); error++;
      }
  }
  {
    unsigned short int isolines;
    if (dwg_dynapi_header_value(dwg, "ISOLINES", &isolines, NULL) &&
        isolines == dwg->header_vars.ISOLINES)
      pass ("HEADER.ISOLINES [unsigned short int]");
    else
      {
        fail ("HEADER.ISOLINES [unsigned short int] %hu != %hu", dwg->header_vars.ISOLINES, isolines); error++;
      }
  }
  {
    unsigned short int cmljust;
    if (dwg_dynapi_header_value(dwg, "CMLJUST", &cmljust, NULL) &&
        cmljust == dwg->header_vars.CMLJUST)
      pass ("HEADER.CMLJUST [unsigned short int]");
    else
      {
        fail ("HEADER.CMLJUST [unsigned short int] %hu != %hu", dwg->header_vars.CMLJUST, cmljust); error++;
      }
  }
  {
    unsigned short int textqlty;
    if (dwg_dynapi_header_value(dwg, "TEXTQLTY", &textqlty, NULL) &&
        textqlty == dwg->header_vars.TEXTQLTY)
      pass ("HEADER.TEXTQLTY [unsigned short int]");
    else
      {
        fail ("HEADER.TEXTQLTY [unsigned short int] %hu != %hu", dwg->header_vars.TEXTQLTY, textqlty); error++;
      }
  }
  {
    unsigned int unknown_14b;
    if (dwg_dynapi_header_value(dwg, "unknown_14b", &unknown_14b, NULL) &&
        unknown_14b == dwg->header_vars.unknown_14b)
      pass ("HEADER.unknown_14b [unsigned int]");
    else
      {
        fail ("HEADER.unknown_14b [unsigned int] %u != %u", dwg->header_vars.unknown_14b, unknown_14b); error++;
      }
  }
  {
    double ltscale;
    if (dwg_dynapi_header_value(dwg, "LTSCALE", &ltscale, NULL) &&
        ltscale == dwg->header_vars.LTSCALE)
      pass ("HEADER.LTSCALE [double]");
    else
      {
        fail ("HEADER.LTSCALE [double] %g != %g", dwg->header_vars.LTSCALE, ltscale); error++;
      }
  }
  {
    double textsize;
    if (dwg_dynapi_header_value(dwg, "TEXTSIZE", &textsize, NULL) &&
        textsize == dwg->header_vars.TEXTSIZE)
      pass ("HEADER.TEXTSIZE [double]");
    else
      {
        fail ("HEADER.TEXTSIZE [double] %g != %g", dwg->header_vars.TEXTSIZE, textsize); error++;
      }
  }
  {
    double tracewid;
    if (dwg_dynapi_header_value(dwg, "TRACEWID", &tracewid, NULL) &&
        tracewid == dwg->header_vars.TRACEWID)
      pass ("HEADER.TRACEWID [double]");
    else
      {
        fail ("HEADER.TRACEWID [double] %g != %g", dwg->header_vars.TRACEWID, tracewid); error++;
      }
  }
  {
    double sketchinc;
    if (dwg_dynapi_header_value(dwg, "SKETCHINC", &sketchinc, NULL) &&
        sketchinc == dwg->header_vars.SKETCHINC)
      pass ("HEADER.SKETCHINC [double]");
    else
      {
        fail ("HEADER.SKETCHINC [double] %g != %g", dwg->header_vars.SKETCHINC, sketchinc); error++;
      }
  }
  {
    double filletrad;
    if (dwg_dynapi_header_value(dwg, "FILLETRAD", &filletrad, NULL) &&
        filletrad == dwg->header_vars.FILLETRAD)
      pass ("HEADER.FILLETRAD [double]");
    else
      {
        fail ("HEADER.FILLETRAD [double] %g != %g", dwg->header_vars.FILLETRAD, filletrad); error++;
      }
  }
  {
    double thickness;
    if (dwg_dynapi_header_value(dwg, "THICKNESS", &thickness, NULL) &&
        thickness == dwg->header_vars.THICKNESS)
      pass ("HEADER.THICKNESS [double]");
    else
      {
        fail ("HEADER.THICKNESS [double] %g != %g", dwg->header_vars.THICKNESS, thickness); error++;
      }
  }
  {
    double angbase;
    if (dwg_dynapi_header_value(dwg, "ANGBASE", &angbase, NULL) &&
        angbase == dwg->header_vars.ANGBASE)
      pass ("HEADER.ANGBASE [double]");
    else
      {
        fail ("HEADER.ANGBASE [double] %g != %g", dwg->header_vars.ANGBASE, angbase); error++;
      }
  }
  {
    double pdsize;
    if (dwg_dynapi_header_value(dwg, "PDSIZE", &pdsize, NULL) &&
        pdsize == dwg->header_vars.PDSIZE)
      pass ("HEADER.PDSIZE [double]");
    else
      {
        fail ("HEADER.PDSIZE [double] %g != %g", dwg->header_vars.PDSIZE, pdsize); error++;
      }
  }
  {
    double plinewid;
    if (dwg_dynapi_header_value(dwg, "PLINEWID", &plinewid, NULL) &&
        plinewid == dwg->header_vars.PLINEWID)
      pass ("HEADER.PLINEWID [double]");
    else
      {
        fail ("HEADER.PLINEWID [double] %g != %g", dwg->header_vars.PLINEWID, plinewid); error++;
      }
  }
  {
    double userr1;
    if (dwg_dynapi_header_value(dwg, "USERR1", &userr1, NULL) &&
        userr1 == dwg->header_vars.USERR1)
      pass ("HEADER.USERR1 [double]");
    else
      {
        fail ("HEADER.USERR1 [double] %g != %g", dwg->header_vars.USERR1, userr1); error++;
      }
  }
  {
    double userr2;
    if (dwg_dynapi_header_value(dwg, "USERR2", &userr2, NULL) &&
        userr2 == dwg->header_vars.USERR2)
      pass ("HEADER.USERR2 [double]");
    else
      {
        fail ("HEADER.USERR2 [double] %g != %g", dwg->header_vars.USERR2, userr2); error++;
      }
  }
  {
    double userr3;
    if (dwg_dynapi_header_value(dwg, "USERR3", &userr3, NULL) &&
        userr3 == dwg->header_vars.USERR3)
      pass ("HEADER.USERR3 [double]");
    else
      {
        fail ("HEADER.USERR3 [double] %g != %g", dwg->header_vars.USERR3, userr3); error++;
      }
  }
  {
    double userr4;
    if (dwg_dynapi_header_value(dwg, "USERR4", &userr4, NULL) &&
        userr4 == dwg->header_vars.USERR4)
      pass ("HEADER.USERR4 [double]");
    else
      {
        fail ("HEADER.USERR4 [double] %g != %g", dwg->header_vars.USERR4, userr4); error++;
      }
  }
  {
    double userr5;
    if (dwg_dynapi_header_value(dwg, "USERR5", &userr5, NULL) &&
        userr5 == dwg->header_vars.USERR5)
      pass ("HEADER.USERR5 [double]");
    else
      {
        fail ("HEADER.USERR5 [double] %g != %g", dwg->header_vars.USERR5, userr5); error++;
      }
  }
  {
    double chamfera;
    if (dwg_dynapi_header_value(dwg, "CHAMFERA", &chamfera, NULL) &&
        chamfera == dwg->header_vars.CHAMFERA)
      pass ("HEADER.CHAMFERA [double]");
    else
      {
        fail ("HEADER.CHAMFERA [double] %g != %g", dwg->header_vars.CHAMFERA, chamfera); error++;
      }
  }
  {
    double chamferb;
    if (dwg_dynapi_header_value(dwg, "CHAMFERB", &chamferb, NULL) &&
        chamferb == dwg->header_vars.CHAMFERB)
      pass ("HEADER.CHAMFERB [double]");
    else
      {
        fail ("HEADER.CHAMFERB [double] %g != %g", dwg->header_vars.CHAMFERB, chamferb); error++;
      }
  }
  {
    double chamferc;
    if (dwg_dynapi_header_value(dwg, "CHAMFERC", &chamferc, NULL) &&
        chamferc == dwg->header_vars.CHAMFERC)
      pass ("HEADER.CHAMFERC [double]");
    else
      {
        fail ("HEADER.CHAMFERC [double] %g != %g", dwg->header_vars.CHAMFERC, chamferc); error++;
      }
  }
  {
    double chamferd;
    if (dwg_dynapi_header_value(dwg, "CHAMFERD", &chamferd, NULL) &&
        chamferd == dwg->header_vars.CHAMFERD)
      pass ("HEADER.CHAMFERD [double]");
    else
      {
        fail ("HEADER.CHAMFERD [double] %g != %g", dwg->header_vars.CHAMFERD, chamferd); error++;
      }
  }
  {
    double facetres;
    if (dwg_dynapi_header_value(dwg, "FACETRES", &facetres, NULL) &&
        facetres == dwg->header_vars.FACETRES)
      pass ("HEADER.FACETRES [double]");
    else
      {
        fail ("HEADER.FACETRES [double] %g != %g", dwg->header_vars.FACETRES, facetres); error++;
      }
  }
  {
    double cmlscale;
    if (dwg_dynapi_header_value(dwg, "CMLSCALE", &cmlscale, NULL) &&
        cmlscale == dwg->header_vars.CMLSCALE)
      pass ("HEADER.CMLSCALE [double]");
    else
      {
        fail ("HEADER.CMLSCALE [double] %g != %g", dwg->header_vars.CMLSCALE, cmlscale); error++;
      }
  }
  {
    double celtscale;
    if (dwg_dynapi_header_value(dwg, "CELTSCALE", &celtscale, NULL) &&
        celtscale == dwg->header_vars.CELTSCALE)
      pass ("HEADER.CELTSCALE [double]");
    else
      {
        fail ("HEADER.CELTSCALE [double] %g != %g", dwg->header_vars.CELTSCALE, celtscale); error++;
      }
  }
  {
    char* menu;
    if (dwg_dynapi_header_value(dwg, "MENU", &menu, NULL)
        && !memcmp(&menu, &dwg->header_vars.MENU, sizeof(dwg->header_vars.MENU))
       )
      pass ("HEADER.MENU [char*]");
    else
      {
        fail ("HEADER.MENU [char*]"); error++;
      }
  }
  {
    Dwg_Bitcode_TimeBLL tdcreate;
    if (dwg_dynapi_header_value(dwg, "TDCREATE", &tdcreate, NULL)
        && !memcmp(&tdcreate, &dwg->header_vars.TDCREATE, sizeof(dwg->header_vars.TDCREATE))
       )
      pass ("HEADER.TDCREATE [Dwg_Bitcode_TimeBLL]");
    else
      {
        fail ("HEADER.TDCREATE [Dwg_Bitcode_TimeBLL]"); error++;
      }
  }
  {
    Dwg_Bitcode_TimeBLL tdupdate;
    if (dwg_dynapi_header_value(dwg, "TDUPDATE", &tdupdate, NULL)
        && !memcmp(&tdupdate, &dwg->header_vars.TDUPDATE, sizeof(dwg->header_vars.TDUPDATE))
       )
      pass ("HEADER.TDUPDATE [Dwg_Bitcode_TimeBLL]");
    else
      {
        fail ("HEADER.TDUPDATE [Dwg_Bitcode_TimeBLL]"); error++;
      }
  }
  {
    unsigned int unknown_15;
    if (dwg_dynapi_header_value(dwg, "unknown_15", &unknown_15, NULL) &&
        unknown_15 == dwg->header_vars.unknown_15)
      pass ("HEADER.unknown_15 [unsigned int]");
    else
      {
        fail ("HEADER.unknown_15 [unsigned int] %u != %u", dwg->header_vars.unknown_15, unknown_15); error++;
      }
  }
  {
    unsigned int unknown_16;
    if (dwg_dynapi_header_value(dwg, "unknown_16", &unknown_16, NULL) &&
        unknown_16 == dwg->header_vars.unknown_16)
      pass ("HEADER.unknown_16 [unsigned int]");
    else
      {
        fail ("HEADER.unknown_16 [unsigned int] %u != %u", dwg->header_vars.unknown_16, unknown_16); error++;
      }
  }
  {
    unsigned int unknown_17;
    if (dwg_dynapi_header_value(dwg, "unknown_17", &unknown_17, NULL) &&
        unknown_17 == dwg->header_vars.unknown_17)
      pass ("HEADER.unknown_17 [unsigned int]");
    else
      {
        fail ("HEADER.unknown_17 [unsigned int] %u != %u", dwg->header_vars.unknown_17, unknown_17); error++;
      }
  }
  {
    Dwg_Bitcode_TimeBLL tdindwg;
    if (dwg_dynapi_header_value(dwg, "TDINDWG", &tdindwg, NULL)
        && !memcmp(&tdindwg, &dwg->header_vars.TDINDWG, sizeof(dwg->header_vars.TDINDWG))
       )
      pass ("HEADER.TDINDWG [Dwg_Bitcode_TimeBLL]");
    else
      {
        fail ("HEADER.TDINDWG [Dwg_Bitcode_TimeBLL]"); error++;
      }
  }
  {
    Dwg_Bitcode_TimeBLL tdusrtimer;
    if (dwg_dynapi_header_value(dwg, "TDUSRTIMER", &tdusrtimer, NULL)
        && !memcmp(&tdusrtimer, &dwg->header_vars.TDUSRTIMER, sizeof(dwg->header_vars.TDUSRTIMER))
       )
      pass ("HEADER.TDUSRTIMER [Dwg_Bitcode_TimeBLL]");
    else
      {
        fail ("HEADER.TDUSRTIMER [Dwg_Bitcode_TimeBLL]"); error++;
      }
  }
  {
    Dwg_Color cecolor;
    if (dwg_dynapi_header_value(dwg, "CECOLOR", &cecolor, NULL)
        && !memcmp(&cecolor, &dwg->header_vars.CECOLOR, sizeof(dwg->header_vars.CECOLOR))
       )
      pass ("HEADER.CECOLOR [Dwg_Color]");
    else
      {
        fail ("HEADER.CECOLOR [Dwg_Color]"); error++;
      }
  }
  {
    unsigned short int cecolor_idx;
    if (dwg_dynapi_header_value(dwg, "CECOLOR_idx", &cecolor_idx, NULL) &&
        cecolor_idx == dwg->header_vars.CECOLOR_idx)
      pass ("HEADER.CECOLOR_idx [unsigned short int]");
    else
      {
        fail ("HEADER.CECOLOR_idx [unsigned short int] %hu != %hu", dwg->header_vars.CECOLOR_idx, cecolor_idx); error++;
      }
  }
  {
    unsigned short int handling;
    if (dwg_dynapi_header_value(dwg, "HANDLING", &handling, NULL) &&
        handling == dwg->header_vars.HANDLING)
      pass ("HEADER.HANDLING [unsigned short int]");
    else
      {
        fail ("HEADER.HANDLING [unsigned short int] %hu != %hu", dwg->header_vars.HANDLING, handling); error++;
      }
  }
  {
    unsigned short int handseed_r11;
    if (dwg_dynapi_header_value(dwg, "HANDSEED_R11", &handseed_r11, NULL) &&
        handseed_r11 == dwg->header_vars.HANDSEED_R11)
      pass ("HEADER.HANDSEED_R11 [unsigned short int]");
    else
      {
        fail ("HEADER.HANDSEED_R11 [unsigned short int] %hu != %hu", dwg->header_vars.HANDSEED_R11, handseed_r11); error++;
      }
  }
  {
    Dwg_Object_Ref* handseed;
    if (dwg_dynapi_header_value(dwg, "HANDSEED", &handseed, NULL)
        && !memcmp(&handseed, &dwg->header_vars.HANDSEED, sizeof(dwg->header_vars.HANDSEED))
       )
      pass ("HEADER.HANDSEED [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.HANDSEED [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    Dwg_Object_Ref* clayer;
    if (dwg_dynapi_header_value(dwg, "CLAYER", &clayer, NULL)
        && !memcmp(&clayer, &dwg->header_vars.CLAYER, sizeof(dwg->header_vars.CLAYER))
       )
      pass ("HEADER.CLAYER [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.CLAYER [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    Dwg_Object_Ref* textstyle;
    if (dwg_dynapi_header_value(dwg, "TEXTSTYLE", &textstyle, NULL)
        && !memcmp(&textstyle, &dwg->header_vars.TEXTSTYLE, sizeof(dwg->header_vars.TEXTSTYLE))
       )
      pass ("HEADER.TEXTSTYLE [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.TEXTSTYLE [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    Dwg_Object_Ref* celtype;
    if (dwg_dynapi_header_value(dwg, "CELTYPE", &celtype, NULL)
        && !memcmp(&celtype, &dwg->header_vars.CELTYPE, sizeof(dwg->header_vars.CELTYPE))
       )
      pass ("HEADER.CELTYPE [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.CELTYPE [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    Dwg_Object_Ref* cmaterial;
    if (dwg_dynapi_header_value(dwg, "CMATERIAL", &cmaterial, NULL)
        && !memcmp(&cmaterial, &dwg->header_vars.CMATERIAL, sizeof(dwg->header_vars.CMATERIAL))
       )
      pass ("HEADER.CMATERIAL [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.CMATERIAL [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    Dwg_Object_Ref* dimstyle;
    if (dwg_dynapi_header_value(dwg, "DIMSTYLE", &dimstyle, NULL)
        && !memcmp(&dimstyle, &dwg->header_vars.DIMSTYLE, sizeof(dwg->header_vars.DIMSTYLE))
       )
      pass ("HEADER.DIMSTYLE [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.DIMSTYLE [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    Dwg_Object_Ref* cmlstyle;
    if (dwg_dynapi_header_value(dwg, "CMLSTYLE", &cmlstyle, NULL)
        && !memcmp(&cmlstyle, &dwg->header_vars.CMLSTYLE, sizeof(dwg->header_vars.CMLSTYLE))
       )
      pass ("HEADER.CMLSTYLE [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.CMLSTYLE [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    double psvpscale;
    if (dwg_dynapi_header_value(dwg, "PSVPSCALE", &psvpscale, NULL) &&
        psvpscale == dwg->header_vars.PSVPSCALE)
      pass ("HEADER.PSVPSCALE [double]");
    else
      {
        fail ("HEADER.PSVPSCALE [double] %g != %g", dwg->header_vars.PSVPSCALE, psvpscale); error++;
      }
  }
  {
    Dwg_Bitcode_3BD pinsbase;
    if (dwg_dynapi_header_value(dwg, "PINSBASE", &pinsbase, NULL)
        && !memcmp(&pinsbase, &dwg->header_vars.PINSBASE, sizeof(dwg->header_vars.PINSBASE))
       )
      pass ("HEADER.PINSBASE [Dwg_Bitcode_3BD]");
    else
      {
        fail ("HEADER.PINSBASE [Dwg_Bitcode_3BD]"); error++;
      }
  }
  {
    Dwg_Bitcode_3BD pextmin;
    if (dwg_dynapi_header_value(dwg, "PEXTMIN", &pextmin, NULL)
        && !memcmp(&pextmin, &dwg->header_vars.PEXTMIN, sizeof(dwg->header_vars.PEXTMIN))
       )
      pass ("HEADER.PEXTMIN [Dwg_Bitcode_3BD]");
    else
      {
        fail ("HEADER.PEXTMIN [Dwg_Bitcode_3BD]"); error++;
      }
  }
  {
    Dwg_Bitcode_3BD pextmax;
    if (dwg_dynapi_header_value(dwg, "PEXTMAX", &pextmax, NULL)
        && !memcmp(&pextmax, &dwg->header_vars.PEXTMAX, sizeof(dwg->header_vars.PEXTMAX))
       )
      pass ("HEADER.PEXTMAX [Dwg_Bitcode_3BD]");
    else
      {
        fail ("HEADER.PEXTMAX [Dwg_Bitcode_3BD]"); error++;
      }
  }
  {
    Dwg_Bitcode_2RD plimmin;
    if (dwg_dynapi_header_value(dwg, "PLIMMIN", &plimmin, NULL)
        && !memcmp(&plimmin, &dwg->header_vars.PLIMMIN, sizeof(dwg->header_vars.PLIMMIN))
       )
      pass ("HEADER.PLIMMIN [Dwg_Bitcode_2RD]");
    else
      {
        fail ("HEADER.PLIMMIN [Dwg_Bitcode_2RD]"); error++;
      }
  }
  {
    Dwg_Bitcode_2RD plimmax;
    if (dwg_dynapi_header_value(dwg, "PLIMMAX", &plimmax, NULL)
        && !memcmp(&plimmax, &dwg->header_vars.PLIMMAX, sizeof(dwg->header_vars.PLIMMAX))
       )
      pass ("HEADER.PLIMMAX [Dwg_Bitcode_2RD]");
    else
      {
        fail ("HEADER.PLIMMAX [Dwg_Bitcode_2RD]"); error++;
      }
  }
  {
    double pelevation;
    if (dwg_dynapi_header_value(dwg, "PELEVATION", &pelevation, NULL) &&
        pelevation == dwg->header_vars.PELEVATION)
      pass ("HEADER.PELEVATION [double]");
    else
      {
        fail ("HEADER.PELEVATION [double] %g != %g", dwg->header_vars.PELEVATION, pelevation); error++;
      }
  }
  {
    Dwg_Bitcode_3BD pucsorg;
    if (dwg_dynapi_header_value(dwg, "PUCSORG", &pucsorg, NULL)
        && !memcmp(&pucsorg, &dwg->header_vars.PUCSORG, sizeof(dwg->header_vars.PUCSORG))
       )
      pass ("HEADER.PUCSORG [Dwg_Bitcode_3BD]");
    else
      {
        fail ("HEADER.PUCSORG [Dwg_Bitcode_3BD]"); error++;
      }
  }
  {
    Dwg_Bitcode_3BD pucsxdir;
    if (dwg_dynapi_header_value(dwg, "PUCSXDIR", &pucsxdir, NULL)
        && !memcmp(&pucsxdir, &dwg->header_vars.PUCSXDIR, sizeof(dwg->header_vars.PUCSXDIR))
       )
      pass ("HEADER.PUCSXDIR [Dwg_Bitcode_3BD]");
    else
      {
        fail ("HEADER.PUCSXDIR [Dwg_Bitcode_3BD]"); error++;
      }
  }
  {
    Dwg_Bitcode_3BD pucsydir;
    if (dwg_dynapi_header_value(dwg, "PUCSYDIR", &pucsydir, NULL)
        && !memcmp(&pucsydir, &dwg->header_vars.PUCSYDIR, sizeof(dwg->header_vars.PUCSYDIR))
       )
      pass ("HEADER.PUCSYDIR [Dwg_Bitcode_3BD]");
    else
      {
        fail ("HEADER.PUCSYDIR [Dwg_Bitcode_3BD]"); error++;
      }
  }
  {
    Dwg_Object_Ref* pucsname;
    if (dwg_dynapi_header_value(dwg, "PUCSNAME", &pucsname, NULL)
        && !memcmp(&pucsname, &dwg->header_vars.PUCSNAME, sizeof(dwg->header_vars.PUCSNAME))
       )
      pass ("HEADER.PUCSNAME [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.PUCSNAME [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    Dwg_Object_Ref* pucsbase;
    if (dwg_dynapi_header_value(dwg, "PUCSBASE", &pucsbase, NULL)
        && !memcmp(&pucsbase, &dwg->header_vars.PUCSBASE, sizeof(dwg->header_vars.PUCSBASE))
       )
      pass ("HEADER.PUCSBASE [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.PUCSBASE [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    Dwg_Object_Ref* pucsorthoref;
    if (dwg_dynapi_header_value(dwg, "PUCSORTHOREF", &pucsorthoref, NULL)
        && !memcmp(&pucsorthoref, &dwg->header_vars.PUCSORTHOREF, sizeof(dwg->header_vars.PUCSORTHOREF))
       )
      pass ("HEADER.PUCSORTHOREF [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.PUCSORTHOREF [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    unsigned short int pucsorthoview;
    if (dwg_dynapi_header_value(dwg, "PUCSORTHOVIEW", &pucsorthoview, NULL) &&
        pucsorthoview == dwg->header_vars.PUCSORTHOVIEW)
      pass ("HEADER.PUCSORTHOVIEW [unsigned short int]");
    else
      {
        fail ("HEADER.PUCSORTHOVIEW [unsigned short int] %hu != %hu", dwg->header_vars.PUCSORTHOVIEW, pucsorthoview); error++;
      }
  }
  {
    Dwg_Bitcode_3BD pucsorgtop;
    if (dwg_dynapi_header_value(dwg, "PUCSORGTOP", &pucsorgtop, NULL)
        && !memcmp(&pucsorgtop, &dwg->header_vars.PUCSORGTOP, sizeof(dwg->header_vars.PUCSORGTOP))
       )
      pass ("HEADER.PUCSORGTOP [Dwg_Bitcode_3BD]");
    else
      {
        fail ("HEADER.PUCSORGTOP [Dwg_Bitcode_3BD]"); error++;
      }
  }
  {
    Dwg_Bitcode_3BD pucsorgbottom;
    if (dwg_dynapi_header_value(dwg, "PUCSORGBOTTOM", &pucsorgbottom, NULL)
        && !memcmp(&pucsorgbottom, &dwg->header_vars.PUCSORGBOTTOM, sizeof(dwg->header_vars.PUCSORGBOTTOM))
       )
      pass ("HEADER.PUCSORGBOTTOM [Dwg_Bitcode_3BD]");
    else
      {
        fail ("HEADER.PUCSORGBOTTOM [Dwg_Bitcode_3BD]"); error++;
      }
  }
  {
    Dwg_Bitcode_3BD pucsorgleft;
    if (dwg_dynapi_header_value(dwg, "PUCSORGLEFT", &pucsorgleft, NULL)
        && !memcmp(&pucsorgleft, &dwg->header_vars.PUCSORGLEFT, sizeof(dwg->header_vars.PUCSORGLEFT))
       )
      pass ("HEADER.PUCSORGLEFT [Dwg_Bitcode_3BD]");
    else
      {
        fail ("HEADER.PUCSORGLEFT [Dwg_Bitcode_3BD]"); error++;
      }
  }
  {
    Dwg_Bitcode_3BD pucsorgright;
    if (dwg_dynapi_header_value(dwg, "PUCSORGRIGHT", &pucsorgright, NULL)
        && !memcmp(&pucsorgright, &dwg->header_vars.PUCSORGRIGHT, sizeof(dwg->header_vars.PUCSORGRIGHT))
       )
      pass ("HEADER.PUCSORGRIGHT [Dwg_Bitcode_3BD]");
    else
      {
        fail ("HEADER.PUCSORGRIGHT [Dwg_Bitcode_3BD]"); error++;
      }
  }
  {
    Dwg_Bitcode_3BD pucsorgfront;
    if (dwg_dynapi_header_value(dwg, "PUCSORGFRONT", &pucsorgfront, NULL)
        && !memcmp(&pucsorgfront, &dwg->header_vars.PUCSORGFRONT, sizeof(dwg->header_vars.PUCSORGFRONT))
       )
      pass ("HEADER.PUCSORGFRONT [Dwg_Bitcode_3BD]");
    else
      {
        fail ("HEADER.PUCSORGFRONT [Dwg_Bitcode_3BD]"); error++;
      }
  }
  {
    Dwg_Bitcode_3BD pucsorgback;
    if (dwg_dynapi_header_value(dwg, "PUCSORGBACK", &pucsorgback, NULL)
        && !memcmp(&pucsorgback, &dwg->header_vars.PUCSORGBACK, sizeof(dwg->header_vars.PUCSORGBACK))
       )
      pass ("HEADER.PUCSORGBACK [Dwg_Bitcode_3BD]");
    else
      {
        fail ("HEADER.PUCSORGBACK [Dwg_Bitcode_3BD]"); error++;
      }
  }
  {
    Dwg_Bitcode_3BD insbase;
    if (dwg_dynapi_header_value(dwg, "INSBASE", &insbase, NULL)
        && !memcmp(&insbase, &dwg->header_vars.INSBASE, sizeof(dwg->header_vars.INSBASE))
       )
      pass ("HEADER.INSBASE [Dwg_Bitcode_3BD]");
    else
      {
        fail ("HEADER.INSBASE [Dwg_Bitcode_3BD]"); error++;
      }
  }
  {
    Dwg_Bitcode_3BD extmin;
    if (dwg_dynapi_header_value(dwg, "EXTMIN", &extmin, NULL)
        && !memcmp(&extmin, &dwg->header_vars.EXTMIN, sizeof(dwg->header_vars.EXTMIN))
       )
      pass ("HEADER.EXTMIN [Dwg_Bitcode_3BD]");
    else
      {
        fail ("HEADER.EXTMIN [Dwg_Bitcode_3BD]"); error++;
      }
  }
  {
    Dwg_Bitcode_3BD extmax;
    if (dwg_dynapi_header_value(dwg, "EXTMAX", &extmax, NULL)
        && !memcmp(&extmax, &dwg->header_vars.EXTMAX, sizeof(dwg->header_vars.EXTMAX))
       )
      pass ("HEADER.EXTMAX [Dwg_Bitcode_3BD]");
    else
      {
        fail ("HEADER.EXTMAX [Dwg_Bitcode_3BD]"); error++;
      }
  }
  {
    Dwg_Bitcode_2RD limmin;
    if (dwg_dynapi_header_value(dwg, "LIMMIN", &limmin, NULL)
        && !memcmp(&limmin, &dwg->header_vars.LIMMIN, sizeof(dwg->header_vars.LIMMIN))
       )
      pass ("HEADER.LIMMIN [Dwg_Bitcode_2RD]");
    else
      {
        fail ("HEADER.LIMMIN [Dwg_Bitcode_2RD]"); error++;
      }
  }
  {
    Dwg_Bitcode_2RD limmax;
    if (dwg_dynapi_header_value(dwg, "LIMMAX", &limmax, NULL)
        && !memcmp(&limmax, &dwg->header_vars.LIMMAX, sizeof(dwg->header_vars.LIMMAX))
       )
      pass ("HEADER.LIMMAX [Dwg_Bitcode_2RD]");
    else
      {
        fail ("HEADER.LIMMAX [Dwg_Bitcode_2RD]"); error++;
      }
  }
  {
    Dwg_Bitcode_2RD viewctr;
    if (dwg_dynapi_header_value(dwg, "VIEWCTR", &viewctr, NULL)
        && !memcmp(&viewctr, &dwg->header_vars.VIEWCTR, sizeof(dwg->header_vars.VIEWCTR))
       )
      pass ("HEADER.VIEWCTR [Dwg_Bitcode_2RD]");
    else
      {
        fail ("HEADER.VIEWCTR [Dwg_Bitcode_2RD]"); error++;
      }
  }
  {
    double elevation;
    if (dwg_dynapi_header_value(dwg, "ELEVATION", &elevation, NULL) &&
        elevation == dwg->header_vars.ELEVATION)
      pass ("HEADER.ELEVATION [double]");
    else
      {
        fail ("HEADER.ELEVATION [double] %g != %g", dwg->header_vars.ELEVATION, elevation); error++;
      }
  }
  {
    double viewsize;
    if (dwg_dynapi_header_value(dwg, "VIEWSIZE", &viewsize, NULL) &&
        viewsize == dwg->header_vars.VIEWSIZE)
      pass ("HEADER.VIEWSIZE [double]");
    else
      {
        fail ("HEADER.VIEWSIZE [double] %g != %g", dwg->header_vars.VIEWSIZE, viewsize); error++;
      }
  }
  {
    unsigned short int snapmode;
    if (dwg_dynapi_header_value(dwg, "SNAPMODE", &snapmode, NULL) &&
        snapmode == dwg->header_vars.SNAPMODE)
      pass ("HEADER.SNAPMODE [unsigned short int]");
    else
      {
        fail ("HEADER.SNAPMODE [unsigned short int] %hu != %hu", dwg->header_vars.SNAPMODE, snapmode); error++;
      }
  }
  {
    Dwg_Bitcode_2RD snapunit;
    if (dwg_dynapi_header_value(dwg, "SNAPUNIT", &snapunit, NULL)
        && !memcmp(&snapunit, &dwg->header_vars.SNAPUNIT, sizeof(dwg->header_vars.SNAPUNIT))
       )
      pass ("HEADER.SNAPUNIT [Dwg_Bitcode_2RD]");
    else
      {
        fail ("HEADER.SNAPUNIT [Dwg_Bitcode_2RD]"); error++;
      }
  }
  {
    Dwg_Bitcode_2RD snapbase;
    if (dwg_dynapi_header_value(dwg, "SNAPBASE", &snapbase, NULL)
        && !memcmp(&snapbase, &dwg->header_vars.SNAPBASE, sizeof(dwg->header_vars.SNAPBASE))
       )
      pass ("HEADER.SNAPBASE [Dwg_Bitcode_2RD]");
    else
      {
        fail ("HEADER.SNAPBASE [Dwg_Bitcode_2RD]"); error++;
      }
  }
  {
    double snapang;
    if (dwg_dynapi_header_value(dwg, "SNAPANG", &snapang, NULL) &&
        snapang == dwg->header_vars.SNAPANG)
      pass ("HEADER.SNAPANG [double]");
    else
      {
        fail ("HEADER.SNAPANG [double] %g != %g", dwg->header_vars.SNAPANG, snapang); error++;
      }
  }
  {
    unsigned short int snapstyl;
    if (dwg_dynapi_header_value(dwg, "SNAPSTYL", &snapstyl, NULL) &&
        snapstyl == dwg->header_vars.SNAPSTYL)
      pass ("HEADER.SNAPSTYL [unsigned short int]");
    else
      {
        fail ("HEADER.SNAPSTYL [unsigned short int] %hu != %hu", dwg->header_vars.SNAPSTYL, snapstyl); error++;
      }
  }
  {
    unsigned short int snapisopair;
    if (dwg_dynapi_header_value(dwg, "SNAPISOPAIR", &snapisopair, NULL) &&
        snapisopair == dwg->header_vars.SNAPISOPAIR)
      pass ("HEADER.SNAPISOPAIR [unsigned short int]");
    else
      {
        fail ("HEADER.SNAPISOPAIR [unsigned short int] %hu != %hu", dwg->header_vars.SNAPISOPAIR, snapisopair); error++;
      }
  }
  {
    unsigned short int gridmode;
    if (dwg_dynapi_header_value(dwg, "GRIDMODE", &gridmode, NULL) &&
        gridmode == dwg->header_vars.GRIDMODE)
      pass ("HEADER.GRIDMODE [unsigned short int]");
    else
      {
        fail ("HEADER.GRIDMODE [unsigned short int] %hu != %hu", dwg->header_vars.GRIDMODE, gridmode); error++;
      }
  }
  {
    Dwg_Bitcode_2RD gridunit;
    if (dwg_dynapi_header_value(dwg, "GRIDUNIT", &gridunit, NULL)
        && !memcmp(&gridunit, &dwg->header_vars.GRIDUNIT, sizeof(dwg->header_vars.GRIDUNIT))
       )
      pass ("HEADER.GRIDUNIT [Dwg_Bitcode_2RD]");
    else
      {
        fail ("HEADER.GRIDUNIT [Dwg_Bitcode_2RD]"); error++;
      }
  }
  {
    Dwg_Bitcode_3BD ucsorg;
    if (dwg_dynapi_header_value(dwg, "UCSORG", &ucsorg, NULL)
        && !memcmp(&ucsorg, &dwg->header_vars.UCSORG, sizeof(dwg->header_vars.UCSORG))
       )
      pass ("HEADER.UCSORG [Dwg_Bitcode_3BD]");
    else
      {
        fail ("HEADER.UCSORG [Dwg_Bitcode_3BD]"); error++;
      }
  }
  {
    Dwg_Bitcode_3BD ucsxdir;
    if (dwg_dynapi_header_value(dwg, "UCSXDIR", &ucsxdir, NULL)
        && !memcmp(&ucsxdir, &dwg->header_vars.UCSXDIR, sizeof(dwg->header_vars.UCSXDIR))
       )
      pass ("HEADER.UCSXDIR [Dwg_Bitcode_3BD]");
    else
      {
        fail ("HEADER.UCSXDIR [Dwg_Bitcode_3BD]"); error++;
      }
  }
  {
    Dwg_Bitcode_3BD ucsydir;
    if (dwg_dynapi_header_value(dwg, "UCSYDIR", &ucsydir, NULL)
        && !memcmp(&ucsydir, &dwg->header_vars.UCSYDIR, sizeof(dwg->header_vars.UCSYDIR))
       )
      pass ("HEADER.UCSYDIR [Dwg_Bitcode_3BD]");
    else
      {
        fail ("HEADER.UCSYDIR [Dwg_Bitcode_3BD]"); error++;
      }
  }
  {
    Dwg_Object_Ref* ucsname;
    if (dwg_dynapi_header_value(dwg, "UCSNAME", &ucsname, NULL)
        && !memcmp(&ucsname, &dwg->header_vars.UCSNAME, sizeof(dwg->header_vars.UCSNAME))
       )
      pass ("HEADER.UCSNAME [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.UCSNAME [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    Dwg_Object_Ref* ucsbase;
    if (dwg_dynapi_header_value(dwg, "UCSBASE", &ucsbase, NULL)
        && !memcmp(&ucsbase, &dwg->header_vars.UCSBASE, sizeof(dwg->header_vars.UCSBASE))
       )
      pass ("HEADER.UCSBASE [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.UCSBASE [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    unsigned short int ucsorthoview;
    if (dwg_dynapi_header_value(dwg, "UCSORTHOVIEW", &ucsorthoview, NULL) &&
        ucsorthoview == dwg->header_vars.UCSORTHOVIEW)
      pass ("HEADER.UCSORTHOVIEW [unsigned short int]");
    else
      {
        fail ("HEADER.UCSORTHOVIEW [unsigned short int] %hu != %hu", dwg->header_vars.UCSORTHOVIEW, ucsorthoview); error++;
      }
  }
  {
    Dwg_Object_Ref* ucsorthoref;
    if (dwg_dynapi_header_value(dwg, "UCSORTHOREF", &ucsorthoref, NULL)
        && !memcmp(&ucsorthoref, &dwg->header_vars.UCSORTHOREF, sizeof(dwg->header_vars.UCSORTHOREF))
       )
      pass ("HEADER.UCSORTHOREF [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.UCSORTHOREF [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    Dwg_Bitcode_3BD ucsorgtop;
    if (dwg_dynapi_header_value(dwg, "UCSORGTOP", &ucsorgtop, NULL)
        && !memcmp(&ucsorgtop, &dwg->header_vars.UCSORGTOP, sizeof(dwg->header_vars.UCSORGTOP))
       )
      pass ("HEADER.UCSORGTOP [Dwg_Bitcode_3BD]");
    else
      {
        fail ("HEADER.UCSORGTOP [Dwg_Bitcode_3BD]"); error++;
      }
  }
  {
    Dwg_Bitcode_3BD ucsorgbottom;
    if (dwg_dynapi_header_value(dwg, "UCSORGBOTTOM", &ucsorgbottom, NULL)
        && !memcmp(&ucsorgbottom, &dwg->header_vars.UCSORGBOTTOM, sizeof(dwg->header_vars.UCSORGBOTTOM))
       )
      pass ("HEADER.UCSORGBOTTOM [Dwg_Bitcode_3BD]");
    else
      {
        fail ("HEADER.UCSORGBOTTOM [Dwg_Bitcode_3BD]"); error++;
      }
  }
  {
    Dwg_Bitcode_3BD ucsorgleft;
    if (dwg_dynapi_header_value(dwg, "UCSORGLEFT", &ucsorgleft, NULL)
        && !memcmp(&ucsorgleft, &dwg->header_vars.UCSORGLEFT, sizeof(dwg->header_vars.UCSORGLEFT))
       )
      pass ("HEADER.UCSORGLEFT [Dwg_Bitcode_3BD]");
    else
      {
        fail ("HEADER.UCSORGLEFT [Dwg_Bitcode_3BD]"); error++;
      }
  }
  {
    Dwg_Bitcode_3BD ucsorgright;
    if (dwg_dynapi_header_value(dwg, "UCSORGRIGHT", &ucsorgright, NULL)
        && !memcmp(&ucsorgright, &dwg->header_vars.UCSORGRIGHT, sizeof(dwg->header_vars.UCSORGRIGHT))
       )
      pass ("HEADER.UCSORGRIGHT [Dwg_Bitcode_3BD]");
    else
      {
        fail ("HEADER.UCSORGRIGHT [Dwg_Bitcode_3BD]"); error++;
      }
  }
  {
    Dwg_Bitcode_3BD ucsorgfront;
    if (dwg_dynapi_header_value(dwg, "UCSORGFRONT", &ucsorgfront, NULL)
        && !memcmp(&ucsorgfront, &dwg->header_vars.UCSORGFRONT, sizeof(dwg->header_vars.UCSORGFRONT))
       )
      pass ("HEADER.UCSORGFRONT [Dwg_Bitcode_3BD]");
    else
      {
        fail ("HEADER.UCSORGFRONT [Dwg_Bitcode_3BD]"); error++;
      }
  }
  {
    Dwg_Bitcode_3BD ucsorgback;
    if (dwg_dynapi_header_value(dwg, "UCSORGBACK", &ucsorgback, NULL)
        && !memcmp(&ucsorgback, &dwg->header_vars.UCSORGBACK, sizeof(dwg->header_vars.UCSORGBACK))
       )
      pass ("HEADER.UCSORGBACK [Dwg_Bitcode_3BD]");
    else
      {
        fail ("HEADER.UCSORGBACK [Dwg_Bitcode_3BD]"); error++;
      }
  }
  {
    char* dimpost;
    if (dwg_dynapi_header_value(dwg, "DIMPOST", &dimpost, NULL)
        && !memcmp(&dimpost, &dwg->header_vars.DIMPOST, sizeof(dwg->header_vars.DIMPOST))
       )
      pass ("HEADER.DIMPOST [char*]");
    else
      {
        fail ("HEADER.DIMPOST [char*]"); error++;
      }
  }
  {
    char* dimapost;
    if (dwg_dynapi_header_value(dwg, "DIMAPOST", &dimapost, NULL)
        && !memcmp(&dimapost, &dwg->header_vars.DIMAPOST, sizeof(dwg->header_vars.DIMAPOST))
       )
      pass ("HEADER.DIMAPOST [char*]");
    else
      {
        fail ("HEADER.DIMAPOST [char*]"); error++;
      }
  }
  {
    unsigned char dimtol;
    if (dwg_dynapi_header_value(dwg, "DIMTOL", &dimtol, NULL) &&
        dimtol == dwg->header_vars.DIMTOL)
      pass ("HEADER.DIMTOL [unsigned char]");
    else
      {
        fail ("HEADER.DIMTOL [unsigned char] %c != %c", dwg->header_vars.DIMTOL, dimtol); error++;
      }
  }
  {
    unsigned char dimlim;
    if (dwg_dynapi_header_value(dwg, "DIMLIM", &dimlim, NULL) &&
        dimlim == dwg->header_vars.DIMLIM)
      pass ("HEADER.DIMLIM [unsigned char]");
    else
      {
        fail ("HEADER.DIMLIM [unsigned char] %c != %c", dwg->header_vars.DIMLIM, dimlim); error++;
      }
  }
  {
    unsigned char dimtih;
    if (dwg_dynapi_header_value(dwg, "DIMTIH", &dimtih, NULL) &&
        dimtih == dwg->header_vars.DIMTIH)
      pass ("HEADER.DIMTIH [unsigned char]");
    else
      {
        fail ("HEADER.DIMTIH [unsigned char] %c != %c", dwg->header_vars.DIMTIH, dimtih); error++;
      }
  }
  {
    unsigned char dimtoh;
    if (dwg_dynapi_header_value(dwg, "DIMTOH", &dimtoh, NULL) &&
        dimtoh == dwg->header_vars.DIMTOH)
      pass ("HEADER.DIMTOH [unsigned char]");
    else
      {
        fail ("HEADER.DIMTOH [unsigned char] %c != %c", dwg->header_vars.DIMTOH, dimtoh); error++;
      }
  }
  {
    unsigned char dimse1;
    if (dwg_dynapi_header_value(dwg, "DIMSE1", &dimse1, NULL) &&
        dimse1 == dwg->header_vars.DIMSE1)
      pass ("HEADER.DIMSE1 [unsigned char]");
    else
      {
        fail ("HEADER.DIMSE1 [unsigned char] %c != %c", dwg->header_vars.DIMSE1, dimse1); error++;
      }
  }
  {
    unsigned char dimse2;
    if (dwg_dynapi_header_value(dwg, "DIMSE2", &dimse2, NULL) &&
        dimse2 == dwg->header_vars.DIMSE2)
      pass ("HEADER.DIMSE2 [unsigned char]");
    else
      {
        fail ("HEADER.DIMSE2 [unsigned char] %c != %c", dwg->header_vars.DIMSE2, dimse2); error++;
      }
  }
  {
    unsigned char dimalt;
    if (dwg_dynapi_header_value(dwg, "DIMALT", &dimalt, NULL) &&
        dimalt == dwg->header_vars.DIMALT)
      pass ("HEADER.DIMALT [unsigned char]");
    else
      {
        fail ("HEADER.DIMALT [unsigned char] %c != %c", dwg->header_vars.DIMALT, dimalt); error++;
      }
  }
  {
    unsigned char dimtofl;
    if (dwg_dynapi_header_value(dwg, "DIMTOFL", &dimtofl, NULL) &&
        dimtofl == dwg->header_vars.DIMTOFL)
      pass ("HEADER.DIMTOFL [unsigned char]");
    else
      {
        fail ("HEADER.DIMTOFL [unsigned char] %c != %c", dwg->header_vars.DIMTOFL, dimtofl); error++;
      }
  }
  {
    unsigned char dimsah;
    if (dwg_dynapi_header_value(dwg, "DIMSAH", &dimsah, NULL) &&
        dimsah == dwg->header_vars.DIMSAH)
      pass ("HEADER.DIMSAH [unsigned char]");
    else
      {
        fail ("HEADER.DIMSAH [unsigned char] %c != %c", dwg->header_vars.DIMSAH, dimsah); error++;
      }
  }
  {
    unsigned char dimtix;
    if (dwg_dynapi_header_value(dwg, "DIMTIX", &dimtix, NULL) &&
        dimtix == dwg->header_vars.DIMTIX)
      pass ("HEADER.DIMTIX [unsigned char]");
    else
      {
        fail ("HEADER.DIMTIX [unsigned char] %c != %c", dwg->header_vars.DIMTIX, dimtix); error++;
      }
  }
  {
    unsigned char dimsoxd;
    if (dwg_dynapi_header_value(dwg, "DIMSOXD", &dimsoxd, NULL) &&
        dimsoxd == dwg->header_vars.DIMSOXD)
      pass ("HEADER.DIMSOXD [unsigned char]");
    else
      {
        fail ("HEADER.DIMSOXD [unsigned char] %c != %c", dwg->header_vars.DIMSOXD, dimsoxd); error++;
      }
  }
  {
    unsigned short int dimaltd;
    if (dwg_dynapi_header_value(dwg, "DIMALTD", &dimaltd, NULL) &&
        dimaltd == dwg->header_vars.DIMALTD)
      pass ("HEADER.DIMALTD [unsigned short int]");
    else
      {
        fail ("HEADER.DIMALTD [unsigned short int] %hu != %hu", dwg->header_vars.DIMALTD, dimaltd); error++;
      }
  }
  {
    unsigned short int dimzin;
    if (dwg_dynapi_header_value(dwg, "DIMZIN", &dimzin, NULL) &&
        dimzin == dwg->header_vars.DIMZIN)
      pass ("HEADER.DIMZIN [unsigned short int]");
    else
      {
        fail ("HEADER.DIMZIN [unsigned short int] %hu != %hu", dwg->header_vars.DIMZIN, dimzin); error++;
      }
  }
  {
    unsigned char dimsd1;
    if (dwg_dynapi_header_value(dwg, "DIMSD1", &dimsd1, NULL) &&
        dimsd1 == dwg->header_vars.DIMSD1)
      pass ("HEADER.DIMSD1 [unsigned char]");
    else
      {
        fail ("HEADER.DIMSD1 [unsigned char] %c != %c", dwg->header_vars.DIMSD1, dimsd1); error++;
      }
  }
  {
    unsigned char dimsd2;
    if (dwg_dynapi_header_value(dwg, "DIMSD2", &dimsd2, NULL) &&
        dimsd2 == dwg->header_vars.DIMSD2)
      pass ("HEADER.DIMSD2 [unsigned char]");
    else
      {
        fail ("HEADER.DIMSD2 [unsigned char] %c != %c", dwg->header_vars.DIMSD2, dimsd2); error++;
      }
  }
  {
    unsigned short int dimtolj;
    if (dwg_dynapi_header_value(dwg, "DIMTOLJ", &dimtolj, NULL) &&
        dimtolj == dwg->header_vars.DIMTOLJ)
      pass ("HEADER.DIMTOLJ [unsigned short int]");
    else
      {
        fail ("HEADER.DIMTOLJ [unsigned short int] %hu != %hu", dwg->header_vars.DIMTOLJ, dimtolj); error++;
      }
  }
  {
    unsigned short int dimjust;
    if (dwg_dynapi_header_value(dwg, "DIMJUST", &dimjust, NULL) &&
        dimjust == dwg->header_vars.DIMJUST)
      pass ("HEADER.DIMJUST [unsigned short int]");
    else
      {
        fail ("HEADER.DIMJUST [unsigned short int] %hu != %hu", dwg->header_vars.DIMJUST, dimjust); error++;
      }
  }
  {
    unsigned short int dimfit;
    if (dwg_dynapi_header_value(dwg, "DIMFIT", &dimfit, NULL) &&
        dimfit == dwg->header_vars.DIMFIT)
      pass ("HEADER.DIMFIT [unsigned short int]");
    else
      {
        fail ("HEADER.DIMFIT [unsigned short int] %hu != %hu", dwg->header_vars.DIMFIT, dimfit); error++;
      }
  }
  {
    unsigned char dimupt;
    if (dwg_dynapi_header_value(dwg, "DIMUPT", &dimupt, NULL) &&
        dimupt == dwg->header_vars.DIMUPT)
      pass ("HEADER.DIMUPT [unsigned char]");
    else
      {
        fail ("HEADER.DIMUPT [unsigned char] %c != %c", dwg->header_vars.DIMUPT, dimupt); error++;
      }
  }
  {
    unsigned short int dimtzin;
    if (dwg_dynapi_header_value(dwg, "DIMTZIN", &dimtzin, NULL) &&
        dimtzin == dwg->header_vars.DIMTZIN)
      pass ("HEADER.DIMTZIN [unsigned short int]");
    else
      {
        fail ("HEADER.DIMTZIN [unsigned short int] %hu != %hu", dwg->header_vars.DIMTZIN, dimtzin); error++;
      }
  }
  {
    unsigned short int dimmaltz;
    if (dwg_dynapi_header_value(dwg, "DIMMALTZ", &dimmaltz, NULL) &&
        dimmaltz == dwg->header_vars.DIMMALTZ)
      pass ("HEADER.DIMMALTZ [unsigned short int]");
    else
      {
        fail ("HEADER.DIMMALTZ [unsigned short int] %hu != %hu", dwg->header_vars.DIMMALTZ, dimmaltz); error++;
      }
  }
  {
    unsigned short int dimmalttz;
    if (dwg_dynapi_header_value(dwg, "DIMMALTTZ", &dimmalttz, NULL) &&
        dimmalttz == dwg->header_vars.DIMMALTTZ)
      pass ("HEADER.DIMMALTTZ [unsigned short int]");
    else
      {
        fail ("HEADER.DIMMALTTZ [unsigned short int] %hu != %hu", dwg->header_vars.DIMMALTTZ, dimmalttz); error++;
      }
  }
  {
    unsigned short int dimtad;
    if (dwg_dynapi_header_value(dwg, "DIMTAD", &dimtad, NULL) &&
        dimtad == dwg->header_vars.DIMTAD)
      pass ("HEADER.DIMTAD [unsigned short int]");
    else
      {
        fail ("HEADER.DIMTAD [unsigned short int] %hu != %hu", dwg->header_vars.DIMTAD, dimtad); error++;
      }
  }
  {
    unsigned short int dimunit;
    if (dwg_dynapi_header_value(dwg, "DIMUNIT", &dimunit, NULL) &&
        dimunit == dwg->header_vars.DIMUNIT)
      pass ("HEADER.DIMUNIT [unsigned short int]");
    else
      {
        fail ("HEADER.DIMUNIT [unsigned short int] %hu != %hu", dwg->header_vars.DIMUNIT, dimunit); error++;
      }
  }
  {
    unsigned short int dimaunit;
    if (dwg_dynapi_header_value(dwg, "DIMAUNIT", &dimaunit, NULL) &&
        dimaunit == dwg->header_vars.DIMAUNIT)
      pass ("HEADER.DIMAUNIT [unsigned short int]");
    else
      {
        fail ("HEADER.DIMAUNIT [unsigned short int] %hu != %hu", dwg->header_vars.DIMAUNIT, dimaunit); error++;
      }
  }
  {
    unsigned short int dimdec;
    if (dwg_dynapi_header_value(dwg, "DIMDEC", &dimdec, NULL) &&
        dimdec == dwg->header_vars.DIMDEC)
      pass ("HEADER.DIMDEC [unsigned short int]");
    else
      {
        fail ("HEADER.DIMDEC [unsigned short int] %hu != %hu", dwg->header_vars.DIMDEC, dimdec); error++;
      }
  }
  {
    unsigned short int dimtdec;
    if (dwg_dynapi_header_value(dwg, "DIMTDEC", &dimtdec, NULL) &&
        dimtdec == dwg->header_vars.DIMTDEC)
      pass ("HEADER.DIMTDEC [unsigned short int]");
    else
      {
        fail ("HEADER.DIMTDEC [unsigned short int] %hu != %hu", dwg->header_vars.DIMTDEC, dimtdec); error++;
      }
  }
  {
    unsigned short int dimaltu;
    if (dwg_dynapi_header_value(dwg, "DIMALTU", &dimaltu, NULL) &&
        dimaltu == dwg->header_vars.DIMALTU)
      pass ("HEADER.DIMALTU [unsigned short int]");
    else
      {
        fail ("HEADER.DIMALTU [unsigned short int] %hu != %hu", dwg->header_vars.DIMALTU, dimaltu); error++;
      }
  }
  {
    unsigned short int dimalttd;
    if (dwg_dynapi_header_value(dwg, "DIMALTTD", &dimalttd, NULL) &&
        dimalttd == dwg->header_vars.DIMALTTD)
      pass ("HEADER.DIMALTTD [unsigned short int]");
    else
      {
        fail ("HEADER.DIMALTTD [unsigned short int] %hu != %hu", dwg->header_vars.DIMALTTD, dimalttd); error++;
      }
  }
  {
    Dwg_Object_Ref* dimtxsty;
    if (dwg_dynapi_header_value(dwg, "DIMTXSTY", &dimtxsty, NULL)
        && !memcmp(&dimtxsty, &dwg->header_vars.DIMTXSTY, sizeof(dwg->header_vars.DIMTXSTY))
       )
      pass ("HEADER.DIMTXSTY [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.DIMTXSTY [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    double dimscale;
    if (dwg_dynapi_header_value(dwg, "DIMSCALE", &dimscale, NULL) &&
        dimscale == dwg->header_vars.DIMSCALE)
      pass ("HEADER.DIMSCALE [double]");
    else
      {
        fail ("HEADER.DIMSCALE [double] %g != %g", dwg->header_vars.DIMSCALE, dimscale); error++;
      }
  }
  {
    double dimasz;
    if (dwg_dynapi_header_value(dwg, "DIMASZ", &dimasz, NULL) &&
        dimasz == dwg->header_vars.DIMASZ)
      pass ("HEADER.DIMASZ [double]");
    else
      {
        fail ("HEADER.DIMASZ [double] %g != %g", dwg->header_vars.DIMASZ, dimasz); error++;
      }
  }
  {
    double dimexo;
    if (dwg_dynapi_header_value(dwg, "DIMEXO", &dimexo, NULL) &&
        dimexo == dwg->header_vars.DIMEXO)
      pass ("HEADER.DIMEXO [double]");
    else
      {
        fail ("HEADER.DIMEXO [double] %g != %g", dwg->header_vars.DIMEXO, dimexo); error++;
      }
  }
  {
    double dimdli;
    if (dwg_dynapi_header_value(dwg, "DIMDLI", &dimdli, NULL) &&
        dimdli == dwg->header_vars.DIMDLI)
      pass ("HEADER.DIMDLI [double]");
    else
      {
        fail ("HEADER.DIMDLI [double] %g != %g", dwg->header_vars.DIMDLI, dimdli); error++;
      }
  }
  {
    double dimexe;
    if (dwg_dynapi_header_value(dwg, "DIMEXE", &dimexe, NULL) &&
        dimexe == dwg->header_vars.DIMEXE)
      pass ("HEADER.DIMEXE [double]");
    else
      {
        fail ("HEADER.DIMEXE [double] %g != %g", dwg->header_vars.DIMEXE, dimexe); error++;
      }
  }
  {
    double dimrnd;
    if (dwg_dynapi_header_value(dwg, "DIMRND", &dimrnd, NULL) &&
        dimrnd == dwg->header_vars.DIMRND)
      pass ("HEADER.DIMRND [double]");
    else
      {
        fail ("HEADER.DIMRND [double] %g != %g", dwg->header_vars.DIMRND, dimrnd); error++;
      }
  }
  {
    double dimdle;
    if (dwg_dynapi_header_value(dwg, "DIMDLE", &dimdle, NULL) &&
        dimdle == dwg->header_vars.DIMDLE)
      pass ("HEADER.DIMDLE [double]");
    else
      {
        fail ("HEADER.DIMDLE [double] %g != %g", dwg->header_vars.DIMDLE, dimdle); error++;
      }
  }
  {
    double dimtp;
    if (dwg_dynapi_header_value(dwg, "DIMTP", &dimtp, NULL) &&
        dimtp == dwg->header_vars.DIMTP)
      pass ("HEADER.DIMTP [double]");
    else
      {
        fail ("HEADER.DIMTP [double] %g != %g", dwg->header_vars.DIMTP, dimtp); error++;
      }
  }
  {
    double dimtm;
    if (dwg_dynapi_header_value(dwg, "DIMTM", &dimtm, NULL) &&
        dimtm == dwg->header_vars.DIMTM)
      pass ("HEADER.DIMTM [double]");
    else
      {
        fail ("HEADER.DIMTM [double] %g != %g", dwg->header_vars.DIMTM, dimtm); error++;
      }
  }
  {
    double dimfxl;
    if (dwg_dynapi_header_value(dwg, "DIMFXL", &dimfxl, NULL) &&
        dimfxl == dwg->header_vars.DIMFXL)
      pass ("HEADER.DIMFXL [double]");
    else
      {
        fail ("HEADER.DIMFXL [double] %g != %g", dwg->header_vars.DIMFXL, dimfxl); error++;
      }
  }
  {
    double dimjogang;
    if (dwg_dynapi_header_value(dwg, "DIMJOGANG", &dimjogang, NULL) &&
        dimjogang == dwg->header_vars.DIMJOGANG)
      pass ("HEADER.DIMJOGANG [double]");
    else
      {
        fail ("HEADER.DIMJOGANG [double] %g != %g", dwg->header_vars.DIMJOGANG, dimjogang); error++;
      }
  }
  {
    unsigned short int dimtfill;
    if (dwg_dynapi_header_value(dwg, "DIMTFILL", &dimtfill, NULL) &&
        dimtfill == dwg->header_vars.DIMTFILL)
      pass ("HEADER.DIMTFILL [unsigned short int]");
    else
      {
        fail ("HEADER.DIMTFILL [unsigned short int] %hu != %hu", dwg->header_vars.DIMTFILL, dimtfill); error++;
      }
  }
  {
    Dwg_Color dimtfillclr;
    if (dwg_dynapi_header_value(dwg, "DIMTFILLCLR", &dimtfillclr, NULL)
        && !memcmp(&dimtfillclr, &dwg->header_vars.DIMTFILLCLR, sizeof(dwg->header_vars.DIMTFILLCLR))
       )
      pass ("HEADER.DIMTFILLCLR [Dwg_Color]");
    else
      {
        fail ("HEADER.DIMTFILLCLR [Dwg_Color]"); error++;
      }
  }
  {
    unsigned short int dimazin;
    if (dwg_dynapi_header_value(dwg, "DIMAZIN", &dimazin, NULL) &&
        dimazin == dwg->header_vars.DIMAZIN)
      pass ("HEADER.DIMAZIN [unsigned short int]");
    else
      {
        fail ("HEADER.DIMAZIN [unsigned short int] %hu != %hu", dwg->header_vars.DIMAZIN, dimazin); error++;
      }
  }
  {
    unsigned short int dimarcsym;
    if (dwg_dynapi_header_value(dwg, "DIMARCSYM", &dimarcsym, NULL) &&
        dimarcsym == dwg->header_vars.DIMARCSYM)
      pass ("HEADER.DIMARCSYM [unsigned short int]");
    else
      {
        fail ("HEADER.DIMARCSYM [unsigned short int] %hu != %hu", dwg->header_vars.DIMARCSYM, dimarcsym); error++;
      }
  }
  {
    double dimtxt;
    if (dwg_dynapi_header_value(dwg, "DIMTXT", &dimtxt, NULL) &&
        dimtxt == dwg->header_vars.DIMTXT)
      pass ("HEADER.DIMTXT [double]");
    else
      {
        fail ("HEADER.DIMTXT [double] %g != %g", dwg->header_vars.DIMTXT, dimtxt); error++;
      }
  }
  {
    double dimcen;
    if (dwg_dynapi_header_value(dwg, "DIMCEN", &dimcen, NULL) &&
        dimcen == dwg->header_vars.DIMCEN)
      pass ("HEADER.DIMCEN [double]");
    else
      {
        fail ("HEADER.DIMCEN [double] %g != %g", dwg->header_vars.DIMCEN, dimcen); error++;
      }
  }
  {
    double dimtsz;
    if (dwg_dynapi_header_value(dwg, "DIMTSZ", &dimtsz, NULL) &&
        dimtsz == dwg->header_vars.DIMTSZ)
      pass ("HEADER.DIMTSZ [double]");
    else
      {
        fail ("HEADER.DIMTSZ [double] %g != %g", dwg->header_vars.DIMTSZ, dimtsz); error++;
      }
  }
  {
    double dimaltf;
    if (dwg_dynapi_header_value(dwg, "DIMALTF", &dimaltf, NULL) &&
        dimaltf == dwg->header_vars.DIMALTF)
      pass ("HEADER.DIMALTF [double]");
    else
      {
        fail ("HEADER.DIMALTF [double] %g != %g", dwg->header_vars.DIMALTF, dimaltf); error++;
      }
  }
  {
    double dimlfac;
    if (dwg_dynapi_header_value(dwg, "DIMLFAC", &dimlfac, NULL) &&
        dimlfac == dwg->header_vars.DIMLFAC)
      pass ("HEADER.DIMLFAC [double]");
    else
      {
        fail ("HEADER.DIMLFAC [double] %g != %g", dwg->header_vars.DIMLFAC, dimlfac); error++;
      }
  }
  {
    double dimtvp;
    if (dwg_dynapi_header_value(dwg, "DIMTVP", &dimtvp, NULL) &&
        dimtvp == dwg->header_vars.DIMTVP)
      pass ("HEADER.DIMTVP [double]");
    else
      {
        fail ("HEADER.DIMTVP [double] %g != %g", dwg->header_vars.DIMTVP, dimtvp); error++;
      }
  }
  {
    double dimtfac;
    if (dwg_dynapi_header_value(dwg, "DIMTFAC", &dimtfac, NULL) &&
        dimtfac == dwg->header_vars.DIMTFAC)
      pass ("HEADER.DIMTFAC [double]");
    else
      {
        fail ("HEADER.DIMTFAC [double] %g != %g", dwg->header_vars.DIMTFAC, dimtfac); error++;
      }
  }
  {
    double dimgap;
    if (dwg_dynapi_header_value(dwg, "DIMGAP", &dimgap, NULL) &&
        dimgap == dwg->header_vars.DIMGAP)
      pass ("HEADER.DIMGAP [double]");
    else
      {
        fail ("HEADER.DIMGAP [double] %g != %g", dwg->header_vars.DIMGAP, dimgap); error++;
      }
  }
  {
    char* dimpost_t;
    if (dwg_dynapi_header_value(dwg, "DIMPOST_T", &dimpost_t, NULL)
        && !memcmp(&dimpost_t, &dwg->header_vars.DIMPOST_T, sizeof(dwg->header_vars.DIMPOST_T))
       )
      pass ("HEADER.DIMPOST_T [char*]");
    else
      {
        fail ("HEADER.DIMPOST_T [char*]"); error++;
      }
  }
  {
    char* dimapost_t;
    if (dwg_dynapi_header_value(dwg, "DIMAPOST_T", &dimapost_t, NULL)
        && !memcmp(&dimapost_t, &dwg->header_vars.DIMAPOST_T, sizeof(dwg->header_vars.DIMAPOST_T))
       )
      pass ("HEADER.DIMAPOST_T [char*]");
    else
      {
        fail ("HEADER.DIMAPOST_T [char*]"); error++;
      }
  }
  {
    char* dimblk_t;
    if (dwg_dynapi_header_value(dwg, "DIMBLK_T", &dimblk_t, NULL)
        && !memcmp(&dimblk_t, &dwg->header_vars.DIMBLK_T, sizeof(dwg->header_vars.DIMBLK_T))
       )
      pass ("HEADER.DIMBLK_T [char*]");
    else
      {
        fail ("HEADER.DIMBLK_T [char*]"); error++;
      }
  }
  {
    char* dimblk1_t;
    if (dwg_dynapi_header_value(dwg, "DIMBLK1_T", &dimblk1_t, NULL)
        && !memcmp(&dimblk1_t, &dwg->header_vars.DIMBLK1_T, sizeof(dwg->header_vars.DIMBLK1_T))
       )
      pass ("HEADER.DIMBLK1_T [char*]");
    else
      {
        fail ("HEADER.DIMBLK1_T [char*]"); error++;
      }
  }
  {
    char* dimblk2_t;
    if (dwg_dynapi_header_value(dwg, "DIMBLK2_T", &dimblk2_t, NULL)
        && !memcmp(&dimblk2_t, &dwg->header_vars.DIMBLK2_T, sizeof(dwg->header_vars.DIMBLK2_T))
       )
      pass ("HEADER.DIMBLK2_T [char*]");
    else
      {
        fail ("HEADER.DIMBLK2_T [char*]"); error++;
      }
  }
  {
    double dimaltrnd;
    if (dwg_dynapi_header_value(dwg, "DIMALTRND", &dimaltrnd, NULL) &&
        dimaltrnd == dwg->header_vars.DIMALTRND)
      pass ("HEADER.DIMALTRND [double]");
    else
      {
        fail ("HEADER.DIMALTRND [double] %g != %g", dwg->header_vars.DIMALTRND, dimaltrnd); error++;
      }
  }
  {
    unsigned short int dimclrd_c;
    if (dwg_dynapi_header_value(dwg, "DIMCLRD_C", &dimclrd_c, NULL) &&
        dimclrd_c == dwg->header_vars.DIMCLRD_C)
      pass ("HEADER.DIMCLRD_C [unsigned short int]");
    else
      {
        fail ("HEADER.DIMCLRD_C [unsigned short int] %hu != %hu", dwg->header_vars.DIMCLRD_C, dimclrd_c); error++;
      }
  }
  {
    unsigned short int dimclre_c;
    if (dwg_dynapi_header_value(dwg, "DIMCLRE_C", &dimclre_c, NULL) &&
        dimclre_c == dwg->header_vars.DIMCLRE_C)
      pass ("HEADER.DIMCLRE_C [unsigned short int]");
    else
      {
        fail ("HEADER.DIMCLRE_C [unsigned short int] %hu != %hu", dwg->header_vars.DIMCLRE_C, dimclre_c); error++;
      }
  }
  {
    unsigned short int dimclrt_c;
    if (dwg_dynapi_header_value(dwg, "DIMCLRT_C", &dimclrt_c, NULL) &&
        dimclrt_c == dwg->header_vars.DIMCLRT_C)
      pass ("HEADER.DIMCLRT_C [unsigned short int]");
    else
      {
        fail ("HEADER.DIMCLRT_C [unsigned short int] %hu != %hu", dwg->header_vars.DIMCLRT_C, dimclrt_c); error++;
      }
  }
  {
    Dwg_Color dimclrd;
    if (dwg_dynapi_header_value(dwg, "DIMCLRD", &dimclrd, NULL)
        && !memcmp(&dimclrd, &dwg->header_vars.DIMCLRD, sizeof(dwg->header_vars.DIMCLRD))
       )
      pass ("HEADER.DIMCLRD [Dwg_Color]");
    else
      {
        fail ("HEADER.DIMCLRD [Dwg_Color]"); error++;
      }
  }
  {
    Dwg_Color dimclre;
    if (dwg_dynapi_header_value(dwg, "DIMCLRE", &dimclre, NULL)
        && !memcmp(&dimclre, &dwg->header_vars.DIMCLRE, sizeof(dwg->header_vars.DIMCLRE))
       )
      pass ("HEADER.DIMCLRE [Dwg_Color]");
    else
      {
        fail ("HEADER.DIMCLRE [Dwg_Color]"); error++;
      }
  }
  {
    Dwg_Color dimclrt;
    if (dwg_dynapi_header_value(dwg, "DIMCLRT", &dimclrt, NULL)
        && !memcmp(&dimclrt, &dwg->header_vars.DIMCLRT, sizeof(dwg->header_vars.DIMCLRT))
       )
      pass ("HEADER.DIMCLRT [Dwg_Color]");
    else
      {
        fail ("HEADER.DIMCLRT [Dwg_Color]"); error++;
      }
  }
  {
    unsigned short int dimadec;
    if (dwg_dynapi_header_value(dwg, "DIMADEC", &dimadec, NULL) &&
        dimadec == dwg->header_vars.DIMADEC)
      pass ("HEADER.DIMADEC [unsigned short int]");
    else
      {
        fail ("HEADER.DIMADEC [unsigned short int] %hu != %hu", dwg->header_vars.DIMADEC, dimadec); error++;
      }
  }
  {
    unsigned short int dimfrac;
    if (dwg_dynapi_header_value(dwg, "DIMFRAC", &dimfrac, NULL) &&
        dimfrac == dwg->header_vars.DIMFRAC)
      pass ("HEADER.DIMFRAC [unsigned short int]");
    else
      {
        fail ("HEADER.DIMFRAC [unsigned short int] %hu != %hu", dwg->header_vars.DIMFRAC, dimfrac); error++;
      }
  }
  {
    unsigned short int dimlunit;
    if (dwg_dynapi_header_value(dwg, "DIMLUNIT", &dimlunit, NULL) &&
        dimlunit == dwg->header_vars.DIMLUNIT)
      pass ("HEADER.DIMLUNIT [unsigned short int]");
    else
      {
        fail ("HEADER.DIMLUNIT [unsigned short int] %hu != %hu", dwg->header_vars.DIMLUNIT, dimlunit); error++;
      }
  }
  {
    unsigned short int dimdsep;
    if (dwg_dynapi_header_value(dwg, "DIMDSEP", &dimdsep, NULL) &&
        dimdsep == dwg->header_vars.DIMDSEP)
      pass ("HEADER.DIMDSEP [unsigned short int]");
    else
      {
        fail ("HEADER.DIMDSEP [unsigned short int] %hu != %hu", dwg->header_vars.DIMDSEP, dimdsep); error++;
      }
  }
  {
    unsigned short int dimtmove;
    if (dwg_dynapi_header_value(dwg, "DIMTMOVE", &dimtmove, NULL) &&
        dimtmove == dwg->header_vars.DIMTMOVE)
      pass ("HEADER.DIMTMOVE [unsigned short int]");
    else
      {
        fail ("HEADER.DIMTMOVE [unsigned short int] %hu != %hu", dwg->header_vars.DIMTMOVE, dimtmove); error++;
      }
  }
  {
    unsigned short int dimaltz;
    if (dwg_dynapi_header_value(dwg, "DIMALTZ", &dimaltz, NULL) &&
        dimaltz == dwg->header_vars.DIMALTZ)
      pass ("HEADER.DIMALTZ [unsigned short int]");
    else
      {
        fail ("HEADER.DIMALTZ [unsigned short int] %hu != %hu", dwg->header_vars.DIMALTZ, dimaltz); error++;
      }
  }
  {
    unsigned short int dimalttz;
    if (dwg_dynapi_header_value(dwg, "DIMALTTZ", &dimalttz, NULL) &&
        dimalttz == dwg->header_vars.DIMALTTZ)
      pass ("HEADER.DIMALTTZ [unsigned short int]");
    else
      {
        fail ("HEADER.DIMALTTZ [unsigned short int] %hu != %hu", dwg->header_vars.DIMALTTZ, dimalttz); error++;
      }
  }
  {
    unsigned short int dimatfit;
    if (dwg_dynapi_header_value(dwg, "DIMATFIT", &dimatfit, NULL) &&
        dimatfit == dwg->header_vars.DIMATFIT)
      pass ("HEADER.DIMATFIT [unsigned short int]");
    else
      {
        fail ("HEADER.DIMATFIT [unsigned short int] %hu != %hu", dwg->header_vars.DIMATFIT, dimatfit); error++;
      }
  }
  {
    unsigned char dimfxlon;
    if (dwg_dynapi_header_value(dwg, "DIMFXLON", &dimfxlon, NULL) &&
        dimfxlon == dwg->header_vars.DIMFXLON)
      pass ("HEADER.DIMFXLON [unsigned char]");
    else
      {
        fail ("HEADER.DIMFXLON [unsigned char] %c != %c", dwg->header_vars.DIMFXLON, dimfxlon); error++;
      }
  }
  {
    unsigned char dimtxtdirection;
    if (dwg_dynapi_header_value(dwg, "DIMTXTDIRECTION", &dimtxtdirection, NULL) &&
        dimtxtdirection == dwg->header_vars.DIMTXTDIRECTION)
      pass ("HEADER.DIMTXTDIRECTION [unsigned char]");
    else
      {
        fail ("HEADER.DIMTXTDIRECTION [unsigned char] %c != %c", dwg->header_vars.DIMTXTDIRECTION, dimtxtdirection); error++;
      }
  }
  {
    double dimaltmzf;
    if (dwg_dynapi_header_value(dwg, "DIMALTMZF", &dimaltmzf, NULL) &&
        dimaltmzf == dwg->header_vars.DIMALTMZF)
      pass ("HEADER.DIMALTMZF [double]");
    else
      {
        fail ("HEADER.DIMALTMZF [double] %g != %g", dwg->header_vars.DIMALTMZF, dimaltmzf); error++;
      }
  }
  {
    char* dimaltmzs;
    if (dwg_dynapi_header_value(dwg, "DIMALTMZS", &dimaltmzs, NULL)
        && !memcmp(&dimaltmzs, &dwg->header_vars.DIMALTMZS, sizeof(dwg->header_vars.DIMALTMZS))
       )
      pass ("HEADER.DIMALTMZS [char*]");
    else
      {
        fail ("HEADER.DIMALTMZS [char*]"); error++;
      }
  }
  {
    double dimmzf;
    if (dwg_dynapi_header_value(dwg, "DIMMZF", &dimmzf, NULL) &&
        dimmzf == dwg->header_vars.DIMMZF)
      pass ("HEADER.DIMMZF [double]");
    else
      {
        fail ("HEADER.DIMMZF [double] %g != %g", dwg->header_vars.DIMMZF, dimmzf); error++;
      }
  }
  {
    char* dimmzs;
    if (dwg_dynapi_header_value(dwg, "DIMMZS", &dimmzs, NULL)
        && !memcmp(&dimmzs, &dwg->header_vars.DIMMZS, sizeof(dwg->header_vars.DIMMZS))
       )
      pass ("HEADER.DIMMZS [char*]");
    else
      {
        fail ("HEADER.DIMMZS [char*]"); error++;
      }
  }
  {
    Dwg_Object_Ref* dimldrblk;
    if (dwg_dynapi_header_value(dwg, "DIMLDRBLK", &dimldrblk, NULL)
        && !memcmp(&dimldrblk, &dwg->header_vars.DIMLDRBLK, sizeof(dwg->header_vars.DIMLDRBLK))
       )
      pass ("HEADER.DIMLDRBLK [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.DIMLDRBLK [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    Dwg_Object_Ref* dimblk;
    if (dwg_dynapi_header_value(dwg, "DIMBLK", &dimblk, NULL)
        && !memcmp(&dimblk, &dwg->header_vars.DIMBLK, sizeof(dwg->header_vars.DIMBLK))
       )
      pass ("HEADER.DIMBLK [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.DIMBLK [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    Dwg_Object_Ref* dimblk1;
    if (dwg_dynapi_header_value(dwg, "DIMBLK1", &dimblk1, NULL)
        && !memcmp(&dimblk1, &dwg->header_vars.DIMBLK1, sizeof(dwg->header_vars.DIMBLK1))
       )
      pass ("HEADER.DIMBLK1 [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.DIMBLK1 [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    Dwg_Object_Ref* dimblk2;
    if (dwg_dynapi_header_value(dwg, "DIMBLK2", &dimblk2, NULL)
        && !memcmp(&dimblk2, &dwg->header_vars.DIMBLK2, sizeof(dwg->header_vars.DIMBLK2))
       )
      pass ("HEADER.DIMBLK2 [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.DIMBLK2 [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    Dwg_Object_Ref* dimltype;
    if (dwg_dynapi_header_value(dwg, "DIMLTYPE", &dimltype, NULL)
        && !memcmp(&dimltype, &dwg->header_vars.DIMLTYPE, sizeof(dwg->header_vars.DIMLTYPE))
       )
      pass ("HEADER.DIMLTYPE [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.DIMLTYPE [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    Dwg_Object_Ref* dimltex1;
    if (dwg_dynapi_header_value(dwg, "DIMLTEX1", &dimltex1, NULL)
        && !memcmp(&dimltex1, &dwg->header_vars.DIMLTEX1, sizeof(dwg->header_vars.DIMLTEX1))
       )
      pass ("HEADER.DIMLTEX1 [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.DIMLTEX1 [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    Dwg_Object_Ref* dimltex2;
    if (dwg_dynapi_header_value(dwg, "DIMLTEX2", &dimltex2, NULL)
        && !memcmp(&dimltex2, &dwg->header_vars.DIMLTEX2, sizeof(dwg->header_vars.DIMLTEX2))
       )
      pass ("HEADER.DIMLTEX2 [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.DIMLTEX2 [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    unsigned short int dimlwd;
    if (dwg_dynapi_header_value(dwg, "DIMLWD", &dimlwd, NULL) &&
        dimlwd == dwg->header_vars.DIMLWD)
      pass ("HEADER.DIMLWD [unsigned short int]");
    else
      {
        fail ("HEADER.DIMLWD [unsigned short int] %hu != %hu", dwg->header_vars.DIMLWD, dimlwd); error++;
      }
  }
  {
    unsigned short int dimlwe;
    if (dwg_dynapi_header_value(dwg, "DIMLWE", &dimlwe, NULL) &&
        dimlwe == dwg->header_vars.DIMLWE)
      pass ("HEADER.DIMLWE [unsigned short int]");
    else
      {
        fail ("HEADER.DIMLWE [unsigned short int] %hu != %hu", dwg->header_vars.DIMLWE, dimlwe); error++;
      }
  }
  {
    Dwg_Object_Ref* block_control_object;
    if (dwg_dynapi_header_value(dwg, "BLOCK_CONTROL_OBJECT", &block_control_object, NULL)
        && !memcmp(&block_control_object, &dwg->header_vars.BLOCK_CONTROL_OBJECT, sizeof(dwg->header_vars.BLOCK_CONTROL_OBJECT))
       )
      pass ("HEADER.BLOCK_CONTROL_OBJECT [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.BLOCK_CONTROL_OBJECT [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    Dwg_Object_Ref* layer_control_object;
    if (dwg_dynapi_header_value(dwg, "LAYER_CONTROL_OBJECT", &layer_control_object, NULL)
        && !memcmp(&layer_control_object, &dwg->header_vars.LAYER_CONTROL_OBJECT, sizeof(dwg->header_vars.LAYER_CONTROL_OBJECT))
       )
      pass ("HEADER.LAYER_CONTROL_OBJECT [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.LAYER_CONTROL_OBJECT [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    Dwg_Object_Ref* style_control_object;
    if (dwg_dynapi_header_value(dwg, "STYLE_CONTROL_OBJECT", &style_control_object, NULL)
        && !memcmp(&style_control_object, &dwg->header_vars.STYLE_CONTROL_OBJECT, sizeof(dwg->header_vars.STYLE_CONTROL_OBJECT))
       )
      pass ("HEADER.STYLE_CONTROL_OBJECT [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.STYLE_CONTROL_OBJECT [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    Dwg_Object_Ref* linetype_control_object;
    if (dwg_dynapi_header_value(dwg, "LINETYPE_CONTROL_OBJECT", &linetype_control_object, NULL)
        && !memcmp(&linetype_control_object, &dwg->header_vars.LINETYPE_CONTROL_OBJECT, sizeof(dwg->header_vars.LINETYPE_CONTROL_OBJECT))
       )
      pass ("HEADER.LINETYPE_CONTROL_OBJECT [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.LINETYPE_CONTROL_OBJECT [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    Dwg_Object_Ref* view_control_object;
    if (dwg_dynapi_header_value(dwg, "VIEW_CONTROL_OBJECT", &view_control_object, NULL)
        && !memcmp(&view_control_object, &dwg->header_vars.VIEW_CONTROL_OBJECT, sizeof(dwg->header_vars.VIEW_CONTROL_OBJECT))
       )
      pass ("HEADER.VIEW_CONTROL_OBJECT [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.VIEW_CONTROL_OBJECT [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    Dwg_Object_Ref* ucs_control_object;
    if (dwg_dynapi_header_value(dwg, "UCS_CONTROL_OBJECT", &ucs_control_object, NULL)
        && !memcmp(&ucs_control_object, &dwg->header_vars.UCS_CONTROL_OBJECT, sizeof(dwg->header_vars.UCS_CONTROL_OBJECT))
       )
      pass ("HEADER.UCS_CONTROL_OBJECT [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.UCS_CONTROL_OBJECT [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    Dwg_Object_Ref* vport_control_object;
    if (dwg_dynapi_header_value(dwg, "VPORT_CONTROL_OBJECT", &vport_control_object, NULL)
        && !memcmp(&vport_control_object, &dwg->header_vars.VPORT_CONTROL_OBJECT, sizeof(dwg->header_vars.VPORT_CONTROL_OBJECT))
       )
      pass ("HEADER.VPORT_CONTROL_OBJECT [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.VPORT_CONTROL_OBJECT [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    Dwg_Object_Ref* appid_control_object;
    if (dwg_dynapi_header_value(dwg, "APPID_CONTROL_OBJECT", &appid_control_object, NULL)
        && !memcmp(&appid_control_object, &dwg->header_vars.APPID_CONTROL_OBJECT, sizeof(dwg->header_vars.APPID_CONTROL_OBJECT))
       )
      pass ("HEADER.APPID_CONTROL_OBJECT [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.APPID_CONTROL_OBJECT [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    Dwg_Object_Ref* dimstyle_control_object;
    if (dwg_dynapi_header_value(dwg, "DIMSTYLE_CONTROL_OBJECT", &dimstyle_control_object, NULL)
        && !memcmp(&dimstyle_control_object, &dwg->header_vars.DIMSTYLE_CONTROL_OBJECT, sizeof(dwg->header_vars.DIMSTYLE_CONTROL_OBJECT))
       )
      pass ("HEADER.DIMSTYLE_CONTROL_OBJECT [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.DIMSTYLE_CONTROL_OBJECT [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    Dwg_Object_Ref* vport_entity_control_object;
    if (dwg_dynapi_header_value(dwg, "VPORT_ENTITY_CONTROL_OBJECT", &vport_entity_control_object, NULL)
        && !memcmp(&vport_entity_control_object, &dwg->header_vars.VPORT_ENTITY_CONTROL_OBJECT, sizeof(dwg->header_vars.VPORT_ENTITY_CONTROL_OBJECT))
       )
      pass ("HEADER.VPORT_ENTITY_CONTROL_OBJECT [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.VPORT_ENTITY_CONTROL_OBJECT [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    Dwg_Object_Ref* dictionary_acad_group;
    if (dwg_dynapi_header_value(dwg, "DICTIONARY_ACAD_GROUP", &dictionary_acad_group, NULL)
        && !memcmp(&dictionary_acad_group, &dwg->header_vars.DICTIONARY_ACAD_GROUP, sizeof(dwg->header_vars.DICTIONARY_ACAD_GROUP))
       )
      pass ("HEADER.DICTIONARY_ACAD_GROUP [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.DICTIONARY_ACAD_GROUP [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    Dwg_Object_Ref* dictionary_acad_mlinestyle;
    if (dwg_dynapi_header_value(dwg, "DICTIONARY_ACAD_MLINESTYLE", &dictionary_acad_mlinestyle, NULL)
        && !memcmp(&dictionary_acad_mlinestyle, &dwg->header_vars.DICTIONARY_ACAD_MLINESTYLE, sizeof(dwg->header_vars.DICTIONARY_ACAD_MLINESTYLE))
       )
      pass ("HEADER.DICTIONARY_ACAD_MLINESTYLE [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.DICTIONARY_ACAD_MLINESTYLE [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    Dwg_Object_Ref* dictionary_named_objects;
    if (dwg_dynapi_header_value(dwg, "DICTIONARY_NAMED_OBJECTS", &dictionary_named_objects, NULL)
        && !memcmp(&dictionary_named_objects, &dwg->header_vars.DICTIONARY_NAMED_OBJECTS, sizeof(dwg->header_vars.DICTIONARY_NAMED_OBJECTS))
       )
      pass ("HEADER.DICTIONARY_NAMED_OBJECTS [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.DICTIONARY_NAMED_OBJECTS [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    unsigned short int tstackalign;
    if (dwg_dynapi_header_value(dwg, "TSTACKALIGN", &tstackalign, NULL) &&
        tstackalign == dwg->header_vars.TSTACKALIGN)
      pass ("HEADER.TSTACKALIGN [unsigned short int]");
    else
      {
        fail ("HEADER.TSTACKALIGN [unsigned short int] %hu != %hu", dwg->header_vars.TSTACKALIGN, tstackalign); error++;
      }
  }
  {
    unsigned short int tstacksize;
    if (dwg_dynapi_header_value(dwg, "TSTACKSIZE", &tstacksize, NULL) &&
        tstacksize == dwg->header_vars.TSTACKSIZE)
      pass ("HEADER.TSTACKSIZE [unsigned short int]");
    else
      {
        fail ("HEADER.TSTACKSIZE [unsigned short int] %hu != %hu", dwg->header_vars.TSTACKSIZE, tstacksize); error++;
      }
  }
  {
    char* hyperlinkbase;
    if (dwg_dynapi_header_value(dwg, "HYPERLINKBASE", &hyperlinkbase, NULL)
        && !memcmp(&hyperlinkbase, &dwg->header_vars.HYPERLINKBASE, sizeof(dwg->header_vars.HYPERLINKBASE))
       )
      pass ("HEADER.HYPERLINKBASE [char*]");
    else
      {
        fail ("HEADER.HYPERLINKBASE [char*]"); error++;
      }
  }
  {
    char* stylesheet;
    if (dwg_dynapi_header_value(dwg, "STYLESHEET", &stylesheet, NULL)
        && !memcmp(&stylesheet, &dwg->header_vars.STYLESHEET, sizeof(dwg->header_vars.STYLESHEET))
       )
      pass ("HEADER.STYLESHEET [char*]");
    else
      {
        fail ("HEADER.STYLESHEET [char*]"); error++;
      }
  }
  {
    Dwg_Object_Ref* dictionary_layouts;
    if (dwg_dynapi_header_value(dwg, "DICTIONARY_LAYOUTS", &dictionary_layouts, NULL)
        && !memcmp(&dictionary_layouts, &dwg->header_vars.DICTIONARY_LAYOUTS, sizeof(dwg->header_vars.DICTIONARY_LAYOUTS))
       )
      pass ("HEADER.DICTIONARY_LAYOUTS [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.DICTIONARY_LAYOUTS [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    Dwg_Object_Ref* dictionary_plotsettings;
    if (dwg_dynapi_header_value(dwg, "DICTIONARY_PLOTSETTINGS", &dictionary_plotsettings, NULL)
        && !memcmp(&dictionary_plotsettings, &dwg->header_vars.DICTIONARY_PLOTSETTINGS, sizeof(dwg->header_vars.DICTIONARY_PLOTSETTINGS))
       )
      pass ("HEADER.DICTIONARY_PLOTSETTINGS [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.DICTIONARY_PLOTSETTINGS [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    Dwg_Object_Ref* dictionary_plotstyles;
    if (dwg_dynapi_header_value(dwg, "DICTIONARY_PLOTSTYLES", &dictionary_plotstyles, NULL)
        && !memcmp(&dictionary_plotstyles, &dwg->header_vars.DICTIONARY_PLOTSTYLES, sizeof(dwg->header_vars.DICTIONARY_PLOTSTYLES))
       )
      pass ("HEADER.DICTIONARY_PLOTSTYLES [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.DICTIONARY_PLOTSTYLES [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    Dwg_Object_Ref* dictionary_materials;
    if (dwg_dynapi_header_value(dwg, "DICTIONARY_MATERIALS", &dictionary_materials, NULL)
        && !memcmp(&dictionary_materials, &dwg->header_vars.DICTIONARY_MATERIALS, sizeof(dwg->header_vars.DICTIONARY_MATERIALS))
       )
      pass ("HEADER.DICTIONARY_MATERIALS [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.DICTIONARY_MATERIALS [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    Dwg_Object_Ref* dictionary_colors;
    if (dwg_dynapi_header_value(dwg, "DICTIONARY_COLORS", &dictionary_colors, NULL)
        && !memcmp(&dictionary_colors, &dwg->header_vars.DICTIONARY_COLORS, sizeof(dwg->header_vars.DICTIONARY_COLORS))
       )
      pass ("HEADER.DICTIONARY_COLORS [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.DICTIONARY_COLORS [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    Dwg_Object_Ref* dictionary_visualstyle;
    if (dwg_dynapi_header_value(dwg, "DICTIONARY_VISUALSTYLE", &dictionary_visualstyle, NULL)
        && !memcmp(&dictionary_visualstyle, &dwg->header_vars.DICTIONARY_VISUALSTYLE, sizeof(dwg->header_vars.DICTIONARY_VISUALSTYLE))
       )
      pass ("HEADER.DICTIONARY_VISUALSTYLE [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.DICTIONARY_VISUALSTYLE [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    Dwg_Object_Ref* dictionary_lightlist;
    if (dwg_dynapi_header_value(dwg, "DICTIONARY_LIGHTLIST", &dictionary_lightlist, NULL)
        && !memcmp(&dictionary_lightlist, &dwg->header_vars.DICTIONARY_LIGHTLIST, sizeof(dwg->header_vars.DICTIONARY_LIGHTLIST))
       )
      pass ("HEADER.DICTIONARY_LIGHTLIST [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.DICTIONARY_LIGHTLIST [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    Dwg_Object_Ref* unknown_20;
    if (dwg_dynapi_header_value(dwg, "unknown_20", &unknown_20, NULL)
        && !memcmp(&unknown_20, &dwg->header_vars.unknown_20, sizeof(dwg->header_vars.unknown_20))
       )
      pass ("HEADER.unknown_20 [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.unknown_20 [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    unsigned int flags;
    if (dwg_dynapi_header_value(dwg, "FLAGS", &flags, NULL) &&
        flags == dwg->header_vars.FLAGS)
      pass ("HEADER.FLAGS [unsigned int]");
    else
      {
        fail ("HEADER.FLAGS [unsigned int] %u != %u", dwg->header_vars.FLAGS, flags); error++;
      }
  }
  {
    unsigned char celweight;
    if (dwg_dynapi_header_value(dwg, "CELWEIGHT", &celweight, NULL) &&
        celweight == dwg->header_vars.CELWEIGHT)
      pass ("HEADER.CELWEIGHT [unsigned char]");
    else
      {
        fail ("HEADER.CELWEIGHT [unsigned char] %c != %c", dwg->header_vars.CELWEIGHT, celweight); error++;
      }
  }
  {
    unsigned char endcaps;
    if (dwg_dynapi_header_value(dwg, "ENDCAPS", &endcaps, NULL) &&
        endcaps == dwg->header_vars.ENDCAPS)
      pass ("HEADER.ENDCAPS [unsigned char]");
    else
      {
        fail ("HEADER.ENDCAPS [unsigned char] %c != %c", dwg->header_vars.ENDCAPS, endcaps); error++;
      }
  }
  {
    unsigned char joinstyle;
    if (dwg_dynapi_header_value(dwg, "JOINSTYLE", &joinstyle, NULL) &&
        joinstyle == dwg->header_vars.JOINSTYLE)
      pass ("HEADER.JOINSTYLE [unsigned char]");
    else
      {
        fail ("HEADER.JOINSTYLE [unsigned char] %c != %c", dwg->header_vars.JOINSTYLE, joinstyle); error++;
      }
  }
  {
    unsigned char lwdisplay;
    if (dwg_dynapi_header_value(dwg, "LWDISPLAY", &lwdisplay, NULL) &&
        lwdisplay == dwg->header_vars.LWDISPLAY)
      pass ("HEADER.LWDISPLAY [unsigned char]");
    else
      {
        fail ("HEADER.LWDISPLAY [unsigned char] %c != %c", dwg->header_vars.LWDISPLAY, lwdisplay); error++;
      }
  }
  {
    unsigned char xedit;
    if (dwg_dynapi_header_value(dwg, "XEDIT", &xedit, NULL) &&
        xedit == dwg->header_vars.XEDIT)
      pass ("HEADER.XEDIT [unsigned char]");
    else
      {
        fail ("HEADER.XEDIT [unsigned char] %c != %c", dwg->header_vars.XEDIT, xedit); error++;
      }
  }
  {
    unsigned char extnames;
    if (dwg_dynapi_header_value(dwg, "EXTNAMES", &extnames, NULL) &&
        extnames == dwg->header_vars.EXTNAMES)
      pass ("HEADER.EXTNAMES [unsigned char]");
    else
      {
        fail ("HEADER.EXTNAMES [unsigned char] %c != %c", dwg->header_vars.EXTNAMES, extnames); error++;
      }
  }
  {
    unsigned char pstylemode;
    if (dwg_dynapi_header_value(dwg, "PSTYLEMODE", &pstylemode, NULL) &&
        pstylemode == dwg->header_vars.PSTYLEMODE)
      pass ("HEADER.PSTYLEMODE [unsigned char]");
    else
      {
        fail ("HEADER.PSTYLEMODE [unsigned char] %c != %c", dwg->header_vars.PSTYLEMODE, pstylemode); error++;
      }
  }
  {
    unsigned char olestartup;
    if (dwg_dynapi_header_value(dwg, "OLESTARTUP", &olestartup, NULL) &&
        olestartup == dwg->header_vars.OLESTARTUP)
      pass ("HEADER.OLESTARTUP [unsigned char]");
    else
      {
        fail ("HEADER.OLESTARTUP [unsigned char] %c != %c", dwg->header_vars.OLESTARTUP, olestartup); error++;
      }
  }
  {
    unsigned short int insunits;
    if (dwg_dynapi_header_value(dwg, "INSUNITS", &insunits, NULL) &&
        insunits == dwg->header_vars.INSUNITS)
      pass ("HEADER.INSUNITS [unsigned short int]");
    else
      {
        fail ("HEADER.INSUNITS [unsigned short int] %hu != %hu", dwg->header_vars.INSUNITS, insunits); error++;
      }
  }
  {
    unsigned short int cepsntype;
    if (dwg_dynapi_header_value(dwg, "CEPSNTYPE", &cepsntype, NULL) &&
        cepsntype == dwg->header_vars.CEPSNTYPE)
      pass ("HEADER.CEPSNTYPE [unsigned short int]");
    else
      {
        fail ("HEADER.CEPSNTYPE [unsigned short int] %hu != %hu", dwg->header_vars.CEPSNTYPE, cepsntype); error++;
      }
  }
  {
    Dwg_Object_Ref* cpsnid;
    if (dwg_dynapi_header_value(dwg, "CPSNID", &cpsnid, NULL)
        && !memcmp(&cpsnid, &dwg->header_vars.CPSNID, sizeof(dwg->header_vars.CPSNID))
       )
      pass ("HEADER.CPSNID [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.CPSNID [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    char* fingerprintguid;
    if (dwg_dynapi_header_value(dwg, "FINGERPRINTGUID", &fingerprintguid, NULL)
        && !memcmp(&fingerprintguid, &dwg->header_vars.FINGERPRINTGUID, sizeof(dwg->header_vars.FINGERPRINTGUID))
       )
      pass ("HEADER.FINGERPRINTGUID [char*]");
    else
      {
        fail ("HEADER.FINGERPRINTGUID [char*]"); error++;
      }
  }
  {
    char* versionguid;
    if (dwg_dynapi_header_value(dwg, "VERSIONGUID", &versionguid, NULL)
        && !memcmp(&versionguid, &dwg->header_vars.VERSIONGUID, sizeof(dwg->header_vars.VERSIONGUID))
       )
      pass ("HEADER.VERSIONGUID [char*]");
    else
      {
        fail ("HEADER.VERSIONGUID [char*]"); error++;
      }
  }
  {
    unsigned char sortents;
    if (dwg_dynapi_header_value(dwg, "SORTENTS", &sortents, NULL) &&
        sortents == dwg->header_vars.SORTENTS)
      pass ("HEADER.SORTENTS [unsigned char]");
    else
      {
        fail ("HEADER.SORTENTS [unsigned char] %c != %c", dwg->header_vars.SORTENTS, sortents); error++;
      }
  }
  {
    unsigned char indexctl;
    if (dwg_dynapi_header_value(dwg, "INDEXCTL", &indexctl, NULL) &&
        indexctl == dwg->header_vars.INDEXCTL)
      pass ("HEADER.INDEXCTL [unsigned char]");
    else
      {
        fail ("HEADER.INDEXCTL [unsigned char] %c != %c", dwg->header_vars.INDEXCTL, indexctl); error++;
      }
  }
  {
    unsigned char hidetext;
    if (dwg_dynapi_header_value(dwg, "HIDETEXT", &hidetext, NULL) &&
        hidetext == dwg->header_vars.HIDETEXT)
      pass ("HEADER.HIDETEXT [unsigned char]");
    else
      {
        fail ("HEADER.HIDETEXT [unsigned char] %c != %c", dwg->header_vars.HIDETEXT, hidetext); error++;
      }
  }
  {
    unsigned char xclipframe;
    if (dwg_dynapi_header_value(dwg, "XCLIPFRAME", &xclipframe, NULL) &&
        xclipframe == dwg->header_vars.XCLIPFRAME)
      pass ("HEADER.XCLIPFRAME [unsigned char]");
    else
      {
        fail ("HEADER.XCLIPFRAME [unsigned char] %c != %c", dwg->header_vars.XCLIPFRAME, xclipframe); error++;
      }
  }
  {
    unsigned char dimassoc;
    if (dwg_dynapi_header_value(dwg, "DIMASSOC", &dimassoc, NULL) &&
        dimassoc == dwg->header_vars.DIMASSOC)
      pass ("HEADER.DIMASSOC [unsigned char]");
    else
      {
        fail ("HEADER.DIMASSOC [unsigned char] %c != %c", dwg->header_vars.DIMASSOC, dimassoc); error++;
      }
  }
  {
    unsigned char halogap;
    if (dwg_dynapi_header_value(dwg, "HALOGAP", &halogap, NULL) &&
        halogap == dwg->header_vars.HALOGAP)
      pass ("HEADER.HALOGAP [unsigned char]");
    else
      {
        fail ("HEADER.HALOGAP [unsigned char] %c != %c", dwg->header_vars.HALOGAP, halogap); error++;
      }
  }
  {
    unsigned short int obscolor;
    if (dwg_dynapi_header_value(dwg, "OBSCOLOR", &obscolor, NULL) &&
        obscolor == dwg->header_vars.OBSCOLOR)
      pass ("HEADER.OBSCOLOR [unsigned short int]");
    else
      {
        fail ("HEADER.OBSCOLOR [unsigned short int] %hu != %hu", dwg->header_vars.OBSCOLOR, obscolor); error++;
      }
  }
  {
    unsigned short int intersectioncolor;
    if (dwg_dynapi_header_value(dwg, "INTERSECTIONCOLOR", &intersectioncolor, NULL) &&
        intersectioncolor == dwg->header_vars.INTERSECTIONCOLOR)
      pass ("HEADER.INTERSECTIONCOLOR [unsigned short int]");
    else
      {
        fail ("HEADER.INTERSECTIONCOLOR [unsigned short int] %hu != %hu", dwg->header_vars.INTERSECTIONCOLOR, intersectioncolor); error++;
      }
  }
  {
    unsigned char obsltype;
    if (dwg_dynapi_header_value(dwg, "OBSLTYPE", &obsltype, NULL) &&
        obsltype == dwg->header_vars.OBSLTYPE)
      pass ("HEADER.OBSLTYPE [unsigned char]");
    else
      {
        fail ("HEADER.OBSLTYPE [unsigned char] %c != %c", dwg->header_vars.OBSLTYPE, obsltype); error++;
      }
  }
  {
    unsigned char intersectiondisplay;
    if (dwg_dynapi_header_value(dwg, "INTERSECTIONDISPLAY", &intersectiondisplay, NULL) &&
        intersectiondisplay == dwg->header_vars.INTERSECTIONDISPLAY)
      pass ("HEADER.INTERSECTIONDISPLAY [unsigned char]");
    else
      {
        fail ("HEADER.INTERSECTIONDISPLAY [unsigned char] %c != %c", dwg->header_vars.INTERSECTIONDISPLAY, intersectiondisplay); error++;
      }
  }
  {
    char* projectname;
    if (dwg_dynapi_header_value(dwg, "PROJECTNAME", &projectname, NULL)
        && !memcmp(&projectname, &dwg->header_vars.PROJECTNAME, sizeof(dwg->header_vars.PROJECTNAME))
       )
      pass ("HEADER.PROJECTNAME [char*]");
    else
      {
        fail ("HEADER.PROJECTNAME [char*]"); error++;
      }
  }
  {
    Dwg_Object_Ref* block_record_pspace;
    if (dwg_dynapi_header_value(dwg, "BLOCK_RECORD_PSPACE", &block_record_pspace, NULL)
        && !memcmp(&block_record_pspace, &dwg->header_vars.BLOCK_RECORD_PSPACE, sizeof(dwg->header_vars.BLOCK_RECORD_PSPACE))
       )
      pass ("HEADER.BLOCK_RECORD_PSPACE [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.BLOCK_RECORD_PSPACE [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    Dwg_Object_Ref* block_record_mspace;
    if (dwg_dynapi_header_value(dwg, "BLOCK_RECORD_MSPACE", &block_record_mspace, NULL)
        && !memcmp(&block_record_mspace, &dwg->header_vars.BLOCK_RECORD_MSPACE, sizeof(dwg->header_vars.BLOCK_RECORD_MSPACE))
       )
      pass ("HEADER.BLOCK_RECORD_MSPACE [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.BLOCK_RECORD_MSPACE [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    Dwg_Object_Ref* ltype_bylayer;
    if (dwg_dynapi_header_value(dwg, "LTYPE_BYLAYER", &ltype_bylayer, NULL)
        && !memcmp(&ltype_bylayer, &dwg->header_vars.LTYPE_BYLAYER, sizeof(dwg->header_vars.LTYPE_BYLAYER))
       )
      pass ("HEADER.LTYPE_BYLAYER [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.LTYPE_BYLAYER [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    Dwg_Object_Ref* ltype_byblock;
    if (dwg_dynapi_header_value(dwg, "LTYPE_BYBLOCK", &ltype_byblock, NULL)
        && !memcmp(&ltype_byblock, &dwg->header_vars.LTYPE_BYBLOCK, sizeof(dwg->header_vars.LTYPE_BYBLOCK))
       )
      pass ("HEADER.LTYPE_BYBLOCK [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.LTYPE_BYBLOCK [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    Dwg_Object_Ref* ltype_continuous;
    if (dwg_dynapi_header_value(dwg, "LTYPE_CONTINUOUS", &ltype_continuous, NULL)
        && !memcmp(&ltype_continuous, &dwg->header_vars.LTYPE_CONTINUOUS, sizeof(dwg->header_vars.LTYPE_CONTINUOUS))
       )
      pass ("HEADER.LTYPE_CONTINUOUS [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.LTYPE_CONTINUOUS [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    unsigned char cameradisplay;
    if (dwg_dynapi_header_value(dwg, "CAMERADISPLAY", &cameradisplay, NULL) &&
        cameradisplay == dwg->header_vars.CAMERADISPLAY)
      pass ("HEADER.CAMERADISPLAY [unsigned char]");
    else
      {
        fail ("HEADER.CAMERADISPLAY [unsigned char] %c != %c", dwg->header_vars.CAMERADISPLAY, cameradisplay); error++;
      }
  }
  {
    unsigned int unknown_21;
    if (dwg_dynapi_header_value(dwg, "unknown_21", &unknown_21, NULL) &&
        unknown_21 == dwg->header_vars.unknown_21)
      pass ("HEADER.unknown_21 [unsigned int]");
    else
      {
        fail ("HEADER.unknown_21 [unsigned int] %u != %u", dwg->header_vars.unknown_21, unknown_21); error++;
      }
  }
  {
    unsigned int unknown_22;
    if (dwg_dynapi_header_value(dwg, "unknown_22", &unknown_22, NULL) &&
        unknown_22 == dwg->header_vars.unknown_22)
      pass ("HEADER.unknown_22 [unsigned int]");
    else
      {
        fail ("HEADER.unknown_22 [unsigned int] %u != %u", dwg->header_vars.unknown_22, unknown_22); error++;
      }
  }
  {
    double unknown_23;
    if (dwg_dynapi_header_value(dwg, "unknown_23", &unknown_23, NULL) &&
        unknown_23 == dwg->header_vars.unknown_23)
      pass ("HEADER.unknown_23 [double]");
    else
      {
        fail ("HEADER.unknown_23 [double] %g != %g", dwg->header_vars.unknown_23, unknown_23); error++;
      }
  }
  {
    double stepspersec;
    if (dwg_dynapi_header_value(dwg, "STEPSPERSEC", &stepspersec, NULL) &&
        stepspersec == dwg->header_vars.STEPSPERSEC)
      pass ("HEADER.STEPSPERSEC [double]");
    else
      {
        fail ("HEADER.STEPSPERSEC [double] %g != %g", dwg->header_vars.STEPSPERSEC, stepspersec); error++;
      }
  }
  {
    double stepsize;
    if (dwg_dynapi_header_value(dwg, "STEPSIZE", &stepsize, NULL) &&
        stepsize == dwg->header_vars.STEPSIZE)
      pass ("HEADER.STEPSIZE [double]");
    else
      {
        fail ("HEADER.STEPSIZE [double] %g != %g", dwg->header_vars.STEPSIZE, stepsize); error++;
      }
  }
  {
    double _3ddwfprec;
    if (dwg_dynapi_header_value(dwg, "_3DDWFPREC", &_3ddwfprec, NULL) &&
        _3ddwfprec == dwg->header_vars._3DDWFPREC)
      pass ("HEADER._3DDWFPREC [double]");
    else
      {
        fail ("HEADER._3DDWFPREC [double] %g != %g", dwg->header_vars._3DDWFPREC, _3ddwfprec); error++;
      }
  }
  {
    double lenslength;
    if (dwg_dynapi_header_value(dwg, "LENSLENGTH", &lenslength, NULL) &&
        lenslength == dwg->header_vars.LENSLENGTH)
      pass ("HEADER.LENSLENGTH [double]");
    else
      {
        fail ("HEADER.LENSLENGTH [double] %g != %g", dwg->header_vars.LENSLENGTH, lenslength); error++;
      }
  }
  {
    double cameraheight;
    if (dwg_dynapi_header_value(dwg, "CAMERAHEIGHT", &cameraheight, NULL) &&
        cameraheight == dwg->header_vars.CAMERAHEIGHT)
      pass ("HEADER.CAMERAHEIGHT [double]");
    else
      {
        fail ("HEADER.CAMERAHEIGHT [double] %g != %g", dwg->header_vars.CAMERAHEIGHT, cameraheight); error++;
      }
  }
  {
    unsigned char solidhist;
    if (dwg_dynapi_header_value(dwg, "SOLIDHIST", &solidhist, NULL) &&
        solidhist == dwg->header_vars.SOLIDHIST)
      pass ("HEADER.SOLIDHIST [unsigned char]");
    else
      {
        fail ("HEADER.SOLIDHIST [unsigned char] %c != %c", dwg->header_vars.SOLIDHIST, solidhist); error++;
      }
  }
  {
    unsigned char showhist;
    if (dwg_dynapi_header_value(dwg, "SHOWHIST", &showhist, NULL) &&
        showhist == dwg->header_vars.SHOWHIST)
      pass ("HEADER.SHOWHIST [unsigned char]");
    else
      {
        fail ("HEADER.SHOWHIST [unsigned char] %c != %c", dwg->header_vars.SHOWHIST, showhist); error++;
      }
  }
  {
    double psolwidth;
    if (dwg_dynapi_header_value(dwg, "PSOLWIDTH", &psolwidth, NULL) &&
        psolwidth == dwg->header_vars.PSOLWIDTH)
      pass ("HEADER.PSOLWIDTH [double]");
    else
      {
        fail ("HEADER.PSOLWIDTH [double] %g != %g", dwg->header_vars.PSOLWIDTH, psolwidth); error++;
      }
  }
  {
    double psolheight;
    if (dwg_dynapi_header_value(dwg, "PSOLHEIGHT", &psolheight, NULL) &&
        psolheight == dwg->header_vars.PSOLHEIGHT)
      pass ("HEADER.PSOLHEIGHT [double]");
    else
      {
        fail ("HEADER.PSOLHEIGHT [double] %g != %g", dwg->header_vars.PSOLHEIGHT, psolheight); error++;
      }
  }
  {
    double loftang1;
    if (dwg_dynapi_header_value(dwg, "LOFTANG1", &loftang1, NULL) &&
        loftang1 == dwg->header_vars.LOFTANG1)
      pass ("HEADER.LOFTANG1 [double]");
    else
      {
        fail ("HEADER.LOFTANG1 [double] %g != %g", dwg->header_vars.LOFTANG1, loftang1); error++;
      }
  }
  {
    double loftang2;
    if (dwg_dynapi_header_value(dwg, "LOFTANG2", &loftang2, NULL) &&
        loftang2 == dwg->header_vars.LOFTANG2)
      pass ("HEADER.LOFTANG2 [double]");
    else
      {
        fail ("HEADER.LOFTANG2 [double] %g != %g", dwg->header_vars.LOFTANG2, loftang2); error++;
      }
  }
  {
    double loftmag1;
    if (dwg_dynapi_header_value(dwg, "LOFTMAG1", &loftmag1, NULL) &&
        loftmag1 == dwg->header_vars.LOFTMAG1)
      pass ("HEADER.LOFTMAG1 [double]");
    else
      {
        fail ("HEADER.LOFTMAG1 [double] %g != %g", dwg->header_vars.LOFTMAG1, loftmag1); error++;
      }
  }
  {
    double loftmag2;
    if (dwg_dynapi_header_value(dwg, "LOFTMAG2", &loftmag2, NULL) &&
        loftmag2 == dwg->header_vars.LOFTMAG2)
      pass ("HEADER.LOFTMAG2 [double]");
    else
      {
        fail ("HEADER.LOFTMAG2 [double] %g != %g", dwg->header_vars.LOFTMAG2, loftmag2); error++;
      }
  }
  {
    unsigned short int loftparam;
    if (dwg_dynapi_header_value(dwg, "LOFTPARAM", &loftparam, NULL) &&
        loftparam == dwg->header_vars.LOFTPARAM)
      pass ("HEADER.LOFTPARAM [unsigned short int]");
    else
      {
        fail ("HEADER.LOFTPARAM [unsigned short int] %hu != %hu", dwg->header_vars.LOFTPARAM, loftparam); error++;
      }
  }
  {
    unsigned char loftnormals;
    if (dwg_dynapi_header_value(dwg, "LOFTNORMALS", &loftnormals, NULL) &&
        loftnormals == dwg->header_vars.LOFTNORMALS)
      pass ("HEADER.LOFTNORMALS [unsigned char]");
    else
      {
        fail ("HEADER.LOFTNORMALS [unsigned char] %c != %c", dwg->header_vars.LOFTNORMALS, loftnormals); error++;
      }
  }
  {
    double latitude;
    if (dwg_dynapi_header_value(dwg, "LATITUDE", &latitude, NULL) &&
        latitude == dwg->header_vars.LATITUDE)
      pass ("HEADER.LATITUDE [double]");
    else
      {
        fail ("HEADER.LATITUDE [double] %g != %g", dwg->header_vars.LATITUDE, latitude); error++;
      }
  }
  {
    double longitude;
    if (dwg_dynapi_header_value(dwg, "LONGITUDE", &longitude, NULL) &&
        longitude == dwg->header_vars.LONGITUDE)
      pass ("HEADER.LONGITUDE [double]");
    else
      {
        fail ("HEADER.LONGITUDE [double] %g != %g", dwg->header_vars.LONGITUDE, longitude); error++;
      }
  }
  {
    double northdirection;
    if (dwg_dynapi_header_value(dwg, "NORTHDIRECTION", &northdirection, NULL) &&
        northdirection == dwg->header_vars.NORTHDIRECTION)
      pass ("HEADER.NORTHDIRECTION [double]");
    else
      {
        fail ("HEADER.NORTHDIRECTION [double] %g != %g", dwg->header_vars.NORTHDIRECTION, northdirection); error++;
      }
  }
  {
    unsigned int timezone;
    if (dwg_dynapi_header_value(dwg, "TIMEZONE", &timezone, NULL) &&
        timezone == dwg->header_vars.TIMEZONE)
      pass ("HEADER.TIMEZONE [unsigned int]");
    else
      {
        fail ("HEADER.TIMEZONE [unsigned int] %u != %u", dwg->header_vars.TIMEZONE, timezone); error++;
      }
  }
  {
    unsigned char lightglyphdisplay;
    if (dwg_dynapi_header_value(dwg, "LIGHTGLYPHDISPLAY", &lightglyphdisplay, NULL) &&
        lightglyphdisplay == dwg->header_vars.LIGHTGLYPHDISPLAY)
      pass ("HEADER.LIGHTGLYPHDISPLAY [unsigned char]");
    else
      {
        fail ("HEADER.LIGHTGLYPHDISPLAY [unsigned char] %c != %c", dwg->header_vars.LIGHTGLYPHDISPLAY, lightglyphdisplay); error++;
      }
  }
  {
    unsigned char tilemodelightsynch;
    if (dwg_dynapi_header_value(dwg, "TILEMODELIGHTSYNCH", &tilemodelightsynch, NULL) &&
        tilemodelightsynch == dwg->header_vars.TILEMODELIGHTSYNCH)
      pass ("HEADER.TILEMODELIGHTSYNCH [unsigned char]");
    else
      {
        fail ("HEADER.TILEMODELIGHTSYNCH [unsigned char] %c != %c", dwg->header_vars.TILEMODELIGHTSYNCH, tilemodelightsynch); error++;
      }
  }
  {
    unsigned char dwfframe;
    if (dwg_dynapi_header_value(dwg, "DWFFRAME", &dwfframe, NULL) &&
        dwfframe == dwg->header_vars.DWFFRAME)
      pass ("HEADER.DWFFRAME [unsigned char]");
    else
      {
        fail ("HEADER.DWFFRAME [unsigned char] %c != %c", dwg->header_vars.DWFFRAME, dwfframe); error++;
      }
  }
  {
    unsigned char dgnframe;
    if (dwg_dynapi_header_value(dwg, "DGNFRAME", &dgnframe, NULL) &&
        dgnframe == dwg->header_vars.DGNFRAME)
      pass ("HEADER.DGNFRAME [unsigned char]");
    else
      {
        fail ("HEADER.DGNFRAME [unsigned char] %c != %c", dwg->header_vars.DGNFRAME, dgnframe); error++;
      }
  }
  {
    unsigned char realworldscale;
    if (dwg_dynapi_header_value(dwg, "REALWORLDSCALE", &realworldscale, NULL) &&
        realworldscale == dwg->header_vars.REALWORLDSCALE)
      pass ("HEADER.REALWORLDSCALE [unsigned char]");
    else
      {
        fail ("HEADER.REALWORLDSCALE [unsigned char] %c != %c", dwg->header_vars.REALWORLDSCALE, realworldscale); error++;
      }
  }
  {
    Dwg_Color interferecolor;
    if (dwg_dynapi_header_value(dwg, "INTERFERECOLOR", &interferecolor, NULL)
        && !memcmp(&interferecolor, &dwg->header_vars.INTERFERECOLOR, sizeof(dwg->header_vars.INTERFERECOLOR))
       )
      pass ("HEADER.INTERFERECOLOR [Dwg_Color]");
    else
      {
        fail ("HEADER.INTERFERECOLOR [Dwg_Color]"); error++;
      }
  }
  {
    Dwg_Object_Ref* interfereobjvs;
    if (dwg_dynapi_header_value(dwg, "INTERFEREOBJVS", &interfereobjvs, NULL)
        && !memcmp(&interfereobjvs, &dwg->header_vars.INTERFEREOBJVS, sizeof(dwg->header_vars.INTERFEREOBJVS))
       )
      pass ("HEADER.INTERFEREOBJVS [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.INTERFEREOBJVS [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    Dwg_Object_Ref* interferevpvs;
    if (dwg_dynapi_header_value(dwg, "INTERFEREVPVS", &interferevpvs, NULL)
        && !memcmp(&interferevpvs, &dwg->header_vars.INTERFEREVPVS, sizeof(dwg->header_vars.INTERFEREVPVS))
       )
      pass ("HEADER.INTERFEREVPVS [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.INTERFEREVPVS [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    Dwg_Object_Ref* dragvs;
    if (dwg_dynapi_header_value(dwg, "DRAGVS", &dragvs, NULL)
        && !memcmp(&dragvs, &dwg->header_vars.DRAGVS, sizeof(dwg->header_vars.DRAGVS))
       )
      pass ("HEADER.DRAGVS [Dwg_Object_Ref*]");
    else
      {
        fail ("HEADER.DRAGVS [Dwg_Object_Ref*]"); error++;
      }
  }
  {
    unsigned char cshadow;
    if (dwg_dynapi_header_value(dwg, "CSHADOW", &cshadow, NULL) &&
        cshadow == dwg->header_vars.CSHADOW)
      pass ("HEADER.CSHADOW [unsigned char]");
    else
      {
        fail ("HEADER.CSHADOW [unsigned char] %c != %c", dwg->header_vars.CSHADOW, cshadow); error++;
      }
  }
  {
    double shadowplanelocation;
    if (dwg_dynapi_header_value(dwg, "SHADOWPLANELOCATION", &shadowplanelocation, NULL) &&
        shadowplanelocation == dwg->header_vars.SHADOWPLANELOCATION)
      pass ("HEADER.SHADOWPLANELOCATION [double]");
    else
      {
        fail ("HEADER.SHADOWPLANELOCATION [double] %g != %g", dwg->header_vars.SHADOWPLANELOCATION, shadowplanelocation); error++;
      }
  }
  {
    unsigned short int unknown_54;
    if (dwg_dynapi_header_value(dwg, "unknown_54", &unknown_54, NULL) &&
        unknown_54 == dwg->header_vars.unknown_54)
      pass ("HEADER.unknown_54 [unsigned short int]");
    else
      {
        fail ("HEADER.unknown_54 [unsigned short int] %hu != %hu", dwg->header_vars.unknown_54, unknown_54); error++;
      }
  }
  {
    unsigned short int unknown_55;
    if (dwg_dynapi_header_value(dwg, "unknown_55", &unknown_55, NULL) &&
        unknown_55 == dwg->header_vars.unknown_55)
      pass ("HEADER.unknown_55 [unsigned short int]");
    else
      {
        fail ("HEADER.unknown_55 [unsigned short int] %hu != %hu", dwg->header_vars.unknown_55, unknown_55); error++;
      }
  }
  {
    unsigned short int unknown_56;
    if (dwg_dynapi_header_value(dwg, "unknown_56", &unknown_56, NULL) &&
        unknown_56 == dwg->header_vars.unknown_56)
      pass ("HEADER.unknown_56 [unsigned short int]");
    else
      {
        fail ("HEADER.unknown_56 [unsigned short int] %hu != %hu", dwg->header_vars.unknown_56, unknown_56); error++;
      }
  }
  {
    unsigned short int unknown_57;
    if (dwg_dynapi_header_value(dwg, "unknown_57", &unknown_57, NULL) &&
        unknown_57 == dwg->header_vars.unknown_57)
      pass ("HEADER.unknown_57 [unsigned short int]");
    else
      {
        fail ("HEADER.unknown_57 [unsigned short int] %hu != %hu", dwg->header_vars.unknown_57, unknown_57); error++;
      }
  }
  {
    unsigned short int crc;
    if (dwg_dynapi_header_value(dwg, "crc", &crc, NULL) &&
        crc == dwg->header_vars.crc)
      pass ("HEADER.crc [unsigned short int]");
    else
      {
        fail ("HEADER.crc [unsigned short int] %hu != %hu", dwg->header_vars.crc, crc); error++;
      }
  }
#line 64 "dynapi_test.c.in"
  return error;
}

#line 3619 "dynapi_test.c"
/* @@for test_OBJECT@@ */
static int test__3DFACE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity__3DFACE *_3dface = obj->tio.entity->tio._3DFACE;
  {
    BITCODE_3BD corner1;
    if (dwg_dynapi_entity_value(_3dface, "3DFACE", "corner1", &corner1, NULL)
        && !memcmp(&corner1, &_3dface->corner1, sizeof(_3dface->corner1)))
      pass ("3DFACE.corner1");
    else
      {
        fail ("3DFACE.corner1"); error++;
      }
  }
  {
    BITCODE_3BD corner2;
    if (dwg_dynapi_entity_value(_3dface, "3DFACE", "corner2", &corner2, NULL)
        && !memcmp(&corner2, &_3dface->corner2, sizeof(_3dface->corner2)))
      pass ("3DFACE.corner2");
    else
      {
        fail ("3DFACE.corner2"); error++;
      }
  }
  {
    BITCODE_3BD corner3;
    if (dwg_dynapi_entity_value(_3dface, "3DFACE", "corner3", &corner3, NULL)
        && !memcmp(&corner3, &_3dface->corner3, sizeof(_3dface->corner3)))
      pass ("3DFACE.corner3");
    else
      {
        fail ("3DFACE.corner3"); error++;
      }
  }
  {
    BITCODE_3BD corner4;
    if (dwg_dynapi_entity_value(_3dface, "3DFACE", "corner4", &corner4, NULL)
        && !memcmp(&corner4, &_3dface->corner4, sizeof(_3dface->corner4)))
      pass ("3DFACE.corner4");
    else
      {
        fail ("3DFACE.corner4"); error++;
      }
  }
  {
    BITCODE_B has_no_flags;
    if (dwg_dynapi_entity_value(_3dface, "3DFACE", "has_no_flags", &has_no_flags, NULL) &&
        has_no_flags == _3dface->has_no_flags)
      pass ("3DFACE.has_no_flags [B]");
    else
      {
        fail ("3DFACE.has_no_flags [B] " FORMAT_B " != " FORMAT_B "", _3dface->has_no_flags, has_no_flags); error++;
      }
  }
  {
    BITCODE_BS invis_flags;
    if (dwg_dynapi_entity_value(_3dface, "3DFACE", "invis_flags", &invis_flags, NULL) &&
        invis_flags == _3dface->invis_flags)
      pass ("3DFACE.invis_flags [BS]");
    else
      {
        fail ("3DFACE.invis_flags [BS] %d != %d", _3dface->invis_flags, invis_flags); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(_3dface, "3DFACE", "parent", &parent, NULL)
        && !memcmp(&parent, &_3dface->parent, sizeof(_3dface->parent)))
      pass ("3DFACE.parent");
    else
      {
        fail ("3DFACE.parent"); error++;
      }
  }
  {
    BITCODE_B z_is_zero;
    if (dwg_dynapi_entity_value(_3dface, "3DFACE", "z_is_zero", &z_is_zero, NULL) &&
        z_is_zero == _3dface->z_is_zero)
      pass ("3DFACE.z_is_zero [B]");
    else
      {
        fail ("3DFACE.z_is_zero [B] " FORMAT_B " != " FORMAT_B "", _3dface->z_is_zero, z_is_zero); error++;
      }
  }
  return error;
}
static int test__3DSOLID (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity__3DSOLID *_3dsolid = obj->tio.entity->tio._3DSOLID;
  {
    BITCODE_RC* acis_data;
    if (dwg_dynapi_entity_value(_3dsolid, "3DSOLID", "acis_data", &acis_data, NULL)
        && !strcmp((char*)&acis_data, (char*)&_3dsolid->acis_data))
      pass ("3DSOLID.acis_data");
    else
      {
        fail ("3DSOLID.acis_data"); error++;
      }
  }
  {
    BITCODE_B acis_empty;
    if (dwg_dynapi_entity_value(_3dsolid, "3DSOLID", "acis_empty", &acis_empty, NULL) &&
        acis_empty == _3dsolid->acis_empty)
      pass ("3DSOLID.acis_empty [B]");
    else
      {
        fail ("3DSOLID.acis_empty [B] " FORMAT_B " != " FORMAT_B "", _3dsolid->acis_empty, acis_empty); error++;
      }
  }
  {
    BITCODE_B acis_empty2;
    if (dwg_dynapi_entity_value(_3dsolid, "3DSOLID", "acis_empty2", &acis_empty2, NULL) &&
        acis_empty2 == _3dsolid->acis_empty2)
      pass ("3DSOLID.acis_empty2 [B]");
    else
      {
        fail ("3DSOLID.acis_empty2 [B] " FORMAT_B " != " FORMAT_B "", _3dsolid->acis_empty2, acis_empty2); error++;
      }
  }
  {
    BITCODE_B acis_empty_bit;
    if (dwg_dynapi_entity_value(_3dsolid, "3DSOLID", "acis_empty_bit", &acis_empty_bit, NULL) &&
        acis_empty_bit == _3dsolid->acis_empty_bit)
      pass ("3DSOLID.acis_empty_bit [B]");
    else
      {
        fail ("3DSOLID.acis_empty_bit [B] " FORMAT_B " != " FORMAT_B "", _3dsolid->acis_empty_bit, acis_empty_bit); error++;
      }
  }
  {
    BITCODE_BL* block_size;
    if (dwg_dynapi_entity_value(_3dsolid, "3DSOLID", "block_size", &block_size, NULL)
        && !memcmp(&block_size, &_3dsolid->block_size, sizeof(_3dsolid->block_size)))
      pass ("3DSOLID.block_size");
    else
      {
        fail ("3DSOLID.block_size"); error++;
      }
  }
  {
    BITCODE_RC** encr_sat_data;
    if (dwg_dynapi_entity_value(_3dsolid, "3DSOLID", "encr_sat_data", &encr_sat_data, NULL)
)
      pass ("3DSOLID.encr_sat_data");
    else
      {
        fail ("3DSOLID.encr_sat_data"); error++;
      }
  }
  {
    struct _dwg_entity_3DSOLID* extra_acis_data;
    if (dwg_dynapi_entity_value(_3dsolid, "3DSOLID", "extra_acis_data", &extra_acis_data, NULL)
        && !memcmp(&extra_acis_data, &_3dsolid->extra_acis_data, sizeof(_3dsolid->extra_acis_data)))
      pass ("3DSOLID.extra_acis_data");
    else
      {
        fail ("3DSOLID.extra_acis_data"); error++;
      }
  }
  {
    BITCODE_H history_id;
    if (dwg_dynapi_entity_value(_3dsolid, "3DSOLID", "history_id", &history_id, NULL) &&
        history_id == _3dsolid->history_id)
      pass ("3DSOLID.history_id [H]");
    else
      {
        fail ("3DSOLID.history_id [H] %p != %p", _3dsolid->history_id, history_id); error++;
      }
  }
  {
    BITCODE_B isoline_present;
    if (dwg_dynapi_entity_value(_3dsolid, "3DSOLID", "isoline_present", &isoline_present, NULL) &&
        isoline_present == _3dsolid->isoline_present)
      pass ("3DSOLID.isoline_present [B]");
    else
      {
        fail ("3DSOLID.isoline_present [B] " FORMAT_B " != " FORMAT_B "", _3dsolid->isoline_present, isoline_present); error++;
      }
  }
  {
    BITCODE_BL num_blocks;
    if (dwg_dynapi_entity_value(_3dsolid, "3DSOLID", "num_blocks", &num_blocks, NULL) &&
        num_blocks == _3dsolid->num_blocks)
      pass ("3DSOLID.num_blocks [BL]");
    else
      {
        fail ("3DSOLID.num_blocks [BL] %u != %u", _3dsolid->num_blocks, num_blocks); error++;
      }
  }
  {
    BITCODE_BL num_isolines;
    if (dwg_dynapi_entity_value(_3dsolid, "3DSOLID", "num_isolines", &num_isolines, NULL) &&
        num_isolines == _3dsolid->num_isolines)
      pass ("3DSOLID.num_isolines [BL]");
    else
      {
        fail ("3DSOLID.num_isolines [BL] %u != %u", _3dsolid->num_isolines, num_isolines); error++;
      }
  }
  {
    BITCODE_BL num_silhouettes;
    if (dwg_dynapi_entity_value(_3dsolid, "3DSOLID", "num_silhouettes", &num_silhouettes, NULL) &&
        num_silhouettes == _3dsolid->num_silhouettes)
      pass ("3DSOLID.num_silhouettes [BL]");
    else
      {
        fail ("3DSOLID.num_silhouettes [BL] %u != %u", _3dsolid->num_silhouettes, num_silhouettes); error++;
      }
  }
  {
    BITCODE_BL num_wires;
    if (dwg_dynapi_entity_value(_3dsolid, "3DSOLID", "num_wires", &num_wires, NULL) &&
        num_wires == _3dsolid->num_wires)
      pass ("3DSOLID.num_wires [BL]");
    else
      {
        fail ("3DSOLID.num_wires [BL] %u != %u", _3dsolid->num_wires, num_wires); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(_3dsolid, "3DSOLID", "parent", &parent, NULL)
        && !memcmp(&parent, &_3dsolid->parent, sizeof(_3dsolid->parent)))
      pass ("3DSOLID.parent");
    else
      {
        fail ("3DSOLID.parent"); error++;
      }
  }
  {
    BITCODE_3BD point;
    if (dwg_dynapi_entity_value(_3dsolid, "3DSOLID", "point", &point, NULL)
        && !memcmp(&point, &_3dsolid->point, sizeof(_3dsolid->point)))
      pass ("3DSOLID.point");
    else
      {
        fail ("3DSOLID.point"); error++;
      }
  }
  {
    BITCODE_B point_present;
    if (dwg_dynapi_entity_value(_3dsolid, "3DSOLID", "point_present", &point_present, NULL) &&
        point_present == _3dsolid->point_present)
      pass ("3DSOLID.point_present [B]");
    else
      {
        fail ("3DSOLID.point_present [B] " FORMAT_B " != " FORMAT_B "", _3dsolid->point_present, point_present); error++;
      }
  }
  {
    Dwg_3DSOLID_silhouette* silhouettes;
    if (dwg_dynapi_entity_value(_3dsolid, "3DSOLID", "silhouettes", &silhouettes, NULL)
        && !memcmp(&silhouettes, &_3dsolid->silhouettes, sizeof(_3dsolid->silhouettes)))
      pass ("3DSOLID.silhouettes");
    else
      {
        fail ("3DSOLID.silhouettes"); error++;
      }
  }
  {
    BITCODE_B unknown;
    if (dwg_dynapi_entity_value(_3dsolid, "3DSOLID", "unknown", &unknown, NULL) &&
        unknown == _3dsolid->unknown)
      pass ("3DSOLID.unknown [B]");
    else
      {
        fail ("3DSOLID.unknown [B] " FORMAT_B " != " FORMAT_B "", _3dsolid->unknown, unknown); error++;
      }
  }
  {
    BITCODE_BL unknown_2007;
    if (dwg_dynapi_entity_value(_3dsolid, "3DSOLID", "unknown_2007", &unknown_2007, NULL) &&
        unknown_2007 == _3dsolid->unknown_2007)
      pass ("3DSOLID.unknown_2007 [BL]");
    else
      {
        fail ("3DSOLID.unknown_2007 [BL] %u != %u", _3dsolid->unknown_2007, unknown_2007); error++;
      }
  }
  {
    BITCODE_BS version;
    if (dwg_dynapi_entity_value(_3dsolid, "3DSOLID", "version", &version, NULL) &&
        version == _3dsolid->version)
      pass ("3DSOLID.version [BS]");
    else
      {
        fail ("3DSOLID.version [BS] %d != %d", _3dsolid->version, version); error++;
      }
  }
  {
    BITCODE_B wireframe_data_present;
    if (dwg_dynapi_entity_value(_3dsolid, "3DSOLID", "wireframe_data_present", &wireframe_data_present, NULL) &&
        wireframe_data_present == _3dsolid->wireframe_data_present)
      pass ("3DSOLID.wireframe_data_present [B]");
    else
      {
        fail ("3DSOLID.wireframe_data_present [B] " FORMAT_B " != " FORMAT_B "", _3dsolid->wireframe_data_present, wireframe_data_present); error++;
      }
  }
  {
    Dwg_3DSOLID_wire* wires;
    if (dwg_dynapi_entity_value(_3dsolid, "3DSOLID", "wires", &wires, NULL)
        && !memcmp(&wires, &_3dsolid->wires, sizeof(_3dsolid->wires)))
      pass ("3DSOLID.wires");
    else
      {
        fail ("3DSOLID.wires"); error++;
      }
  }
  return error;
}
static int test_ARC (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_ARC *arc = obj->tio.entity->tio.ARC;
  {
    BITCODE_3BD center;
    if (dwg_dynapi_entity_value(arc, "ARC", "center", &center, NULL)
        && !memcmp(&center, &arc->center, sizeof(arc->center)))
      pass ("ARC.center");
    else
      {
        fail ("ARC.center"); error++;
      }
  }
  {
    BITCODE_BD end_angle;
    if (dwg_dynapi_entity_value(arc, "ARC", "end_angle", &end_angle, NULL) &&
        end_angle == arc->end_angle)
      pass ("ARC.end_angle [BD]");
    else
      {
        fail ("ARC.end_angle [BD] %g != %g", arc->end_angle, end_angle); error++;
      }
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value(arc, "ARC", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &arc->extrusion, sizeof(arc->extrusion)))
      pass ("ARC.extrusion");
    else
      {
        fail ("ARC.extrusion"); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(arc, "ARC", "parent", &parent, NULL)
        && !memcmp(&parent, &arc->parent, sizeof(arc->parent)))
      pass ("ARC.parent");
    else
      {
        fail ("ARC.parent"); error++;
      }
  }
  {
    BITCODE_BD radius;
    if (dwg_dynapi_entity_value(arc, "ARC", "radius", &radius, NULL) &&
        radius == arc->radius)
      pass ("ARC.radius [BD]");
    else
      {
        fail ("ARC.radius [BD] %g != %g", arc->radius, radius); error++;
      }
  }
  {
    BITCODE_BD start_angle;
    if (dwg_dynapi_entity_value(arc, "ARC", "start_angle", &start_angle, NULL) &&
        start_angle == arc->start_angle)
      pass ("ARC.start_angle [BD]");
    else
      {
        fail ("ARC.start_angle [BD] %g != %g", arc->start_angle, start_angle); error++;
      }
  }
  {
    BITCODE_BT thickness;
    if (dwg_dynapi_entity_value(arc, "ARC", "thickness", &thickness, NULL) &&
        thickness == arc->thickness)
      pass ("ARC.thickness [BT]");
    else
      {
        fail ("ARC.thickness [BT] " FORMAT_BT " != " FORMAT_BT "", arc->thickness, thickness); error++;
      }
  }
  return error;
}
static int test_ATTDEF (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_ATTDEF *attdef = obj->tio.entity->tio.ATTDEF;
  {
    BITCODE_2DPOINT alignment_pt;
    if (dwg_dynapi_entity_value(attdef, "ATTDEF", "alignment_pt", &alignment_pt, NULL)
        && !memcmp(&alignment_pt, &attdef->alignment_pt, sizeof(attdef->alignment_pt)))
      pass ("ATTDEF.alignment_pt");
    else
      {
        fail ("ATTDEF.alignment_pt"); error++;
      }
  }
  {
    BITCODE_RC class_version;
    if (dwg_dynapi_entity_value(attdef, "ATTDEF", "class_version", &class_version, NULL) &&
        class_version == attdef->class_version)
      pass ("ATTDEF.class_version [RC]");
    else
      {
        fail ("ATTDEF.class_version [RC] %c != %c", attdef->class_version, class_version); error++;
      }
  }
  {
    BITCODE_RC dataflags;
    if (dwg_dynapi_entity_value(attdef, "ATTDEF", "dataflags", &dataflags, NULL) &&
        dataflags == attdef->dataflags)
      pass ("ATTDEF.dataflags [RC]");
    else
      {
        fail ("ATTDEF.dataflags [RC] %c != %c", attdef->dataflags, dataflags); error++;
      }
  }
  {
    BITCODE_TV default_value;
    if (dwg_dynapi_entity_value(attdef, "ATTDEF", "default_value", &default_value, NULL)
        && !strcmp((char*)&default_value, (char*)&attdef->default_value))
      pass ("ATTDEF.default_value");
    else
      {
        fail ("ATTDEF.default_value"); error++;
      }
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value(attdef, "ATTDEF", "elevation", &elevation, NULL) &&
        elevation == attdef->elevation)
      pass ("ATTDEF.elevation [BD]");
    else
      {
        fail ("ATTDEF.elevation [BD] %g != %g", attdef->elevation, elevation); error++;
      }
  }
  {
    BITCODE_3DPOINT extrusion;
    if (dwg_dynapi_entity_value(attdef, "ATTDEF", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &attdef->extrusion, sizeof(attdef->extrusion)))
      pass ("ATTDEF.extrusion");
    else
      {
        fail ("ATTDEF.extrusion"); error++;
      }
  }
  {
    BITCODE_BS field_length;
    if (dwg_dynapi_entity_value(attdef, "ATTDEF", "field_length", &field_length, NULL) &&
        field_length == attdef->field_length)
      pass ("ATTDEF.field_length [BS]");
    else
      {
        fail ("ATTDEF.field_length [BS] %d != %d", attdef->field_length, field_length); error++;
      }
  }
  {
    BITCODE_RC flags;
    if (dwg_dynapi_entity_value(attdef, "ATTDEF", "flags", &flags, NULL) &&
        flags == attdef->flags)
      pass ("ATTDEF.flags [RC]");
    else
      {
        fail ("ATTDEF.flags [RC] %c != %c", attdef->flags, flags); error++;
      }
  }
  {
    BITCODE_BS generation;
    if (dwg_dynapi_entity_value(attdef, "ATTDEF", "generation", &generation, NULL) &&
        generation == attdef->generation)
      pass ("ATTDEF.generation [BS]");
    else
      {
        fail ("ATTDEF.generation [BS] %d != %d", attdef->generation, generation); error++;
      }
  }
  {
    BITCODE_RD height;
    if (dwg_dynapi_entity_value(attdef, "ATTDEF", "height", &height, NULL) &&
        height == attdef->height)
      pass ("ATTDEF.height [RD]");
    else
      {
        fail ("ATTDEF.height [RD] " FORMAT_RD " != " FORMAT_RD "", attdef->height, height); error++;
      }
  }
  {
    BITCODE_BS horiz_alignment;
    if (dwg_dynapi_entity_value(attdef, "ATTDEF", "horiz_alignment", &horiz_alignment, NULL) &&
        horiz_alignment == attdef->horiz_alignment)
      pass ("ATTDEF.horiz_alignment [BS]");
    else
      {
        fail ("ATTDEF.horiz_alignment [BS] %d != %d", attdef->horiz_alignment, horiz_alignment); error++;
      }
  }
  {
    BITCODE_2DPOINT insertion_pt;
    if (dwg_dynapi_entity_value(attdef, "ATTDEF", "insertion_pt", &insertion_pt, NULL)
        && !memcmp(&insertion_pt, &attdef->insertion_pt, sizeof(attdef->insertion_pt)))
      pass ("ATTDEF.insertion_pt");
    else
      {
        fail ("ATTDEF.insertion_pt"); error++;
      }
  }
  {
    BITCODE_B lock_position_flag;
    if (dwg_dynapi_entity_value(attdef, "ATTDEF", "lock_position_flag", &lock_position_flag, NULL) &&
        lock_position_flag == attdef->lock_position_flag)
      pass ("ATTDEF.lock_position_flag [B]");
    else
      {
        fail ("ATTDEF.lock_position_flag [B] " FORMAT_B " != " FORMAT_B "", attdef->lock_position_flag, lock_position_flag); error++;
      }
  }
  {
    BITCODE_RD oblique_ang;
    if (dwg_dynapi_entity_value(attdef, "ATTDEF", "oblique_ang", &oblique_ang, NULL) &&
        oblique_ang == attdef->oblique_ang)
      pass ("ATTDEF.oblique_ang [RD]");
    else
      {
        fail ("ATTDEF.oblique_ang [RD] " FORMAT_RD " != " FORMAT_RD "", attdef->oblique_ang, oblique_ang); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(attdef, "ATTDEF", "parent", &parent, NULL)
        && !memcmp(&parent, &attdef->parent, sizeof(attdef->parent)))
      pass ("ATTDEF.parent");
    else
      {
        fail ("ATTDEF.parent"); error++;
      }
  }
  {
    BITCODE_TV prompt;
    if (dwg_dynapi_entity_value(attdef, "ATTDEF", "prompt", &prompt, NULL)
        && !strcmp((char*)&prompt, (char*)&attdef->prompt))
      pass ("ATTDEF.prompt");
    else
      {
        fail ("ATTDEF.prompt"); error++;
      }
  }
  {
    BITCODE_RD rotation;
    if (dwg_dynapi_entity_value(attdef, "ATTDEF", "rotation", &rotation, NULL) &&
        rotation == attdef->rotation)
      pass ("ATTDEF.rotation [RD]");
    else
      {
        fail ("ATTDEF.rotation [RD] " FORMAT_RD " != " FORMAT_RD "", attdef->rotation, rotation); error++;
      }
  }
  {
    BITCODE_H style;
    if (dwg_dynapi_entity_value(attdef, "ATTDEF", "style", &style, NULL) &&
        style == attdef->style)
      pass ("ATTDEF.style [H]");
    else
      {
        fail ("ATTDEF.style [H] %p != %p", attdef->style, style); error++;
      }
  }
  {
    BITCODE_TV tag;
    if (dwg_dynapi_entity_value(attdef, "ATTDEF", "tag", &tag, NULL)
        && !strcmp((char*)&tag, (char*)&attdef->tag))
      pass ("ATTDEF.tag");
    else
      {
        fail ("ATTDEF.tag"); error++;
      }
  }
  {
    BITCODE_RD thickness;
    if (dwg_dynapi_entity_value(attdef, "ATTDEF", "thickness", &thickness, NULL) &&
        thickness == attdef->thickness)
      pass ("ATTDEF.thickness [RD]");
    else
      {
        fail ("ATTDEF.thickness [RD] " FORMAT_RD " != " FORMAT_RD "", attdef->thickness, thickness); error++;
      }
  }
  {
    BITCODE_BS vert_alignment;
    if (dwg_dynapi_entity_value(attdef, "ATTDEF", "vert_alignment", &vert_alignment, NULL) &&
        vert_alignment == attdef->vert_alignment)
      pass ("ATTDEF.vert_alignment [BS]");
    else
      {
        fail ("ATTDEF.vert_alignment [BS] %d != %d", attdef->vert_alignment, vert_alignment); error++;
      }
  }
  {
    BITCODE_RD width_factor;
    if (dwg_dynapi_entity_value(attdef, "ATTDEF", "width_factor", &width_factor, NULL) &&
        width_factor == attdef->width_factor)
      pass ("ATTDEF.width_factor [RD]");
    else
      {
        fail ("ATTDEF.width_factor [RD] " FORMAT_RD " != " FORMAT_RD "", attdef->width_factor, width_factor); error++;
      }
  }
  return error;
}
static int test_ATTRIB (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_ATTRIB *attrib = obj->tio.entity->tio.ATTRIB;
  {
    BITCODE_2DPOINT alignment_pt;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "alignment_pt", &alignment_pt, NULL)
        && !memcmp(&alignment_pt, &attrib->alignment_pt, sizeof(attrib->alignment_pt)))
      pass ("ATTRIB.alignment_pt");
    else
      {
        fail ("ATTRIB.alignment_pt"); error++;
      }
  }
  {
    BITCODE_H annotative_app;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "annotative_app", &annotative_app, NULL) &&
        annotative_app == attrib->annotative_app)
      pass ("ATTRIB.annotative_app [H]");
    else
      {
        fail ("ATTRIB.annotative_app [H] %p != %p", attrib->annotative_app, annotative_app); error++;
      }
  }
  {
    BITCODE_RC annotative_data_bytes;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "annotative_data_bytes", &annotative_data_bytes, NULL) &&
        annotative_data_bytes == attrib->annotative_data_bytes)
      pass ("ATTRIB.annotative_data_bytes [RC]");
    else
      {
        fail ("ATTRIB.annotative_data_bytes [RC] %c != %c", attrib->annotative_data_bytes, annotative_data_bytes); error++;
      }
  }
  {
    BITCODE_BS annotative_data_size;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "annotative_data_size", &annotative_data_size, NULL) &&
        annotative_data_size == attrib->annotative_data_size)
      pass ("ATTRIB.annotative_data_size [BS]");
    else
      {
        fail ("ATTRIB.annotative_data_size [BS] %d != %d", attrib->annotative_data_size, annotative_data_size); error++;
      }
  }
  {
    BITCODE_BS annotative_short;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "annotative_short", &annotative_short, NULL) &&
        annotative_short == attrib->annotative_short)
      pass ("ATTRIB.annotative_short [BS]");
    else
      {
        fail ("ATTRIB.annotative_short [BS] %d != %d", attrib->annotative_short, annotative_short); error++;
      }
  }
  {
    BITCODE_RC class_version;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "class_version", &class_version, NULL) &&
        class_version == attrib->class_version)
      pass ("ATTRIB.class_version [RC]");
    else
      {
        fail ("ATTRIB.class_version [RC] %c != %c", attrib->class_version, class_version); error++;
      }
  }
  {
    BITCODE_RC dataflags;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "dataflags", &dataflags, NULL) &&
        dataflags == attrib->dataflags)
      pass ("ATTRIB.dataflags [RC]");
    else
      {
        fail ("ATTRIB.dataflags [RC] %c != %c", attrib->dataflags, dataflags); error++;
      }
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "elevation", &elevation, NULL) &&
        elevation == attrib->elevation)
      pass ("ATTRIB.elevation [BD]");
    else
      {
        fail ("ATTRIB.elevation [BD] %g != %g", attrib->elevation, elevation); error++;
      }
  }
  {
    BITCODE_3DPOINT extrusion;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &attrib->extrusion, sizeof(attrib->extrusion)))
      pass ("ATTRIB.extrusion");
    else
      {
        fail ("ATTRIB.extrusion"); error++;
      }
  }
  {
    BITCODE_BS field_length;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "field_length", &field_length, NULL) &&
        field_length == attrib->field_length)
      pass ("ATTRIB.field_length [BS]");
    else
      {
        fail ("ATTRIB.field_length [BS] %d != %d", attrib->field_length, field_length); error++;
      }
  }
  {
    BITCODE_RC flags;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "flags", &flags, NULL) &&
        flags == attrib->flags)
      pass ("ATTRIB.flags [RC]");
    else
      {
        fail ("ATTRIB.flags [RC] %c != %c", attrib->flags, flags); error++;
      }
  }
  {
    BITCODE_BS generation;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "generation", &generation, NULL) &&
        generation == attrib->generation)
      pass ("ATTRIB.generation [BS]");
    else
      {
        fail ("ATTRIB.generation [BS] %d != %d", attrib->generation, generation); error++;
      }
  }
  {
    BITCODE_RD height;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "height", &height, NULL) &&
        height == attrib->height)
      pass ("ATTRIB.height [RD]");
    else
      {
        fail ("ATTRIB.height [RD] " FORMAT_RD " != " FORMAT_RD "", attrib->height, height); error++;
      }
  }
  {
    BITCODE_BS horiz_alignment;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "horiz_alignment", &horiz_alignment, NULL) &&
        horiz_alignment == attrib->horiz_alignment)
      pass ("ATTRIB.horiz_alignment [BS]");
    else
      {
        fail ("ATTRIB.horiz_alignment [BS] %d != %d", attrib->horiz_alignment, horiz_alignment); error++;
      }
  }
  {
    BITCODE_2DPOINT insertion_pt;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "insertion_pt", &insertion_pt, NULL)
        && !memcmp(&insertion_pt, &attrib->insertion_pt, sizeof(attrib->insertion_pt)))
      pass ("ATTRIB.insertion_pt");
    else
      {
        fail ("ATTRIB.insertion_pt"); error++;
      }
  }
  {
    BITCODE_B lock_position_flag;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "lock_position_flag", &lock_position_flag, NULL) &&
        lock_position_flag == attrib->lock_position_flag)
      pass ("ATTRIB.lock_position_flag [B]");
    else
      {
        fail ("ATTRIB.lock_position_flag [B] " FORMAT_B " != " FORMAT_B "", attrib->lock_position_flag, lock_position_flag); error++;
      }
  }
  {
    BITCODE_H mtext_handles;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "mtext_handles", &mtext_handles, NULL) &&
        mtext_handles == attrib->mtext_handles)
      pass ("ATTRIB.mtext_handles [H]");
    else
      {
        fail ("ATTRIB.mtext_handles [H] %p != %p", attrib->mtext_handles, mtext_handles); error++;
      }
  }
  {
    BITCODE_RD oblique_ang;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "oblique_ang", &oblique_ang, NULL) &&
        oblique_ang == attrib->oblique_ang)
      pass ("ATTRIB.oblique_ang [RD]");
    else
      {
        fail ("ATTRIB.oblique_ang [RD] " FORMAT_RD " != " FORMAT_RD "", attrib->oblique_ang, oblique_ang); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "parent", &parent, NULL)
        && !memcmp(&parent, &attrib->parent, sizeof(attrib->parent)))
      pass ("ATTRIB.parent");
    else
      {
        fail ("ATTRIB.parent"); error++;
      }
  }
  {
    BITCODE_RD rotation;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "rotation", &rotation, NULL) &&
        rotation == attrib->rotation)
      pass ("ATTRIB.rotation [RD]");
    else
      {
        fail ("ATTRIB.rotation [RD] " FORMAT_RD " != " FORMAT_RD "", attrib->rotation, rotation); error++;
      }
  }
  {
    BITCODE_H style;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "style", &style, NULL) &&
        style == attrib->style)
      pass ("ATTRIB.style [H]");
    else
      {
        fail ("ATTRIB.style [H] %p != %p", attrib->style, style); error++;
      }
  }
  {
    BITCODE_TV tag;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "tag", &tag, NULL)
        && !strcmp((char*)&tag, (char*)&attrib->tag))
      pass ("ATTRIB.tag");
    else
      {
        fail ("ATTRIB.tag"); error++;
      }
  }
  {
    BITCODE_TV text_value;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "text_value", &text_value, NULL)
        && !strcmp((char*)&text_value, (char*)&attrib->text_value))
      pass ("ATTRIB.text_value");
    else
      {
        fail ("ATTRIB.text_value"); error++;
      }
  }
  {
    BITCODE_RD thickness;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "thickness", &thickness, NULL) &&
        thickness == attrib->thickness)
      pass ("ATTRIB.thickness [RD]");
    else
      {
        fail ("ATTRIB.thickness [RD] " FORMAT_RD " != " FORMAT_RD "", attrib->thickness, thickness); error++;
      }
  }
  {
    BITCODE_RC type;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "type", &type, NULL) &&
        type == attrib->type)
      pass ("ATTRIB.type [RC]");
    else
      {
        fail ("ATTRIB.type [RC] %c != %c", attrib->type, type); error++;
      }
  }
  {
    BITCODE_BS vert_alignment;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "vert_alignment", &vert_alignment, NULL) &&
        vert_alignment == attrib->vert_alignment)
      pass ("ATTRIB.vert_alignment [BS]");
    else
      {
        fail ("ATTRIB.vert_alignment [BS] %d != %d", attrib->vert_alignment, vert_alignment); error++;
      }
  }
  {
    BITCODE_RD width_factor;
    if (dwg_dynapi_entity_value(attrib, "ATTRIB", "width_factor", &width_factor, NULL) &&
        width_factor == attrib->width_factor)
      pass ("ATTRIB.width_factor [RD]");
    else
      {
        fail ("ATTRIB.width_factor [RD] " FORMAT_RD " != " FORMAT_RD "", attrib->width_factor, width_factor); error++;
      }
  }
  return error;
}
static int test_BLOCK (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_BLOCK *block = obj->tio.entity->tio.BLOCK;
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value(block, "BLOCK", "name", &name, NULL)
        && !strcmp((char*)&name, (char*)&block->name))
      pass ("BLOCK.name");
    else
      {
        fail ("BLOCK.name"); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(block, "BLOCK", "parent", &parent, NULL)
        && !memcmp(&parent, &block->parent, sizeof(block->parent)))
      pass ("BLOCK.parent");
    else
      {
        fail ("BLOCK.parent"); error++;
      }
  }
  return error;
}
static int test_CAMERA (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_CAMERA *camera = obj->tio.entity->tio.CAMERA;
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(camera, "CAMERA", "parent", &parent, NULL)
        && !memcmp(&parent, &camera->parent, sizeof(camera->parent)))
      pass ("CAMERA.parent");
    else
      {
        fail ("CAMERA.parent"); error++;
      }
  }
  {
    BITCODE_H view;
    if (dwg_dynapi_entity_value(camera, "CAMERA", "view", &view, NULL) &&
        view == camera->view)
      pass ("CAMERA.view [H]");
    else
      {
        fail ("CAMERA.view [H] %p != %p", camera->view, view); error++;
      }
  }
  return error;
}
static int test_CIRCLE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_CIRCLE *circle = obj->tio.entity->tio.CIRCLE;
  {
    BITCODE_3BD center;
    if (dwg_dynapi_entity_value(circle, "CIRCLE", "center", &center, NULL)
        && !memcmp(&center, &circle->center, sizeof(circle->center)))
      pass ("CIRCLE.center");
    else
      {
        fail ("CIRCLE.center"); error++;
      }
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value(circle, "CIRCLE", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &circle->extrusion, sizeof(circle->extrusion)))
      pass ("CIRCLE.extrusion");
    else
      {
        fail ("CIRCLE.extrusion"); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(circle, "CIRCLE", "parent", &parent, NULL)
        && !memcmp(&parent, &circle->parent, sizeof(circle->parent)))
      pass ("CIRCLE.parent");
    else
      {
        fail ("CIRCLE.parent"); error++;
      }
  }
  {
    BITCODE_BD radius;
    if (dwg_dynapi_entity_value(circle, "CIRCLE", "radius", &radius, NULL) &&
        radius == circle->radius)
      pass ("CIRCLE.radius [BD]");
    else
      {
        fail ("CIRCLE.radius [BD] %g != %g", circle->radius, radius); error++;
      }
  }
  {
    BITCODE_BT thickness;
    if (dwg_dynapi_entity_value(circle, "CIRCLE", "thickness", &thickness, NULL) &&
        thickness == circle->thickness)
      pass ("CIRCLE.thickness [BT]");
    else
      {
        fail ("CIRCLE.thickness [BT] " FORMAT_BT " != " FORMAT_BT "", circle->thickness, thickness); error++;
      }
  }
  return error;
}
static int test_DIMENSION_ALIGNED (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_DIMENSION_ALIGNED *dimension_aligned = obj->tio.entity->tio.DIMENSION_ALIGNED;
  {
    BITCODE_3BD _13_pt;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "_13_pt", &_13_pt, NULL)
        && !memcmp(&_13_pt, &dimension_aligned->_13_pt, sizeof(dimension_aligned->_13_pt)))
      pass ("DIMENSION_ALIGNED._13_pt");
    else
      {
        fail ("DIMENSION_ALIGNED._13_pt"); error++;
      }
  }
  {
    BITCODE_3BD _14_pt;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "_14_pt", &_14_pt, NULL)
        && !memcmp(&_14_pt, &dimension_aligned->_14_pt, sizeof(dimension_aligned->_14_pt)))
      pass ("DIMENSION_ALIGNED._14_pt");
    else
      {
        fail ("DIMENSION_ALIGNED._14_pt"); error++;
      }
  }
  {
    BITCODE_BD act_measurement;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "act_measurement", &act_measurement, NULL) &&
        act_measurement == dimension_aligned->act_measurement)
      pass ("DIMENSION_ALIGNED.act_measurement [BD]");
    else
      {
        fail ("DIMENSION_ALIGNED.act_measurement [BD] %g != %g", dimension_aligned->act_measurement, act_measurement); error++;
      }
  }
  {
    BITCODE_BS attachment;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "attachment", &attachment, NULL) &&
        attachment == dimension_aligned->attachment)
      pass ("DIMENSION_ALIGNED.attachment [BS]");
    else
      {
        fail ("DIMENSION_ALIGNED.attachment [BS] %d != %d", dimension_aligned->attachment, attachment); error++;
      }
  }
  {
    BITCODE_H block;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "block", &block, NULL) &&
        block == dimension_aligned->block)
      pass ("DIMENSION_ALIGNED.block [H]");
    else
      {
        fail ("DIMENSION_ALIGNED.block [H] %p != %p", dimension_aligned->block, block); error++;
      }
  }
  {
    BITCODE_TV blockname;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "blockname", &blockname, NULL)
        && !strcmp((char*)&blockname, (char*)&dimension_aligned->blockname))
      pass ("DIMENSION_ALIGNED.blockname");
    else
      {
        fail ("DIMENSION_ALIGNED.blockname"); error++;
      }
  }
  {
    BITCODE_RC class_version;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "class_version", &class_version, NULL) &&
        class_version == dimension_aligned->class_version)
      pass ("DIMENSION_ALIGNED.class_version [RC]");
    else
      {
        fail ("DIMENSION_ALIGNED.class_version [RC] %c != %c", dimension_aligned->class_version, class_version); error++;
      }
  }
  {
    Dwg_Bitcode_2RD clone_ins_pt;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "clone_ins_pt", &clone_ins_pt, NULL)
        && !memcmp(&clone_ins_pt, &dimension_aligned->clone_ins_pt, sizeof(dimension_aligned->clone_ins_pt)))
      pass ("DIMENSION_ALIGNED.clone_ins_pt");
    else
      {
        fail ("DIMENSION_ALIGNED.clone_ins_pt"); error++;
      }
  }
  {
    Dwg_Bitcode_3BD def_pt;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "def_pt", &def_pt, NULL)
        && !memcmp(&def_pt, &dimension_aligned->def_pt, sizeof(dimension_aligned->def_pt)))
      pass ("DIMENSION_ALIGNED.def_pt");
    else
      {
        fail ("DIMENSION_ALIGNED.def_pt"); error++;
      }
  }
  {
    BITCODE_H dimstyle;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "dimstyle", &dimstyle, NULL) &&
        dimstyle == dimension_aligned->dimstyle)
      pass ("DIMENSION_ALIGNED.dimstyle [H]");
    else
      {
        fail ("DIMENSION_ALIGNED.dimstyle [H] %p != %p", dimension_aligned->dimstyle, dimstyle); error++;
      }
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "elevation", &elevation, NULL) &&
        elevation == dimension_aligned->elevation)
      pass ("DIMENSION_ALIGNED.elevation [BD]");
    else
      {
        fail ("DIMENSION_ALIGNED.elevation [BD] %g != %g", dimension_aligned->elevation, elevation); error++;
      }
  }
  {
    BITCODE_BD ext_line_rotation;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "ext_line_rotation", &ext_line_rotation, NULL) &&
        ext_line_rotation == dimension_aligned->ext_line_rotation)
      pass ("DIMENSION_ALIGNED.ext_line_rotation [BD]");
    else
      {
        fail ("DIMENSION_ALIGNED.ext_line_rotation [BD] %g != %g", dimension_aligned->ext_line_rotation, ext_line_rotation); error++;
      }
  }
  {
    Dwg_Bitcode_3BD extrusion;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &dimension_aligned->extrusion, sizeof(dimension_aligned->extrusion)))
      pass ("DIMENSION_ALIGNED.extrusion");
    else
      {
        fail ("DIMENSION_ALIGNED.extrusion"); error++;
      }
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "flag", &flag, NULL) &&
        flag == dimension_aligned->flag)
      pass ("DIMENSION_ALIGNED.flag [RC]");
    else
      {
        fail ("DIMENSION_ALIGNED.flag [RC] %c != %c", dimension_aligned->flag, flag); error++;
      }
  }
  {
    BITCODE_RC flag1;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "flag1", &flag1, NULL) &&
        flag1 == dimension_aligned->flag1)
      pass ("DIMENSION_ALIGNED.flag1 [RC]");
    else
      {
        fail ("DIMENSION_ALIGNED.flag1 [RC] %c != %c", dimension_aligned->flag1, flag1); error++;
      }
  }
  {
    BITCODE_RC flip_arrow1;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "flip_arrow1", &flip_arrow1, NULL) &&
        flip_arrow1 == dimension_aligned->flip_arrow1)
      pass ("DIMENSION_ALIGNED.flip_arrow1 [RC]");
    else
      {
        fail ("DIMENSION_ALIGNED.flip_arrow1 [RC] %c != %c", dimension_aligned->flip_arrow1, flip_arrow1); error++;
      }
  }
  {
    BITCODE_RC flip_arrow2;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "flip_arrow2", &flip_arrow2, NULL) &&
        flip_arrow2 == dimension_aligned->flip_arrow2)
      pass ("DIMENSION_ALIGNED.flip_arrow2 [RC]");
    else
      {
        fail ("DIMENSION_ALIGNED.flip_arrow2 [RC] %c != %c", dimension_aligned->flip_arrow2, flip_arrow2); error++;
      }
  }
  {
    BITCODE_BD horiz_dir;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "horiz_dir", &horiz_dir, NULL) &&
        horiz_dir == dimension_aligned->horiz_dir)
      pass ("DIMENSION_ALIGNED.horiz_dir [BD]");
    else
      {
        fail ("DIMENSION_ALIGNED.horiz_dir [BD] %g != %g", dimension_aligned->horiz_dir, horiz_dir); error++;
      }
  }
  {
    BITCODE_BD ins_rotation;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "ins_rotation", &ins_rotation, NULL) &&
        ins_rotation == dimension_aligned->ins_rotation)
      pass ("DIMENSION_ALIGNED.ins_rotation [BD]");
    else
      {
        fail ("DIMENSION_ALIGNED.ins_rotation [BD] %g != %g", dimension_aligned->ins_rotation, ins_rotation); error++;
      }
  }
  {
    Dwg_Bitcode_3BD ins_scale;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "ins_scale", &ins_scale, NULL)
        && !memcmp(&ins_scale, &dimension_aligned->ins_scale, sizeof(dimension_aligned->ins_scale)))
      pass ("DIMENSION_ALIGNED.ins_scale");
    else
      {
        fail ("DIMENSION_ALIGNED.ins_scale"); error++;
      }
  }
  {
    BITCODE_BD lspace_factor;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "lspace_factor", &lspace_factor, NULL) &&
        lspace_factor == dimension_aligned->lspace_factor)
      pass ("DIMENSION_ALIGNED.lspace_factor [BD]");
    else
      {
        fail ("DIMENSION_ALIGNED.lspace_factor [BD] %g != %g", dimension_aligned->lspace_factor, lspace_factor); error++;
      }
  }
  {
    BITCODE_BS lspace_style;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "lspace_style", &lspace_style, NULL) &&
        lspace_style == dimension_aligned->lspace_style)
      pass ("DIMENSION_ALIGNED.lspace_style [BS]");
    else
      {
        fail ("DIMENSION_ALIGNED.lspace_style [BS] %d != %d", dimension_aligned->lspace_style, lspace_style); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "parent", &parent, NULL)
        && !memcmp(&parent, &dimension_aligned->parent, sizeof(dimension_aligned->parent)))
      pass ("DIMENSION_ALIGNED.parent");
    else
      {
        fail ("DIMENSION_ALIGNED.parent"); error++;
      }
  }
  {
    Dwg_Bitcode_2RD text_midpt;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "text_midpt", &text_midpt, NULL)
        && !memcmp(&text_midpt, &dimension_aligned->text_midpt, sizeof(dimension_aligned->text_midpt)))
      pass ("DIMENSION_ALIGNED.text_midpt");
    else
      {
        fail ("DIMENSION_ALIGNED.text_midpt"); error++;
      }
  }
  {
    BITCODE_BD text_rotation;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "text_rotation", &text_rotation, NULL) &&
        text_rotation == dimension_aligned->text_rotation)
      pass ("DIMENSION_ALIGNED.text_rotation [BD]");
    else
      {
        fail ("DIMENSION_ALIGNED.text_rotation [BD] %g != %g", dimension_aligned->text_rotation, text_rotation); error++;
      }
  }
  {
    BITCODE_RC unknown;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "unknown", &unknown, NULL) &&
        unknown == dimension_aligned->unknown)
      pass ("DIMENSION_ALIGNED.unknown [RC]");
    else
      {
        fail ("DIMENSION_ALIGNED.unknown [RC] %c != %c", dimension_aligned->unknown, unknown); error++;
      }
  }
  {
    BITCODE_TV user_text;
    if (dwg_dynapi_entity_value(dimension_aligned, "DIMENSION_ALIGNED", "user_text", &user_text, NULL)
        && !strcmp((char*)&user_text, (char*)&dimension_aligned->user_text))
      pass ("DIMENSION_ALIGNED.user_text");
    else
      {
        fail ("DIMENSION_ALIGNED.user_text"); error++;
      }
  }
  return error;
}
static int test_DIMENSION_ANG2LN (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_DIMENSION_ANG2LN *dimension_ang2ln = obj->tio.entity->tio.DIMENSION_ANG2LN;
  {
    BITCODE_3BD _13_pt;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "_13_pt", &_13_pt, NULL)
        && !memcmp(&_13_pt, &dimension_ang2ln->_13_pt, sizeof(dimension_ang2ln->_13_pt)))
      pass ("DIMENSION_ANG2LN._13_pt");
    else
      {
        fail ("DIMENSION_ANG2LN._13_pt"); error++;
      }
  }
  {
    BITCODE_3BD _14_pt;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "_14_pt", &_14_pt, NULL)
        && !memcmp(&_14_pt, &dimension_ang2ln->_14_pt, sizeof(dimension_ang2ln->_14_pt)))
      pass ("DIMENSION_ANG2LN._14_pt");
    else
      {
        fail ("DIMENSION_ANG2LN._14_pt"); error++;
      }
  }
  {
    BITCODE_2RD _16_pt;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "_16_pt", &_16_pt, NULL)
        && !memcmp(&_16_pt, &dimension_ang2ln->_16_pt, sizeof(dimension_ang2ln->_16_pt)))
      pass ("DIMENSION_ANG2LN._16_pt");
    else
      {
        fail ("DIMENSION_ANG2LN._16_pt"); error++;
      }
  }
  {
    BITCODE_BD act_measurement;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "act_measurement", &act_measurement, NULL) &&
        act_measurement == dimension_ang2ln->act_measurement)
      pass ("DIMENSION_ANG2LN.act_measurement [BD]");
    else
      {
        fail ("DIMENSION_ANG2LN.act_measurement [BD] %g != %g", dimension_ang2ln->act_measurement, act_measurement); error++;
      }
  }
  {
    BITCODE_BS attachment;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "attachment", &attachment, NULL) &&
        attachment == dimension_ang2ln->attachment)
      pass ("DIMENSION_ANG2LN.attachment [BS]");
    else
      {
        fail ("DIMENSION_ANG2LN.attachment [BS] %d != %d", dimension_ang2ln->attachment, attachment); error++;
      }
  }
  {
    BITCODE_H block;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "block", &block, NULL) &&
        block == dimension_ang2ln->block)
      pass ("DIMENSION_ANG2LN.block [H]");
    else
      {
        fail ("DIMENSION_ANG2LN.block [H] %p != %p", dimension_ang2ln->block, block); error++;
      }
  }
  {
    BITCODE_TV blockname;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "blockname", &blockname, NULL)
        && !strcmp((char*)&blockname, (char*)&dimension_ang2ln->blockname))
      pass ("DIMENSION_ANG2LN.blockname");
    else
      {
        fail ("DIMENSION_ANG2LN.blockname"); error++;
      }
  }
  {
    BITCODE_RC class_version;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "class_version", &class_version, NULL) &&
        class_version == dimension_ang2ln->class_version)
      pass ("DIMENSION_ANG2LN.class_version [RC]");
    else
      {
        fail ("DIMENSION_ANG2LN.class_version [RC] %c != %c", dimension_ang2ln->class_version, class_version); error++;
      }
  }
  {
    Dwg_Bitcode_2RD clone_ins_pt;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "clone_ins_pt", &clone_ins_pt, NULL)
        && !memcmp(&clone_ins_pt, &dimension_ang2ln->clone_ins_pt, sizeof(dimension_ang2ln->clone_ins_pt)))
      pass ("DIMENSION_ANG2LN.clone_ins_pt");
    else
      {
        fail ("DIMENSION_ANG2LN.clone_ins_pt"); error++;
      }
  }
  {
    Dwg_Bitcode_3BD def_pt;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "def_pt", &def_pt, NULL)
        && !memcmp(&def_pt, &dimension_ang2ln->def_pt, sizeof(dimension_ang2ln->def_pt)))
      pass ("DIMENSION_ANG2LN.def_pt");
    else
      {
        fail ("DIMENSION_ANG2LN.def_pt"); error++;
      }
  }
  {
    BITCODE_H dimstyle;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "dimstyle", &dimstyle, NULL) &&
        dimstyle == dimension_ang2ln->dimstyle)
      pass ("DIMENSION_ANG2LN.dimstyle [H]");
    else
      {
        fail ("DIMENSION_ANG2LN.dimstyle [H] %p != %p", dimension_ang2ln->dimstyle, dimstyle); error++;
      }
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "elevation", &elevation, NULL) &&
        elevation == dimension_ang2ln->elevation)
      pass ("DIMENSION_ANG2LN.elevation [BD]");
    else
      {
        fail ("DIMENSION_ANG2LN.elevation [BD] %g != %g", dimension_ang2ln->elevation, elevation); error++;
      }
  }
  {
    Dwg_Bitcode_3BD extrusion;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &dimension_ang2ln->extrusion, sizeof(dimension_ang2ln->extrusion)))
      pass ("DIMENSION_ANG2LN.extrusion");
    else
      {
        fail ("DIMENSION_ANG2LN.extrusion"); error++;
      }
  }
  {
    BITCODE_3BD first_arc_pt;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "first_arc_pt", &first_arc_pt, NULL)
        && !memcmp(&first_arc_pt, &dimension_ang2ln->first_arc_pt, sizeof(dimension_ang2ln->first_arc_pt)))
      pass ("DIMENSION_ANG2LN.first_arc_pt");
    else
      {
        fail ("DIMENSION_ANG2LN.first_arc_pt"); error++;
      }
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "flag", &flag, NULL) &&
        flag == dimension_ang2ln->flag)
      pass ("DIMENSION_ANG2LN.flag [RC]");
    else
      {
        fail ("DIMENSION_ANG2LN.flag [RC] %c != %c", dimension_ang2ln->flag, flag); error++;
      }
  }
  {
    BITCODE_RC flag1;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "flag1", &flag1, NULL) &&
        flag1 == dimension_ang2ln->flag1)
      pass ("DIMENSION_ANG2LN.flag1 [RC]");
    else
      {
        fail ("DIMENSION_ANG2LN.flag1 [RC] %c != %c", dimension_ang2ln->flag1, flag1); error++;
      }
  }
  {
    BITCODE_RC flip_arrow1;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "flip_arrow1", &flip_arrow1, NULL) &&
        flip_arrow1 == dimension_ang2ln->flip_arrow1)
      pass ("DIMENSION_ANG2LN.flip_arrow1 [RC]");
    else
      {
        fail ("DIMENSION_ANG2LN.flip_arrow1 [RC] %c != %c", dimension_ang2ln->flip_arrow1, flip_arrow1); error++;
      }
  }
  {
    BITCODE_RC flip_arrow2;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "flip_arrow2", &flip_arrow2, NULL) &&
        flip_arrow2 == dimension_ang2ln->flip_arrow2)
      pass ("DIMENSION_ANG2LN.flip_arrow2 [RC]");
    else
      {
        fail ("DIMENSION_ANG2LN.flip_arrow2 [RC] %c != %c", dimension_ang2ln->flip_arrow2, flip_arrow2); error++;
      }
  }
  {
    BITCODE_BD horiz_dir;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "horiz_dir", &horiz_dir, NULL) &&
        horiz_dir == dimension_ang2ln->horiz_dir)
      pass ("DIMENSION_ANG2LN.horiz_dir [BD]");
    else
      {
        fail ("DIMENSION_ANG2LN.horiz_dir [BD] %g != %g", dimension_ang2ln->horiz_dir, horiz_dir); error++;
      }
  }
  {
    BITCODE_BD ins_rotation;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "ins_rotation", &ins_rotation, NULL) &&
        ins_rotation == dimension_ang2ln->ins_rotation)
      pass ("DIMENSION_ANG2LN.ins_rotation [BD]");
    else
      {
        fail ("DIMENSION_ANG2LN.ins_rotation [BD] %g != %g", dimension_ang2ln->ins_rotation, ins_rotation); error++;
      }
  }
  {
    Dwg_Bitcode_3BD ins_scale;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "ins_scale", &ins_scale, NULL)
        && !memcmp(&ins_scale, &dimension_ang2ln->ins_scale, sizeof(dimension_ang2ln->ins_scale)))
      pass ("DIMENSION_ANG2LN.ins_scale");
    else
      {
        fail ("DIMENSION_ANG2LN.ins_scale"); error++;
      }
  }
  {
    BITCODE_BD lspace_factor;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "lspace_factor", &lspace_factor, NULL) &&
        lspace_factor == dimension_ang2ln->lspace_factor)
      pass ("DIMENSION_ANG2LN.lspace_factor [BD]");
    else
      {
        fail ("DIMENSION_ANG2LN.lspace_factor [BD] %g != %g", dimension_ang2ln->lspace_factor, lspace_factor); error++;
      }
  }
  {
    BITCODE_BS lspace_style;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "lspace_style", &lspace_style, NULL) &&
        lspace_style == dimension_ang2ln->lspace_style)
      pass ("DIMENSION_ANG2LN.lspace_style [BS]");
    else
      {
        fail ("DIMENSION_ANG2LN.lspace_style [BS] %d != %d", dimension_ang2ln->lspace_style, lspace_style); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "parent", &parent, NULL)
        && !memcmp(&parent, &dimension_ang2ln->parent, sizeof(dimension_ang2ln->parent)))
      pass ("DIMENSION_ANG2LN.parent");
    else
      {
        fail ("DIMENSION_ANG2LN.parent"); error++;
      }
  }
  {
    Dwg_Bitcode_2RD text_midpt;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "text_midpt", &text_midpt, NULL)
        && !memcmp(&text_midpt, &dimension_ang2ln->text_midpt, sizeof(dimension_ang2ln->text_midpt)))
      pass ("DIMENSION_ANG2LN.text_midpt");
    else
      {
        fail ("DIMENSION_ANG2LN.text_midpt"); error++;
      }
  }
  {
    BITCODE_BD text_rotation;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "text_rotation", &text_rotation, NULL) &&
        text_rotation == dimension_ang2ln->text_rotation)
      pass ("DIMENSION_ANG2LN.text_rotation [BD]");
    else
      {
        fail ("DIMENSION_ANG2LN.text_rotation [BD] %g != %g", dimension_ang2ln->text_rotation, text_rotation); error++;
      }
  }
  {
    BITCODE_RC unknown;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "unknown", &unknown, NULL) &&
        unknown == dimension_ang2ln->unknown)
      pass ("DIMENSION_ANG2LN.unknown [RC]");
    else
      {
        fail ("DIMENSION_ANG2LN.unknown [RC] %c != %c", dimension_ang2ln->unknown, unknown); error++;
      }
  }
  {
    BITCODE_TV user_text;
    if (dwg_dynapi_entity_value(dimension_ang2ln, "DIMENSION_ANG2LN", "user_text", &user_text, NULL)
        && !strcmp((char*)&user_text, (char*)&dimension_ang2ln->user_text))
      pass ("DIMENSION_ANG2LN.user_text");
    else
      {
        fail ("DIMENSION_ANG2LN.user_text"); error++;
      }
  }
  return error;
}
static int test_DIMENSION_ANG3PT (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_DIMENSION_ANG3PT *dimension_ang3pt = obj->tio.entity->tio.DIMENSION_ANG3PT;
  {
    BITCODE_3BD _13_pt;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "_13_pt", &_13_pt, NULL)
        && !memcmp(&_13_pt, &dimension_ang3pt->_13_pt, sizeof(dimension_ang3pt->_13_pt)))
      pass ("DIMENSION_ANG3PT._13_pt");
    else
      {
        fail ("DIMENSION_ANG3PT._13_pt"); error++;
      }
  }
  {
    BITCODE_3BD _14_pt;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "_14_pt", &_14_pt, NULL)
        && !memcmp(&_14_pt, &dimension_ang3pt->_14_pt, sizeof(dimension_ang3pt->_14_pt)))
      pass ("DIMENSION_ANG3PT._14_pt");
    else
      {
        fail ("DIMENSION_ANG3PT._14_pt"); error++;
      }
  }
  {
    BITCODE_BD act_measurement;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "act_measurement", &act_measurement, NULL) &&
        act_measurement == dimension_ang3pt->act_measurement)
      pass ("DIMENSION_ANG3PT.act_measurement [BD]");
    else
      {
        fail ("DIMENSION_ANG3PT.act_measurement [BD] %g != %g", dimension_ang3pt->act_measurement, act_measurement); error++;
      }
  }
  {
    BITCODE_BS attachment;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "attachment", &attachment, NULL) &&
        attachment == dimension_ang3pt->attachment)
      pass ("DIMENSION_ANG3PT.attachment [BS]");
    else
      {
        fail ("DIMENSION_ANG3PT.attachment [BS] %d != %d", dimension_ang3pt->attachment, attachment); error++;
      }
  }
  {
    BITCODE_H block;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "block", &block, NULL) &&
        block == dimension_ang3pt->block)
      pass ("DIMENSION_ANG3PT.block [H]");
    else
      {
        fail ("DIMENSION_ANG3PT.block [H] %p != %p", dimension_ang3pt->block, block); error++;
      }
  }
  {
    BITCODE_TV blockname;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "blockname", &blockname, NULL)
        && !strcmp((char*)&blockname, (char*)&dimension_ang3pt->blockname))
      pass ("DIMENSION_ANG3PT.blockname");
    else
      {
        fail ("DIMENSION_ANG3PT.blockname"); error++;
      }
  }
  {
    BITCODE_RC class_version;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "class_version", &class_version, NULL) &&
        class_version == dimension_ang3pt->class_version)
      pass ("DIMENSION_ANG3PT.class_version [RC]");
    else
      {
        fail ("DIMENSION_ANG3PT.class_version [RC] %c != %c", dimension_ang3pt->class_version, class_version); error++;
      }
  }
  {
    Dwg_Bitcode_2RD clone_ins_pt;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "clone_ins_pt", &clone_ins_pt, NULL)
        && !memcmp(&clone_ins_pt, &dimension_ang3pt->clone_ins_pt, sizeof(dimension_ang3pt->clone_ins_pt)))
      pass ("DIMENSION_ANG3PT.clone_ins_pt");
    else
      {
        fail ("DIMENSION_ANG3PT.clone_ins_pt"); error++;
      }
  }
  {
    Dwg_Bitcode_3BD def_pt;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "def_pt", &def_pt, NULL)
        && !memcmp(&def_pt, &dimension_ang3pt->def_pt, sizeof(dimension_ang3pt->def_pt)))
      pass ("DIMENSION_ANG3PT.def_pt");
    else
      {
        fail ("DIMENSION_ANG3PT.def_pt"); error++;
      }
  }
  {
    BITCODE_H dimstyle;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "dimstyle", &dimstyle, NULL) &&
        dimstyle == dimension_ang3pt->dimstyle)
      pass ("DIMENSION_ANG3PT.dimstyle [H]");
    else
      {
        fail ("DIMENSION_ANG3PT.dimstyle [H] %p != %p", dimension_ang3pt->dimstyle, dimstyle); error++;
      }
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "elevation", &elevation, NULL) &&
        elevation == dimension_ang3pt->elevation)
      pass ("DIMENSION_ANG3PT.elevation [BD]");
    else
      {
        fail ("DIMENSION_ANG3PT.elevation [BD] %g != %g", dimension_ang3pt->elevation, elevation); error++;
      }
  }
  {
    Dwg_Bitcode_3BD extrusion;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &dimension_ang3pt->extrusion, sizeof(dimension_ang3pt->extrusion)))
      pass ("DIMENSION_ANG3PT.extrusion");
    else
      {
        fail ("DIMENSION_ANG3PT.extrusion"); error++;
      }
  }
  {
    BITCODE_3BD first_arc_pt;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "first_arc_pt", &first_arc_pt, NULL)
        && !memcmp(&first_arc_pt, &dimension_ang3pt->first_arc_pt, sizeof(dimension_ang3pt->first_arc_pt)))
      pass ("DIMENSION_ANG3PT.first_arc_pt");
    else
      {
        fail ("DIMENSION_ANG3PT.first_arc_pt"); error++;
      }
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "flag", &flag, NULL) &&
        flag == dimension_ang3pt->flag)
      pass ("DIMENSION_ANG3PT.flag [RC]");
    else
      {
        fail ("DIMENSION_ANG3PT.flag [RC] %c != %c", dimension_ang3pt->flag, flag); error++;
      }
  }
  {
    BITCODE_RC flag1;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "flag1", &flag1, NULL) &&
        flag1 == dimension_ang3pt->flag1)
      pass ("DIMENSION_ANG3PT.flag1 [RC]");
    else
      {
        fail ("DIMENSION_ANG3PT.flag1 [RC] %c != %c", dimension_ang3pt->flag1, flag1); error++;
      }
  }
  {
    BITCODE_RC flip_arrow1;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "flip_arrow1", &flip_arrow1, NULL) &&
        flip_arrow1 == dimension_ang3pt->flip_arrow1)
      pass ("DIMENSION_ANG3PT.flip_arrow1 [RC]");
    else
      {
        fail ("DIMENSION_ANG3PT.flip_arrow1 [RC] %c != %c", dimension_ang3pt->flip_arrow1, flip_arrow1); error++;
      }
  }
  {
    BITCODE_RC flip_arrow2;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "flip_arrow2", &flip_arrow2, NULL) &&
        flip_arrow2 == dimension_ang3pt->flip_arrow2)
      pass ("DIMENSION_ANG3PT.flip_arrow2 [RC]");
    else
      {
        fail ("DIMENSION_ANG3PT.flip_arrow2 [RC] %c != %c", dimension_ang3pt->flip_arrow2, flip_arrow2); error++;
      }
  }
  {
    BITCODE_BD horiz_dir;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "horiz_dir", &horiz_dir, NULL) &&
        horiz_dir == dimension_ang3pt->horiz_dir)
      pass ("DIMENSION_ANG3PT.horiz_dir [BD]");
    else
      {
        fail ("DIMENSION_ANG3PT.horiz_dir [BD] %g != %g", dimension_ang3pt->horiz_dir, horiz_dir); error++;
      }
  }
  {
    BITCODE_BD ins_rotation;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "ins_rotation", &ins_rotation, NULL) &&
        ins_rotation == dimension_ang3pt->ins_rotation)
      pass ("DIMENSION_ANG3PT.ins_rotation [BD]");
    else
      {
        fail ("DIMENSION_ANG3PT.ins_rotation [BD] %g != %g", dimension_ang3pt->ins_rotation, ins_rotation); error++;
      }
  }
  {
    Dwg_Bitcode_3BD ins_scale;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "ins_scale", &ins_scale, NULL)
        && !memcmp(&ins_scale, &dimension_ang3pt->ins_scale, sizeof(dimension_ang3pt->ins_scale)))
      pass ("DIMENSION_ANG3PT.ins_scale");
    else
      {
        fail ("DIMENSION_ANG3PT.ins_scale"); error++;
      }
  }
  {
    BITCODE_BD lspace_factor;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "lspace_factor", &lspace_factor, NULL) &&
        lspace_factor == dimension_ang3pt->lspace_factor)
      pass ("DIMENSION_ANG3PT.lspace_factor [BD]");
    else
      {
        fail ("DIMENSION_ANG3PT.lspace_factor [BD] %g != %g", dimension_ang3pt->lspace_factor, lspace_factor); error++;
      }
  }
  {
    BITCODE_BS lspace_style;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "lspace_style", &lspace_style, NULL) &&
        lspace_style == dimension_ang3pt->lspace_style)
      pass ("DIMENSION_ANG3PT.lspace_style [BS]");
    else
      {
        fail ("DIMENSION_ANG3PT.lspace_style [BS] %d != %d", dimension_ang3pt->lspace_style, lspace_style); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "parent", &parent, NULL)
        && !memcmp(&parent, &dimension_ang3pt->parent, sizeof(dimension_ang3pt->parent)))
      pass ("DIMENSION_ANG3PT.parent");
    else
      {
        fail ("DIMENSION_ANG3PT.parent"); error++;
      }
  }
  {
    Dwg_Bitcode_2RD text_midpt;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "text_midpt", &text_midpt, NULL)
        && !memcmp(&text_midpt, &dimension_ang3pt->text_midpt, sizeof(dimension_ang3pt->text_midpt)))
      pass ("DIMENSION_ANG3PT.text_midpt");
    else
      {
        fail ("DIMENSION_ANG3PT.text_midpt"); error++;
      }
  }
  {
    BITCODE_BD text_rotation;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "text_rotation", &text_rotation, NULL) &&
        text_rotation == dimension_ang3pt->text_rotation)
      pass ("DIMENSION_ANG3PT.text_rotation [BD]");
    else
      {
        fail ("DIMENSION_ANG3PT.text_rotation [BD] %g != %g", dimension_ang3pt->text_rotation, text_rotation); error++;
      }
  }
  {
    BITCODE_RC unknown;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "unknown", &unknown, NULL) &&
        unknown == dimension_ang3pt->unknown)
      pass ("DIMENSION_ANG3PT.unknown [RC]");
    else
      {
        fail ("DIMENSION_ANG3PT.unknown [RC] %c != %c", dimension_ang3pt->unknown, unknown); error++;
      }
  }
  {
    BITCODE_TV user_text;
    if (dwg_dynapi_entity_value(dimension_ang3pt, "DIMENSION_ANG3PT", "user_text", &user_text, NULL)
        && !strcmp((char*)&user_text, (char*)&dimension_ang3pt->user_text))
      pass ("DIMENSION_ANG3PT.user_text");
    else
      {
        fail ("DIMENSION_ANG3PT.user_text"); error++;
      }
  }
  return error;
}
static int test_DIMENSION_DIAMETER (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_DIMENSION_DIAMETER *dimension_diameter = obj->tio.entity->tio.DIMENSION_DIAMETER;
  {
    BITCODE_BD act_measurement;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "act_measurement", &act_measurement, NULL) &&
        act_measurement == dimension_diameter->act_measurement)
      pass ("DIMENSION_DIAMETER.act_measurement [BD]");
    else
      {
        fail ("DIMENSION_DIAMETER.act_measurement [BD] %g != %g", dimension_diameter->act_measurement, act_measurement); error++;
      }
  }
  {
    BITCODE_BS attachment;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "attachment", &attachment, NULL) &&
        attachment == dimension_diameter->attachment)
      pass ("DIMENSION_DIAMETER.attachment [BS]");
    else
      {
        fail ("DIMENSION_DIAMETER.attachment [BS] %d != %d", dimension_diameter->attachment, attachment); error++;
      }
  }
  {
    BITCODE_H block;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "block", &block, NULL) &&
        block == dimension_diameter->block)
      pass ("DIMENSION_DIAMETER.block [H]");
    else
      {
        fail ("DIMENSION_DIAMETER.block [H] %p != %p", dimension_diameter->block, block); error++;
      }
  }
  {
    BITCODE_TV blockname;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "blockname", &blockname, NULL)
        && !strcmp((char*)&blockname, (char*)&dimension_diameter->blockname))
      pass ("DIMENSION_DIAMETER.blockname");
    else
      {
        fail ("DIMENSION_DIAMETER.blockname"); error++;
      }
  }
  {
    BITCODE_RC class_version;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "class_version", &class_version, NULL) &&
        class_version == dimension_diameter->class_version)
      pass ("DIMENSION_DIAMETER.class_version [RC]");
    else
      {
        fail ("DIMENSION_DIAMETER.class_version [RC] %c != %c", dimension_diameter->class_version, class_version); error++;
      }
  }
  {
    Dwg_Bitcode_2RD clone_ins_pt;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "clone_ins_pt", &clone_ins_pt, NULL)
        && !memcmp(&clone_ins_pt, &dimension_diameter->clone_ins_pt, sizeof(dimension_diameter->clone_ins_pt)))
      pass ("DIMENSION_DIAMETER.clone_ins_pt");
    else
      {
        fail ("DIMENSION_DIAMETER.clone_ins_pt"); error++;
      }
  }
  {
    Dwg_Bitcode_3BD def_pt;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "def_pt", &def_pt, NULL)
        && !memcmp(&def_pt, &dimension_diameter->def_pt, sizeof(dimension_diameter->def_pt)))
      pass ("DIMENSION_DIAMETER.def_pt");
    else
      {
        fail ("DIMENSION_DIAMETER.def_pt"); error++;
      }
  }
  {
    BITCODE_H dimstyle;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "dimstyle", &dimstyle, NULL) &&
        dimstyle == dimension_diameter->dimstyle)
      pass ("DIMENSION_DIAMETER.dimstyle [H]");
    else
      {
        fail ("DIMENSION_DIAMETER.dimstyle [H] %p != %p", dimension_diameter->dimstyle, dimstyle); error++;
      }
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "elevation", &elevation, NULL) &&
        elevation == dimension_diameter->elevation)
      pass ("DIMENSION_DIAMETER.elevation [BD]");
    else
      {
        fail ("DIMENSION_DIAMETER.elevation [BD] %g != %g", dimension_diameter->elevation, elevation); error++;
      }
  }
  {
    Dwg_Bitcode_3BD extrusion;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &dimension_diameter->extrusion, sizeof(dimension_diameter->extrusion)))
      pass ("DIMENSION_DIAMETER.extrusion");
    else
      {
        fail ("DIMENSION_DIAMETER.extrusion"); error++;
      }
  }
  {
    BITCODE_3BD first_arc_pt;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "first_arc_pt", &first_arc_pt, NULL)
        && !memcmp(&first_arc_pt, &dimension_diameter->first_arc_pt, sizeof(dimension_diameter->first_arc_pt)))
      pass ("DIMENSION_DIAMETER.first_arc_pt");
    else
      {
        fail ("DIMENSION_DIAMETER.first_arc_pt"); error++;
      }
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "flag", &flag, NULL) &&
        flag == dimension_diameter->flag)
      pass ("DIMENSION_DIAMETER.flag [RC]");
    else
      {
        fail ("DIMENSION_DIAMETER.flag [RC] %c != %c", dimension_diameter->flag, flag); error++;
      }
  }
  {
    BITCODE_RC flag1;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "flag1", &flag1, NULL) &&
        flag1 == dimension_diameter->flag1)
      pass ("DIMENSION_DIAMETER.flag1 [RC]");
    else
      {
        fail ("DIMENSION_DIAMETER.flag1 [RC] %c != %c", dimension_diameter->flag1, flag1); error++;
      }
  }
  {
    BITCODE_RC flip_arrow1;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "flip_arrow1", &flip_arrow1, NULL) &&
        flip_arrow1 == dimension_diameter->flip_arrow1)
      pass ("DIMENSION_DIAMETER.flip_arrow1 [RC]");
    else
      {
        fail ("DIMENSION_DIAMETER.flip_arrow1 [RC] %c != %c", dimension_diameter->flip_arrow1, flip_arrow1); error++;
      }
  }
  {
    BITCODE_RC flip_arrow2;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "flip_arrow2", &flip_arrow2, NULL) &&
        flip_arrow2 == dimension_diameter->flip_arrow2)
      pass ("DIMENSION_DIAMETER.flip_arrow2 [RC]");
    else
      {
        fail ("DIMENSION_DIAMETER.flip_arrow2 [RC] %c != %c", dimension_diameter->flip_arrow2, flip_arrow2); error++;
      }
  }
  {
    BITCODE_BD horiz_dir;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "horiz_dir", &horiz_dir, NULL) &&
        horiz_dir == dimension_diameter->horiz_dir)
      pass ("DIMENSION_DIAMETER.horiz_dir [BD]");
    else
      {
        fail ("DIMENSION_DIAMETER.horiz_dir [BD] %g != %g", dimension_diameter->horiz_dir, horiz_dir); error++;
      }
  }
  {
    BITCODE_BD ins_rotation;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "ins_rotation", &ins_rotation, NULL) &&
        ins_rotation == dimension_diameter->ins_rotation)
      pass ("DIMENSION_DIAMETER.ins_rotation [BD]");
    else
      {
        fail ("DIMENSION_DIAMETER.ins_rotation [BD] %g != %g", dimension_diameter->ins_rotation, ins_rotation); error++;
      }
  }
  {
    Dwg_Bitcode_3BD ins_scale;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "ins_scale", &ins_scale, NULL)
        && !memcmp(&ins_scale, &dimension_diameter->ins_scale, sizeof(dimension_diameter->ins_scale)))
      pass ("DIMENSION_DIAMETER.ins_scale");
    else
      {
        fail ("DIMENSION_DIAMETER.ins_scale"); error++;
      }
  }
  {
    BITCODE_BD leader_len;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "leader_len", &leader_len, NULL) &&
        leader_len == dimension_diameter->leader_len)
      pass ("DIMENSION_DIAMETER.leader_len [BD]");
    else
      {
        fail ("DIMENSION_DIAMETER.leader_len [BD] %g != %g", dimension_diameter->leader_len, leader_len); error++;
      }
  }
  {
    BITCODE_BD lspace_factor;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "lspace_factor", &lspace_factor, NULL) &&
        lspace_factor == dimension_diameter->lspace_factor)
      pass ("DIMENSION_DIAMETER.lspace_factor [BD]");
    else
      {
        fail ("DIMENSION_DIAMETER.lspace_factor [BD] %g != %g", dimension_diameter->lspace_factor, lspace_factor); error++;
      }
  }
  {
    BITCODE_BS lspace_style;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "lspace_style", &lspace_style, NULL) &&
        lspace_style == dimension_diameter->lspace_style)
      pass ("DIMENSION_DIAMETER.lspace_style [BS]");
    else
      {
        fail ("DIMENSION_DIAMETER.lspace_style [BS] %d != %d", dimension_diameter->lspace_style, lspace_style); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "parent", &parent, NULL)
        && !memcmp(&parent, &dimension_diameter->parent, sizeof(dimension_diameter->parent)))
      pass ("DIMENSION_DIAMETER.parent");
    else
      {
        fail ("DIMENSION_DIAMETER.parent"); error++;
      }
  }
  {
    Dwg_Bitcode_2RD text_midpt;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "text_midpt", &text_midpt, NULL)
        && !memcmp(&text_midpt, &dimension_diameter->text_midpt, sizeof(dimension_diameter->text_midpt)))
      pass ("DIMENSION_DIAMETER.text_midpt");
    else
      {
        fail ("DIMENSION_DIAMETER.text_midpt"); error++;
      }
  }
  {
    BITCODE_BD text_rotation;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "text_rotation", &text_rotation, NULL) &&
        text_rotation == dimension_diameter->text_rotation)
      pass ("DIMENSION_DIAMETER.text_rotation [BD]");
    else
      {
        fail ("DIMENSION_DIAMETER.text_rotation [BD] %g != %g", dimension_diameter->text_rotation, text_rotation); error++;
      }
  }
  {
    BITCODE_RC unknown;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "unknown", &unknown, NULL) &&
        unknown == dimension_diameter->unknown)
      pass ("DIMENSION_DIAMETER.unknown [RC]");
    else
      {
        fail ("DIMENSION_DIAMETER.unknown [RC] %c != %c", dimension_diameter->unknown, unknown); error++;
      }
  }
  {
    BITCODE_TV user_text;
    if (dwg_dynapi_entity_value(dimension_diameter, "DIMENSION_DIAMETER", "user_text", &user_text, NULL)
        && !strcmp((char*)&user_text, (char*)&dimension_diameter->user_text))
      pass ("DIMENSION_DIAMETER.user_text");
    else
      {
        fail ("DIMENSION_DIAMETER.user_text"); error++;
      }
  }
  return error;
}
static int test_DIMENSION_LINEAR (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_DIMENSION_LINEAR *dimension_linear = obj->tio.entity->tio.DIMENSION_LINEAR;
  {
    BITCODE_3BD _13_pt;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "_13_pt", &_13_pt, NULL)
        && !memcmp(&_13_pt, &dimension_linear->_13_pt, sizeof(dimension_linear->_13_pt)))
      pass ("DIMENSION_LINEAR._13_pt");
    else
      {
        fail ("DIMENSION_LINEAR._13_pt"); error++;
      }
  }
  {
    BITCODE_3BD _14_pt;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "_14_pt", &_14_pt, NULL)
        && !memcmp(&_14_pt, &dimension_linear->_14_pt, sizeof(dimension_linear->_14_pt)))
      pass ("DIMENSION_LINEAR._14_pt");
    else
      {
        fail ("DIMENSION_LINEAR._14_pt"); error++;
      }
  }
  {
    BITCODE_BD act_measurement;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "act_measurement", &act_measurement, NULL) &&
        act_measurement == dimension_linear->act_measurement)
      pass ("DIMENSION_LINEAR.act_measurement [BD]");
    else
      {
        fail ("DIMENSION_LINEAR.act_measurement [BD] %g != %g", dimension_linear->act_measurement, act_measurement); error++;
      }
  }
  {
    BITCODE_BS attachment;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "attachment", &attachment, NULL) &&
        attachment == dimension_linear->attachment)
      pass ("DIMENSION_LINEAR.attachment [BS]");
    else
      {
        fail ("DIMENSION_LINEAR.attachment [BS] %d != %d", dimension_linear->attachment, attachment); error++;
      }
  }
  {
    BITCODE_H block;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "block", &block, NULL) &&
        block == dimension_linear->block)
      pass ("DIMENSION_LINEAR.block [H]");
    else
      {
        fail ("DIMENSION_LINEAR.block [H] %p != %p", dimension_linear->block, block); error++;
      }
  }
  {
    BITCODE_TV blockname;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "blockname", &blockname, NULL)
        && !strcmp((char*)&blockname, (char*)&dimension_linear->blockname))
      pass ("DIMENSION_LINEAR.blockname");
    else
      {
        fail ("DIMENSION_LINEAR.blockname"); error++;
      }
  }
  {
    BITCODE_RC class_version;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "class_version", &class_version, NULL) &&
        class_version == dimension_linear->class_version)
      pass ("DIMENSION_LINEAR.class_version [RC]");
    else
      {
        fail ("DIMENSION_LINEAR.class_version [RC] %c != %c", dimension_linear->class_version, class_version); error++;
      }
  }
  {
    Dwg_Bitcode_2RD clone_ins_pt;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "clone_ins_pt", &clone_ins_pt, NULL)
        && !memcmp(&clone_ins_pt, &dimension_linear->clone_ins_pt, sizeof(dimension_linear->clone_ins_pt)))
      pass ("DIMENSION_LINEAR.clone_ins_pt");
    else
      {
        fail ("DIMENSION_LINEAR.clone_ins_pt"); error++;
      }
  }
  {
    Dwg_Bitcode_3BD def_pt;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "def_pt", &def_pt, NULL)
        && !memcmp(&def_pt, &dimension_linear->def_pt, sizeof(dimension_linear->def_pt)))
      pass ("DIMENSION_LINEAR.def_pt");
    else
      {
        fail ("DIMENSION_LINEAR.def_pt"); error++;
      }
  }
  {
    BITCODE_BD dim_rotation;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "dim_rotation", &dim_rotation, NULL) &&
        dim_rotation == dimension_linear->dim_rotation)
      pass ("DIMENSION_LINEAR.dim_rotation [BD]");
    else
      {
        fail ("DIMENSION_LINEAR.dim_rotation [BD] %g != %g", dimension_linear->dim_rotation, dim_rotation); error++;
      }
  }
  {
    BITCODE_H dimstyle;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "dimstyle", &dimstyle, NULL) &&
        dimstyle == dimension_linear->dimstyle)
      pass ("DIMENSION_LINEAR.dimstyle [H]");
    else
      {
        fail ("DIMENSION_LINEAR.dimstyle [H] %p != %p", dimension_linear->dimstyle, dimstyle); error++;
      }
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "elevation", &elevation, NULL) &&
        elevation == dimension_linear->elevation)
      pass ("DIMENSION_LINEAR.elevation [BD]");
    else
      {
        fail ("DIMENSION_LINEAR.elevation [BD] %g != %g", dimension_linear->elevation, elevation); error++;
      }
  }
  {
    BITCODE_BD ext_line_rotation;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "ext_line_rotation", &ext_line_rotation, NULL) &&
        ext_line_rotation == dimension_linear->ext_line_rotation)
      pass ("DIMENSION_LINEAR.ext_line_rotation [BD]");
    else
      {
        fail ("DIMENSION_LINEAR.ext_line_rotation [BD] %g != %g", dimension_linear->ext_line_rotation, ext_line_rotation); error++;
      }
  }
  {
    Dwg_Bitcode_3BD extrusion;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &dimension_linear->extrusion, sizeof(dimension_linear->extrusion)))
      pass ("DIMENSION_LINEAR.extrusion");
    else
      {
        fail ("DIMENSION_LINEAR.extrusion"); error++;
      }
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "flag", &flag, NULL) &&
        flag == dimension_linear->flag)
      pass ("DIMENSION_LINEAR.flag [RC]");
    else
      {
        fail ("DIMENSION_LINEAR.flag [RC] %c != %c", dimension_linear->flag, flag); error++;
      }
  }
  {
    BITCODE_RC flag1;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "flag1", &flag1, NULL) &&
        flag1 == dimension_linear->flag1)
      pass ("DIMENSION_LINEAR.flag1 [RC]");
    else
      {
        fail ("DIMENSION_LINEAR.flag1 [RC] %c != %c", dimension_linear->flag1, flag1); error++;
      }
  }
  {
    BITCODE_RC flip_arrow1;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "flip_arrow1", &flip_arrow1, NULL) &&
        flip_arrow1 == dimension_linear->flip_arrow1)
      pass ("DIMENSION_LINEAR.flip_arrow1 [RC]");
    else
      {
        fail ("DIMENSION_LINEAR.flip_arrow1 [RC] %c != %c", dimension_linear->flip_arrow1, flip_arrow1); error++;
      }
  }
  {
    BITCODE_RC flip_arrow2;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "flip_arrow2", &flip_arrow2, NULL) &&
        flip_arrow2 == dimension_linear->flip_arrow2)
      pass ("DIMENSION_LINEAR.flip_arrow2 [RC]");
    else
      {
        fail ("DIMENSION_LINEAR.flip_arrow2 [RC] %c != %c", dimension_linear->flip_arrow2, flip_arrow2); error++;
      }
  }
  {
    BITCODE_BD horiz_dir;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "horiz_dir", &horiz_dir, NULL) &&
        horiz_dir == dimension_linear->horiz_dir)
      pass ("DIMENSION_LINEAR.horiz_dir [BD]");
    else
      {
        fail ("DIMENSION_LINEAR.horiz_dir [BD] %g != %g", dimension_linear->horiz_dir, horiz_dir); error++;
      }
  }
  {
    BITCODE_BD ins_rotation;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "ins_rotation", &ins_rotation, NULL) &&
        ins_rotation == dimension_linear->ins_rotation)
      pass ("DIMENSION_LINEAR.ins_rotation [BD]");
    else
      {
        fail ("DIMENSION_LINEAR.ins_rotation [BD] %g != %g", dimension_linear->ins_rotation, ins_rotation); error++;
      }
  }
  {
    Dwg_Bitcode_3BD ins_scale;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "ins_scale", &ins_scale, NULL)
        && !memcmp(&ins_scale, &dimension_linear->ins_scale, sizeof(dimension_linear->ins_scale)))
      pass ("DIMENSION_LINEAR.ins_scale");
    else
      {
        fail ("DIMENSION_LINEAR.ins_scale"); error++;
      }
  }
  {
    BITCODE_BD lspace_factor;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "lspace_factor", &lspace_factor, NULL) &&
        lspace_factor == dimension_linear->lspace_factor)
      pass ("DIMENSION_LINEAR.lspace_factor [BD]");
    else
      {
        fail ("DIMENSION_LINEAR.lspace_factor [BD] %g != %g", dimension_linear->lspace_factor, lspace_factor); error++;
      }
  }
  {
    BITCODE_BS lspace_style;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "lspace_style", &lspace_style, NULL) &&
        lspace_style == dimension_linear->lspace_style)
      pass ("DIMENSION_LINEAR.lspace_style [BS]");
    else
      {
        fail ("DIMENSION_LINEAR.lspace_style [BS] %d != %d", dimension_linear->lspace_style, lspace_style); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "parent", &parent, NULL)
        && !memcmp(&parent, &dimension_linear->parent, sizeof(dimension_linear->parent)))
      pass ("DIMENSION_LINEAR.parent");
    else
      {
        fail ("DIMENSION_LINEAR.parent"); error++;
      }
  }
  {
    Dwg_Bitcode_2RD text_midpt;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "text_midpt", &text_midpt, NULL)
        && !memcmp(&text_midpt, &dimension_linear->text_midpt, sizeof(dimension_linear->text_midpt)))
      pass ("DIMENSION_LINEAR.text_midpt");
    else
      {
        fail ("DIMENSION_LINEAR.text_midpt"); error++;
      }
  }
  {
    BITCODE_BD text_rotation;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "text_rotation", &text_rotation, NULL) &&
        text_rotation == dimension_linear->text_rotation)
      pass ("DIMENSION_LINEAR.text_rotation [BD]");
    else
      {
        fail ("DIMENSION_LINEAR.text_rotation [BD] %g != %g", dimension_linear->text_rotation, text_rotation); error++;
      }
  }
  {
    BITCODE_RC unknown;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "unknown", &unknown, NULL) &&
        unknown == dimension_linear->unknown)
      pass ("DIMENSION_LINEAR.unknown [RC]");
    else
      {
        fail ("DIMENSION_LINEAR.unknown [RC] %c != %c", dimension_linear->unknown, unknown); error++;
      }
  }
  {
    BITCODE_TV user_text;
    if (dwg_dynapi_entity_value(dimension_linear, "DIMENSION_LINEAR", "user_text", &user_text, NULL)
        && !strcmp((char*)&user_text, (char*)&dimension_linear->user_text))
      pass ("DIMENSION_LINEAR.user_text");
    else
      {
        fail ("DIMENSION_LINEAR.user_text"); error++;
      }
  }
  return error;
}
static int test_DIMENSION_ORDINATE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_DIMENSION_ORDINATE *dimension_ordinate = obj->tio.entity->tio.DIMENSION_ORDINATE;
  {
    BITCODE_BD act_measurement;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "act_measurement", &act_measurement, NULL) &&
        act_measurement == dimension_ordinate->act_measurement)
      pass ("DIMENSION_ORDINATE.act_measurement [BD]");
    else
      {
        fail ("DIMENSION_ORDINATE.act_measurement [BD] %g != %g", dimension_ordinate->act_measurement, act_measurement); error++;
      }
  }
  {
    BITCODE_BS attachment;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "attachment", &attachment, NULL) &&
        attachment == dimension_ordinate->attachment)
      pass ("DIMENSION_ORDINATE.attachment [BS]");
    else
      {
        fail ("DIMENSION_ORDINATE.attachment [BS] %d != %d", dimension_ordinate->attachment, attachment); error++;
      }
  }
  {
    BITCODE_H block;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "block", &block, NULL) &&
        block == dimension_ordinate->block)
      pass ("DIMENSION_ORDINATE.block [H]");
    else
      {
        fail ("DIMENSION_ORDINATE.block [H] %p != %p", dimension_ordinate->block, block); error++;
      }
  }
  {
    BITCODE_TV blockname;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "blockname", &blockname, NULL)
        && !strcmp((char*)&blockname, (char*)&dimension_ordinate->blockname))
      pass ("DIMENSION_ORDINATE.blockname");
    else
      {
        fail ("DIMENSION_ORDINATE.blockname"); error++;
      }
  }
  {
    BITCODE_RC class_version;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "class_version", &class_version, NULL) &&
        class_version == dimension_ordinate->class_version)
      pass ("DIMENSION_ORDINATE.class_version [RC]");
    else
      {
        fail ("DIMENSION_ORDINATE.class_version [RC] %c != %c", dimension_ordinate->class_version, class_version); error++;
      }
  }
  {
    Dwg_Bitcode_2RD clone_ins_pt;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "clone_ins_pt", &clone_ins_pt, NULL)
        && !memcmp(&clone_ins_pt, &dimension_ordinate->clone_ins_pt, sizeof(dimension_ordinate->clone_ins_pt)))
      pass ("DIMENSION_ORDINATE.clone_ins_pt");
    else
      {
        fail ("DIMENSION_ORDINATE.clone_ins_pt"); error++;
      }
  }
  {
    Dwg_Bitcode_3BD def_pt;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "def_pt", &def_pt, NULL)
        && !memcmp(&def_pt, &dimension_ordinate->def_pt, sizeof(dimension_ordinate->def_pt)))
      pass ("DIMENSION_ORDINATE.def_pt");
    else
      {
        fail ("DIMENSION_ORDINATE.def_pt"); error++;
      }
  }
  {
    BITCODE_H dimstyle;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "dimstyle", &dimstyle, NULL) &&
        dimstyle == dimension_ordinate->dimstyle)
      pass ("DIMENSION_ORDINATE.dimstyle [H]");
    else
      {
        fail ("DIMENSION_ORDINATE.dimstyle [H] %p != %p", dimension_ordinate->dimstyle, dimstyle); error++;
      }
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "elevation", &elevation, NULL) &&
        elevation == dimension_ordinate->elevation)
      pass ("DIMENSION_ORDINATE.elevation [BD]");
    else
      {
        fail ("DIMENSION_ORDINATE.elevation [BD] %g != %g", dimension_ordinate->elevation, elevation); error++;
      }
  }
  {
    Dwg_Bitcode_3BD extrusion;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &dimension_ordinate->extrusion, sizeof(dimension_ordinate->extrusion)))
      pass ("DIMENSION_ORDINATE.extrusion");
    else
      {
        fail ("DIMENSION_ORDINATE.extrusion"); error++;
      }
  }
  {
    BITCODE_3BD feature_location_pt;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "feature_location_pt", &feature_location_pt, NULL)
        && !memcmp(&feature_location_pt, &dimension_ordinate->feature_location_pt, sizeof(dimension_ordinate->feature_location_pt)))
      pass ("DIMENSION_ORDINATE.feature_location_pt");
    else
      {
        fail ("DIMENSION_ORDINATE.feature_location_pt"); error++;
      }
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "flag", &flag, NULL) &&
        flag == dimension_ordinate->flag)
      pass ("DIMENSION_ORDINATE.flag [RC]");
    else
      {
        fail ("DIMENSION_ORDINATE.flag [RC] %c != %c", dimension_ordinate->flag, flag); error++;
      }
  }
  {
    BITCODE_RC flag1;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "flag1", &flag1, NULL) &&
        flag1 == dimension_ordinate->flag1)
      pass ("DIMENSION_ORDINATE.flag1 [RC]");
    else
      {
        fail ("DIMENSION_ORDINATE.flag1 [RC] %c != %c", dimension_ordinate->flag1, flag1); error++;
      }
  }
  {
    BITCODE_RC flag2;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "flag2", &flag2, NULL) &&
        flag2 == dimension_ordinate->flag2)
      pass ("DIMENSION_ORDINATE.flag2 [RC]");
    else
      {
        fail ("DIMENSION_ORDINATE.flag2 [RC] %c != %c", dimension_ordinate->flag2, flag2); error++;
      }
  }
  {
    BITCODE_RC flip_arrow1;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "flip_arrow1", &flip_arrow1, NULL) &&
        flip_arrow1 == dimension_ordinate->flip_arrow1)
      pass ("DIMENSION_ORDINATE.flip_arrow1 [RC]");
    else
      {
        fail ("DIMENSION_ORDINATE.flip_arrow1 [RC] %c != %c", dimension_ordinate->flip_arrow1, flip_arrow1); error++;
      }
  }
  {
    BITCODE_RC flip_arrow2;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "flip_arrow2", &flip_arrow2, NULL) &&
        flip_arrow2 == dimension_ordinate->flip_arrow2)
      pass ("DIMENSION_ORDINATE.flip_arrow2 [RC]");
    else
      {
        fail ("DIMENSION_ORDINATE.flip_arrow2 [RC] %c != %c", dimension_ordinate->flip_arrow2, flip_arrow2); error++;
      }
  }
  {
    BITCODE_BD horiz_dir;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "horiz_dir", &horiz_dir, NULL) &&
        horiz_dir == dimension_ordinate->horiz_dir)
      pass ("DIMENSION_ORDINATE.horiz_dir [BD]");
    else
      {
        fail ("DIMENSION_ORDINATE.horiz_dir [BD] %g != %g", dimension_ordinate->horiz_dir, horiz_dir); error++;
      }
  }
  {
    BITCODE_BD ins_rotation;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "ins_rotation", &ins_rotation, NULL) &&
        ins_rotation == dimension_ordinate->ins_rotation)
      pass ("DIMENSION_ORDINATE.ins_rotation [BD]");
    else
      {
        fail ("DIMENSION_ORDINATE.ins_rotation [BD] %g != %g", dimension_ordinate->ins_rotation, ins_rotation); error++;
      }
  }
  {
    Dwg_Bitcode_3BD ins_scale;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "ins_scale", &ins_scale, NULL)
        && !memcmp(&ins_scale, &dimension_ordinate->ins_scale, sizeof(dimension_ordinate->ins_scale)))
      pass ("DIMENSION_ORDINATE.ins_scale");
    else
      {
        fail ("DIMENSION_ORDINATE.ins_scale"); error++;
      }
  }
  {
    BITCODE_3BD leader_endpt;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "leader_endpt", &leader_endpt, NULL)
        && !memcmp(&leader_endpt, &dimension_ordinate->leader_endpt, sizeof(dimension_ordinate->leader_endpt)))
      pass ("DIMENSION_ORDINATE.leader_endpt");
    else
      {
        fail ("DIMENSION_ORDINATE.leader_endpt"); error++;
      }
  }
  {
    BITCODE_BD lspace_factor;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "lspace_factor", &lspace_factor, NULL) &&
        lspace_factor == dimension_ordinate->lspace_factor)
      pass ("DIMENSION_ORDINATE.lspace_factor [BD]");
    else
      {
        fail ("DIMENSION_ORDINATE.lspace_factor [BD] %g != %g", dimension_ordinate->lspace_factor, lspace_factor); error++;
      }
  }
  {
    BITCODE_BS lspace_style;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "lspace_style", &lspace_style, NULL) &&
        lspace_style == dimension_ordinate->lspace_style)
      pass ("DIMENSION_ORDINATE.lspace_style [BS]");
    else
      {
        fail ("DIMENSION_ORDINATE.lspace_style [BS] %d != %d", dimension_ordinate->lspace_style, lspace_style); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "parent", &parent, NULL)
        && !memcmp(&parent, &dimension_ordinate->parent, sizeof(dimension_ordinate->parent)))
      pass ("DIMENSION_ORDINATE.parent");
    else
      {
        fail ("DIMENSION_ORDINATE.parent"); error++;
      }
  }
  {
    Dwg_Bitcode_2RD text_midpt;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "text_midpt", &text_midpt, NULL)
        && !memcmp(&text_midpt, &dimension_ordinate->text_midpt, sizeof(dimension_ordinate->text_midpt)))
      pass ("DIMENSION_ORDINATE.text_midpt");
    else
      {
        fail ("DIMENSION_ORDINATE.text_midpt"); error++;
      }
  }
  {
    BITCODE_BD text_rotation;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "text_rotation", &text_rotation, NULL) &&
        text_rotation == dimension_ordinate->text_rotation)
      pass ("DIMENSION_ORDINATE.text_rotation [BD]");
    else
      {
        fail ("DIMENSION_ORDINATE.text_rotation [BD] %g != %g", dimension_ordinate->text_rotation, text_rotation); error++;
      }
  }
  {
    BITCODE_RC unknown;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "unknown", &unknown, NULL) &&
        unknown == dimension_ordinate->unknown)
      pass ("DIMENSION_ORDINATE.unknown [RC]");
    else
      {
        fail ("DIMENSION_ORDINATE.unknown [RC] %c != %c", dimension_ordinate->unknown, unknown); error++;
      }
  }
  {
    BITCODE_TV user_text;
    if (dwg_dynapi_entity_value(dimension_ordinate, "DIMENSION_ORDINATE", "user_text", &user_text, NULL)
        && !strcmp((char*)&user_text, (char*)&dimension_ordinate->user_text))
      pass ("DIMENSION_ORDINATE.user_text");
    else
      {
        fail ("DIMENSION_ORDINATE.user_text"); error++;
      }
  }
  return error;
}
static int test_DIMENSION_RADIUS (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_DIMENSION_RADIUS *dimension_radius = obj->tio.entity->tio.DIMENSION_RADIUS;
  {
    BITCODE_BD act_measurement;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "act_measurement", &act_measurement, NULL) &&
        act_measurement == dimension_radius->act_measurement)
      pass ("DIMENSION_RADIUS.act_measurement [BD]");
    else
      {
        fail ("DIMENSION_RADIUS.act_measurement [BD] %g != %g", dimension_radius->act_measurement, act_measurement); error++;
      }
  }
  {
    BITCODE_BS attachment;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "attachment", &attachment, NULL) &&
        attachment == dimension_radius->attachment)
      pass ("DIMENSION_RADIUS.attachment [BS]");
    else
      {
        fail ("DIMENSION_RADIUS.attachment [BS] %d != %d", dimension_radius->attachment, attachment); error++;
      }
  }
  {
    BITCODE_H block;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "block", &block, NULL) &&
        block == dimension_radius->block)
      pass ("DIMENSION_RADIUS.block [H]");
    else
      {
        fail ("DIMENSION_RADIUS.block [H] %p != %p", dimension_radius->block, block); error++;
      }
  }
  {
    BITCODE_TV blockname;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "blockname", &blockname, NULL)
        && !strcmp((char*)&blockname, (char*)&dimension_radius->blockname))
      pass ("DIMENSION_RADIUS.blockname");
    else
      {
        fail ("DIMENSION_RADIUS.blockname"); error++;
      }
  }
  {
    BITCODE_RC class_version;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "class_version", &class_version, NULL) &&
        class_version == dimension_radius->class_version)
      pass ("DIMENSION_RADIUS.class_version [RC]");
    else
      {
        fail ("DIMENSION_RADIUS.class_version [RC] %c != %c", dimension_radius->class_version, class_version); error++;
      }
  }
  {
    Dwg_Bitcode_2RD clone_ins_pt;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "clone_ins_pt", &clone_ins_pt, NULL)
        && !memcmp(&clone_ins_pt, &dimension_radius->clone_ins_pt, sizeof(dimension_radius->clone_ins_pt)))
      pass ("DIMENSION_RADIUS.clone_ins_pt");
    else
      {
        fail ("DIMENSION_RADIUS.clone_ins_pt"); error++;
      }
  }
  {
    Dwg_Bitcode_3BD def_pt;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "def_pt", &def_pt, NULL)
        && !memcmp(&def_pt, &dimension_radius->def_pt, sizeof(dimension_radius->def_pt)))
      pass ("DIMENSION_RADIUS.def_pt");
    else
      {
        fail ("DIMENSION_RADIUS.def_pt"); error++;
      }
  }
  {
    BITCODE_H dimstyle;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "dimstyle", &dimstyle, NULL) &&
        dimstyle == dimension_radius->dimstyle)
      pass ("DIMENSION_RADIUS.dimstyle [H]");
    else
      {
        fail ("DIMENSION_RADIUS.dimstyle [H] %p != %p", dimension_radius->dimstyle, dimstyle); error++;
      }
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "elevation", &elevation, NULL) &&
        elevation == dimension_radius->elevation)
      pass ("DIMENSION_RADIUS.elevation [BD]");
    else
      {
        fail ("DIMENSION_RADIUS.elevation [BD] %g != %g", dimension_radius->elevation, elevation); error++;
      }
  }
  {
    Dwg_Bitcode_3BD extrusion;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &dimension_radius->extrusion, sizeof(dimension_radius->extrusion)))
      pass ("DIMENSION_RADIUS.extrusion");
    else
      {
        fail ("DIMENSION_RADIUS.extrusion"); error++;
      }
  }
  {
    BITCODE_3BD first_arc_pt;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "first_arc_pt", &first_arc_pt, NULL)
        && !memcmp(&first_arc_pt, &dimension_radius->first_arc_pt, sizeof(dimension_radius->first_arc_pt)))
      pass ("DIMENSION_RADIUS.first_arc_pt");
    else
      {
        fail ("DIMENSION_RADIUS.first_arc_pt"); error++;
      }
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "flag", &flag, NULL) &&
        flag == dimension_radius->flag)
      pass ("DIMENSION_RADIUS.flag [RC]");
    else
      {
        fail ("DIMENSION_RADIUS.flag [RC] %c != %c", dimension_radius->flag, flag); error++;
      }
  }
  {
    BITCODE_RC flag1;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "flag1", &flag1, NULL) &&
        flag1 == dimension_radius->flag1)
      pass ("DIMENSION_RADIUS.flag1 [RC]");
    else
      {
        fail ("DIMENSION_RADIUS.flag1 [RC] %c != %c", dimension_radius->flag1, flag1); error++;
      }
  }
  {
    BITCODE_RC flip_arrow1;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "flip_arrow1", &flip_arrow1, NULL) &&
        flip_arrow1 == dimension_radius->flip_arrow1)
      pass ("DIMENSION_RADIUS.flip_arrow1 [RC]");
    else
      {
        fail ("DIMENSION_RADIUS.flip_arrow1 [RC] %c != %c", dimension_radius->flip_arrow1, flip_arrow1); error++;
      }
  }
  {
    BITCODE_RC flip_arrow2;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "flip_arrow2", &flip_arrow2, NULL) &&
        flip_arrow2 == dimension_radius->flip_arrow2)
      pass ("DIMENSION_RADIUS.flip_arrow2 [RC]");
    else
      {
        fail ("DIMENSION_RADIUS.flip_arrow2 [RC] %c != %c", dimension_radius->flip_arrow2, flip_arrow2); error++;
      }
  }
  {
    BITCODE_BD horiz_dir;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "horiz_dir", &horiz_dir, NULL) &&
        horiz_dir == dimension_radius->horiz_dir)
      pass ("DIMENSION_RADIUS.horiz_dir [BD]");
    else
      {
        fail ("DIMENSION_RADIUS.horiz_dir [BD] %g != %g", dimension_radius->horiz_dir, horiz_dir); error++;
      }
  }
  {
    BITCODE_BD ins_rotation;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "ins_rotation", &ins_rotation, NULL) &&
        ins_rotation == dimension_radius->ins_rotation)
      pass ("DIMENSION_RADIUS.ins_rotation [BD]");
    else
      {
        fail ("DIMENSION_RADIUS.ins_rotation [BD] %g != %g", dimension_radius->ins_rotation, ins_rotation); error++;
      }
  }
  {
    Dwg_Bitcode_3BD ins_scale;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "ins_scale", &ins_scale, NULL)
        && !memcmp(&ins_scale, &dimension_radius->ins_scale, sizeof(dimension_radius->ins_scale)))
      pass ("DIMENSION_RADIUS.ins_scale");
    else
      {
        fail ("DIMENSION_RADIUS.ins_scale"); error++;
      }
  }
  {
    BITCODE_BD leader_len;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "leader_len", &leader_len, NULL) &&
        leader_len == dimension_radius->leader_len)
      pass ("DIMENSION_RADIUS.leader_len [BD]");
    else
      {
        fail ("DIMENSION_RADIUS.leader_len [BD] %g != %g", dimension_radius->leader_len, leader_len); error++;
      }
  }
  {
    BITCODE_BD lspace_factor;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "lspace_factor", &lspace_factor, NULL) &&
        lspace_factor == dimension_radius->lspace_factor)
      pass ("DIMENSION_RADIUS.lspace_factor [BD]");
    else
      {
        fail ("DIMENSION_RADIUS.lspace_factor [BD] %g != %g", dimension_radius->lspace_factor, lspace_factor); error++;
      }
  }
  {
    BITCODE_BS lspace_style;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "lspace_style", &lspace_style, NULL) &&
        lspace_style == dimension_radius->lspace_style)
      pass ("DIMENSION_RADIUS.lspace_style [BS]");
    else
      {
        fail ("DIMENSION_RADIUS.lspace_style [BS] %d != %d", dimension_radius->lspace_style, lspace_style); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "parent", &parent, NULL)
        && !memcmp(&parent, &dimension_radius->parent, sizeof(dimension_radius->parent)))
      pass ("DIMENSION_RADIUS.parent");
    else
      {
        fail ("DIMENSION_RADIUS.parent"); error++;
      }
  }
  {
    Dwg_Bitcode_2RD text_midpt;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "text_midpt", &text_midpt, NULL)
        && !memcmp(&text_midpt, &dimension_radius->text_midpt, sizeof(dimension_radius->text_midpt)))
      pass ("DIMENSION_RADIUS.text_midpt");
    else
      {
        fail ("DIMENSION_RADIUS.text_midpt"); error++;
      }
  }
  {
    BITCODE_BD text_rotation;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "text_rotation", &text_rotation, NULL) &&
        text_rotation == dimension_radius->text_rotation)
      pass ("DIMENSION_RADIUS.text_rotation [BD]");
    else
      {
        fail ("DIMENSION_RADIUS.text_rotation [BD] %g != %g", dimension_radius->text_rotation, text_rotation); error++;
      }
  }
  {
    BITCODE_RC unknown;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "unknown", &unknown, NULL) &&
        unknown == dimension_radius->unknown)
      pass ("DIMENSION_RADIUS.unknown [RC]");
    else
      {
        fail ("DIMENSION_RADIUS.unknown [RC] %c != %c", dimension_radius->unknown, unknown); error++;
      }
  }
  {
    BITCODE_TV user_text;
    if (dwg_dynapi_entity_value(dimension_radius, "DIMENSION_RADIUS", "user_text", &user_text, NULL)
        && !strcmp((char*)&user_text, (char*)&dimension_radius->user_text))
      pass ("DIMENSION_RADIUS.user_text");
    else
      {
        fail ("DIMENSION_RADIUS.user_text"); error++;
      }
  }
  return error;
}
static int test_ELLIPSE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_ELLIPSE *ellipse = obj->tio.entity->tio.ELLIPSE;
  {
    BITCODE_BD axis_ratio;
    if (dwg_dynapi_entity_value(ellipse, "ELLIPSE", "axis_ratio", &axis_ratio, NULL) &&
        axis_ratio == ellipse->axis_ratio)
      pass ("ELLIPSE.axis_ratio [BD]");
    else
      {
        fail ("ELLIPSE.axis_ratio [BD] %g != %g", ellipse->axis_ratio, axis_ratio); error++;
      }
  }
  {
    BITCODE_3BD center;
    if (dwg_dynapi_entity_value(ellipse, "ELLIPSE", "center", &center, NULL)
        && !memcmp(&center, &ellipse->center, sizeof(ellipse->center)))
      pass ("ELLIPSE.center");
    else
      {
        fail ("ELLIPSE.center"); error++;
      }
  }
  {
    BITCODE_BD end_angle;
    if (dwg_dynapi_entity_value(ellipse, "ELLIPSE", "end_angle", &end_angle, NULL) &&
        end_angle == ellipse->end_angle)
      pass ("ELLIPSE.end_angle [BD]");
    else
      {
        fail ("ELLIPSE.end_angle [BD] %g != %g", ellipse->end_angle, end_angle); error++;
      }
  }
  {
    BITCODE_3BD extrusion;
    if (dwg_dynapi_entity_value(ellipse, "ELLIPSE", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &ellipse->extrusion, sizeof(ellipse->extrusion)))
      pass ("ELLIPSE.extrusion");
    else
      {
        fail ("ELLIPSE.extrusion"); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(ellipse, "ELLIPSE", "parent", &parent, NULL)
        && !memcmp(&parent, &ellipse->parent, sizeof(ellipse->parent)))
      pass ("ELLIPSE.parent");
    else
      {
        fail ("ELLIPSE.parent"); error++;
      }
  }
  {
    BITCODE_3BD sm_axis;
    if (dwg_dynapi_entity_value(ellipse, "ELLIPSE", "sm_axis", &sm_axis, NULL)
        && !memcmp(&sm_axis, &ellipse->sm_axis, sizeof(ellipse->sm_axis)))
      pass ("ELLIPSE.sm_axis");
    else
      {
        fail ("ELLIPSE.sm_axis"); error++;
      }
  }
  {
    BITCODE_BD start_angle;
    if (dwg_dynapi_entity_value(ellipse, "ELLIPSE", "start_angle", &start_angle, NULL) &&
        start_angle == ellipse->start_angle)
      pass ("ELLIPSE.start_angle [BD]");
    else
      {
        fail ("ELLIPSE.start_angle [BD] %g != %g", ellipse->start_angle, start_angle); error++;
      }
  }
  return error;
}
static int test_ENDBLK (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_ENDBLK *endblk = obj->tio.entity->tio.ENDBLK;
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(endblk, "ENDBLK", "parent", &parent, NULL)
        && !memcmp(&parent, &endblk->parent, sizeof(endblk->parent)))
      pass ("ENDBLK.parent");
    else
      {
        fail ("ENDBLK.parent"); error++;
      }
  }
  return error;
}
static int test_EXTRUDEDSURFACE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_EXTRUDEDSURFACE *extrudedsurface = obj->tio.entity->tio.EXTRUDEDSURFACE;
  {
    unsigned char* acis_data;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "acis_data", &acis_data, NULL)
        && !strcmp((char*)&acis_data, (char*)&extrudedsurface->acis_data))
      pass ("EXTRUDEDSURFACE.acis_data");
    else
      {
        fail ("EXTRUDEDSURFACE.acis_data"); error++;
      }
  }
  {
    BITCODE_RC acis_empty;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "acis_empty", &acis_empty, NULL) &&
        acis_empty == extrudedsurface->acis_empty)
      pass ("EXTRUDEDSURFACE.acis_empty [RC]");
    else
      {
        fail ("EXTRUDEDSURFACE.acis_empty [RC] %c != %c", extrudedsurface->acis_empty, acis_empty); error++;
      }
  }
  {
    BITCODE_RC acis_empty2;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "acis_empty2", &acis_empty2, NULL) &&
        acis_empty2 == extrudedsurface->acis_empty2)
      pass ("EXTRUDEDSURFACE.acis_empty2 [RC]");
    else
      {
        fail ("EXTRUDEDSURFACE.acis_empty2 [RC] %c != %c", extrudedsurface->acis_empty2, acis_empty2); error++;
      }
  }
  {
    BITCODE_RC acis_empty_bit;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "acis_empty_bit", &acis_empty_bit, NULL) &&
        acis_empty_bit == extrudedsurface->acis_empty_bit)
      pass ("EXTRUDEDSURFACE.acis_empty_bit [RC]");
    else
      {
        fail ("EXTRUDEDSURFACE.acis_empty_bit [RC] %c != %c", extrudedsurface->acis_empty_bit, acis_empty_bit); error++;
      }
  }
  {
    BITCODE_BD align_angle;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "align_angle", &align_angle, NULL) &&
        align_angle == extrudedsurface->align_angle)
      pass ("EXTRUDEDSURFACE.align_angle [BD]");
    else
      {
        fail ("EXTRUDEDSURFACE.align_angle [BD] %g != %g", extrudedsurface->align_angle, align_angle); error++;
      }
  }
  {
    BITCODE_B align_start;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "align_start", &align_start, NULL) &&
        align_start == extrudedsurface->align_start)
      pass ("EXTRUDEDSURFACE.align_start [B]");
    else
      {
        fail ("EXTRUDEDSURFACE.align_start [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->align_start, align_start); error++;
      }
  }
  {
    BITCODE_B bank;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "bank", &bank, NULL) &&
        bank == extrudedsurface->bank)
      pass ("EXTRUDEDSURFACE.bank [B]");
    else
      {
        fail ("EXTRUDEDSURFACE.bank [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->bank, bank); error++;
      }
  }
  {
    BITCODE_B base_point_set;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "base_point_set", &base_point_set, NULL) &&
        base_point_set == extrudedsurface->base_point_set)
      pass ("EXTRUDEDSURFACE.base_point_set [B]");
    else
      {
        fail ("EXTRUDEDSURFACE.base_point_set [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->base_point_set, base_point_set); error++;
      }
  }
  {
    BITCODE_TF bindata;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "bindata", &bindata, NULL) &&
        bindata == extrudedsurface->bindata)
      pass ("EXTRUDEDSURFACE.bindata [TF]");
    else
      {
        fail ("EXTRUDEDSURFACE.bindata [TF] " FORMAT_TF " != " FORMAT_TF "", extrudedsurface->bindata, bindata); error++;
      }
  }
  {
    unsigned int* block_size;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "block_size", &block_size, NULL)
        && !memcmp(&block_size, &extrudedsurface->block_size, sizeof(extrudedsurface->block_size)))
      pass ("EXTRUDEDSURFACE.block_size");
    else
      {
        fail ("EXTRUDEDSURFACE.block_size"); error++;
      }
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "class_version", &class_version, NULL) &&
        class_version == extrudedsurface->class_version)
      pass ("EXTRUDEDSURFACE.class_version [BL]");
    else
      {
        fail ("EXTRUDEDSURFACE.class_version [BL] %u != %u", extrudedsurface->class_version, class_version); error++;
      }
  }
  {
    BITCODE_BD draft_angle;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "draft_angle", &draft_angle, NULL) &&
        draft_angle == extrudedsurface->draft_angle)
      pass ("EXTRUDEDSURFACE.draft_angle [BD]");
    else
      {
        fail ("EXTRUDEDSURFACE.draft_angle [BD] %g != %g", extrudedsurface->draft_angle, draft_angle); error++;
      }
  }
  {
    BITCODE_BD draft_end_distance;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "draft_end_distance", &draft_end_distance, NULL) &&
        draft_end_distance == extrudedsurface->draft_end_distance)
      pass ("EXTRUDEDSURFACE.draft_end_distance [BD]");
    else
      {
        fail ("EXTRUDEDSURFACE.draft_end_distance [BD] %g != %g", extrudedsurface->draft_end_distance, draft_end_distance); error++;
      }
  }
  {
    BITCODE_BD draft_start_distance;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "draft_start_distance", &draft_start_distance, NULL) &&
        draft_start_distance == extrudedsurface->draft_start_distance)
      pass ("EXTRUDEDSURFACE.draft_start_distance [BD]");
    else
      {
        fail ("EXTRUDEDSURFACE.draft_start_distance [BD] %g != %g", extrudedsurface->draft_start_distance, draft_start_distance); error++;
      }
  }
  {
    BITCODE_TV encr_sat_data;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "encr_sat_data", &encr_sat_data, NULL)
        && !strcmp((char*)&encr_sat_data, (char*)&extrudedsurface->encr_sat_data))
      pass ("EXTRUDEDSURFACE.encr_sat_data");
    else
      {
        fail ("EXTRUDEDSURFACE.encr_sat_data"); error++;
      }
  }
  {
    struct _dwg_entity_3DSOLID* extra_acis_data;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "extra_acis_data", &extra_acis_data, NULL)
        && !memcmp(&extra_acis_data, &extrudedsurface->extra_acis_data, sizeof(extrudedsurface->extra_acis_data)))
      pass ("EXTRUDEDSURFACE.extra_acis_data");
    else
      {
        fail ("EXTRUDEDSURFACE.extra_acis_data"); error++;
      }
  }
  {
    BITCODE_BD height;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "height", &height, NULL) &&
        height == extrudedsurface->height)
      pass ("EXTRUDEDSURFACE.height [BD]");
    else
      {
        fail ("EXTRUDEDSURFACE.height [BD] %g != %g", extrudedsurface->height, height); error++;
      }
  }
  {
    Dwg_Object_Ref* history_id;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "history_id", &history_id, NULL)
        && !memcmp(&history_id, &extrudedsurface->history_id, sizeof(extrudedsurface->history_id)))
      pass ("EXTRUDEDSURFACE.history_id");
    else
      {
        fail ("EXTRUDEDSURFACE.history_id"); error++;
      }
  }
  {
    BITCODE_RC isoline_present;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "isoline_present", &isoline_present, NULL) &&
        isoline_present == extrudedsurface->isoline_present)
      pass ("EXTRUDEDSURFACE.isoline_present [RC]");
    else
      {
        fail ("EXTRUDEDSURFACE.isoline_present [RC] %c != %c", extrudedsurface->isoline_present, isoline_present); error++;
      }
  }
  {
    BITCODE_BS modeler_format_version;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "modeler_format_version", &modeler_format_version, NULL) &&
        modeler_format_version == extrudedsurface->modeler_format_version)
      pass ("EXTRUDEDSURFACE.modeler_format_version [BS]");
    else
      {
        fail ("EXTRUDEDSURFACE.modeler_format_version [BS] %d != %d", extrudedsurface->modeler_format_version, modeler_format_version); error++;
      }
  }
  {
    BITCODE_BL num_blocks;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "num_blocks", &num_blocks, NULL) &&
        num_blocks == extrudedsurface->num_blocks)
      pass ("EXTRUDEDSURFACE.num_blocks [BL]");
    else
      {
        fail ("EXTRUDEDSURFACE.num_blocks [BL] %u != %u", extrudedsurface->num_blocks, num_blocks); error++;
      }
  }
  {
    BITCODE_BL num_isolines;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "num_isolines", &num_isolines, NULL) &&
        num_isolines == extrudedsurface->num_isolines)
      pass ("EXTRUDEDSURFACE.num_isolines [BL]");
    else
      {
        fail ("EXTRUDEDSURFACE.num_isolines [BL] %u != %u", extrudedsurface->num_isolines, num_isolines); error++;
      }
  }
  {
    BITCODE_BL num_silhouettes;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "num_silhouettes", &num_silhouettes, NULL) &&
        num_silhouettes == extrudedsurface->num_silhouettes)
      pass ("EXTRUDEDSURFACE.num_silhouettes [BL]");
    else
      {
        fail ("EXTRUDEDSURFACE.num_silhouettes [BL] %u != %u", extrudedsurface->num_silhouettes, num_silhouettes); error++;
      }
  }
  {
    BITCODE_BL num_wires;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "num_wires", &num_wires, NULL) &&
        num_wires == extrudedsurface->num_wires)
      pass ("EXTRUDEDSURFACE.num_wires [BL]");
    else
      {
        fail ("EXTRUDEDSURFACE.num_wires [BL] %u != %u", extrudedsurface->num_wires, num_wires); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "parent", &parent, NULL)
        && !memcmp(&parent, &extrudedsurface->parent, sizeof(extrudedsurface->parent)))
      pass ("EXTRUDEDSURFACE.parent");
    else
      {
        fail ("EXTRUDEDSURFACE.parent"); error++;
      }
  }
  {
    BITCODE_H path_entity;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "path_entity", &path_entity, NULL) &&
        path_entity == extrudedsurface->path_entity)
      pass ("EXTRUDEDSURFACE.path_entity [H]");
    else
      {
        fail ("EXTRUDEDSURFACE.path_entity [H] %p != %p", extrudedsurface->path_entity, path_entity); error++;
      }
  }
  {
    BITCODE_B path_entity_transform_computed;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "path_entity_transform_computed", &path_entity_transform_computed, NULL) &&
        path_entity_transform_computed == extrudedsurface->path_entity_transform_computed)
      pass ("EXTRUDEDSURFACE.path_entity_transform_computed [B]");
    else
      {
        fail ("EXTRUDEDSURFACE.path_entity_transform_computed [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->path_entity_transform_computed, path_entity_transform_computed); error++;
      }
  }
  {
    BITCODE_BD* path_entity_transmatrix;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "path_entity_transmatrix", &path_entity_transmatrix, NULL)
        && !memcmp(&path_entity_transmatrix, &extrudedsurface->path_entity_transmatrix, sizeof(extrudedsurface->path_entity_transmatrix)))
      pass ("EXTRUDEDSURFACE.path_entity_transmatrix");
    else
      {
        fail ("EXTRUDEDSURFACE.path_entity_transmatrix"); error++;
      }
  }
  {
    Dwg_Bitcode_3BD point;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "point", &point, NULL)
        && !memcmp(&point, &extrudedsurface->point, sizeof(extrudedsurface->point)))
      pass ("EXTRUDEDSURFACE.point");
    else
      {
        fail ("EXTRUDEDSURFACE.point"); error++;
      }
  }
  {
    BITCODE_RC point_present;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "point_present", &point_present, NULL) &&
        point_present == extrudedsurface->point_present)
      pass ("EXTRUDEDSURFACE.point_present [RC]");
    else
      {
        fail ("EXTRUDEDSURFACE.point_present [RC] %c != %c", extrudedsurface->point_present, point_present); error++;
      }
  }
  {
    BITCODE_3BD reference_vector_for_controlling_twist;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "reference_vector_for_controlling_twist", &reference_vector_for_controlling_twist, NULL)
        && !memcmp(&reference_vector_for_controlling_twist, &extrudedsurface->reference_vector_for_controlling_twist, sizeof(extrudedsurface->reference_vector_for_controlling_twist)))
      pass ("EXTRUDEDSURFACE.reference_vector_for_controlling_twist");
    else
      {
        fail ("EXTRUDEDSURFACE.reference_vector_for_controlling_twist"); error++;
      }
  }
  {
    BITCODE_BD scale_factor;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "scale_factor", &scale_factor, NULL) &&
        scale_factor == extrudedsurface->scale_factor)
      pass ("EXTRUDEDSURFACE.scale_factor [BD]");
    else
      {
        fail ("EXTRUDEDSURFACE.scale_factor [BD] %g != %g", extrudedsurface->scale_factor, scale_factor); error++;
      }
  }
  {
    Dwg_3DSOLID_silhouette* silhouettes;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "silhouettes", &silhouettes, NULL)
        && !memcmp(&silhouettes, &extrudedsurface->silhouettes, sizeof(extrudedsurface->silhouettes)))
      pass ("EXTRUDEDSURFACE.silhouettes");
    else
      {
        fail ("EXTRUDEDSURFACE.silhouettes"); error++;
      }
  }
  {
    BITCODE_BL size_bindata;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "size_bindata", &size_bindata, NULL) &&
        size_bindata == extrudedsurface->size_bindata)
      pass ("EXTRUDEDSURFACE.size_bindata [BL]");
    else
      {
        fail ("EXTRUDEDSURFACE.size_bindata [BL] %u != %u", extrudedsurface->size_bindata, size_bindata); error++;
      }
  }
  {
    BITCODE_B solid;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "solid", &solid, NULL) &&
        solid == extrudedsurface->solid)
      pass ("EXTRUDEDSURFACE.solid [B]");
    else
      {
        fail ("EXTRUDEDSURFACE.solid [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->solid, solid); error++;
      }
  }
  {
    BITCODE_BS sweep_alignment_flags;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "sweep_alignment_flags", &sweep_alignment_flags, NULL) &&
        sweep_alignment_flags == extrudedsurface->sweep_alignment_flags)
      pass ("EXTRUDEDSURFACE.sweep_alignment_flags [BS]");
    else
      {
        fail ("EXTRUDEDSURFACE.sweep_alignment_flags [BS] %d != %d", extrudedsurface->sweep_alignment_flags, sweep_alignment_flags); error++;
      }
  }
  {
    BITCODE_H sweep_entity;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "sweep_entity", &sweep_entity, NULL) &&
        sweep_entity == extrudedsurface->sweep_entity)
      pass ("EXTRUDEDSURFACE.sweep_entity [H]");
    else
      {
        fail ("EXTRUDEDSURFACE.sweep_entity [H] %p != %p", extrudedsurface->sweep_entity, sweep_entity); error++;
      }
  }
  {
    BITCODE_B sweep_entity_transform_computed;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "sweep_entity_transform_computed", &sweep_entity_transform_computed, NULL) &&
        sweep_entity_transform_computed == extrudedsurface->sweep_entity_transform_computed)
      pass ("EXTRUDEDSURFACE.sweep_entity_transform_computed [B]");
    else
      {
        fail ("EXTRUDEDSURFACE.sweep_entity_transform_computed [B] " FORMAT_B " != " FORMAT_B "", extrudedsurface->sweep_entity_transform_computed, sweep_entity_transform_computed); error++;
      }
  }
  {
    BITCODE_BD* sweep_entity_transmatrix;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "sweep_entity_transmatrix", &sweep_entity_transmatrix, NULL)
        && !memcmp(&sweep_entity_transmatrix, &extrudedsurface->sweep_entity_transmatrix, sizeof(extrudedsurface->sweep_entity_transmatrix)))
      pass ("EXTRUDEDSURFACE.sweep_entity_transmatrix");
    else
      {
        fail ("EXTRUDEDSURFACE.sweep_entity_transmatrix"); error++;
      }
  }
  {
    BITCODE_BD* sweep_transmatrix;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "sweep_transmatrix", &sweep_transmatrix, NULL)
        && !memcmp(&sweep_transmatrix, &extrudedsurface->sweep_transmatrix, sizeof(extrudedsurface->sweep_transmatrix)))
      pass ("EXTRUDEDSURFACE.sweep_transmatrix");
    else
      {
        fail ("EXTRUDEDSURFACE.sweep_transmatrix"); error++;
      }
  }
  {
    BITCODE_3BD sweep_vector;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "sweep_vector", &sweep_vector, NULL)
        && !memcmp(&sweep_vector, &extrudedsurface->sweep_vector, sizeof(extrudedsurface->sweep_vector)))
      pass ("EXTRUDEDSURFACE.sweep_vector");
    else
      {
        fail ("EXTRUDEDSURFACE.sweep_vector"); error++;
      }
  }
  {
    BITCODE_BD twist_angle;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "twist_angle", &twist_angle, NULL) &&
        twist_angle == extrudedsurface->twist_angle)
      pass ("EXTRUDEDSURFACE.twist_angle [BD]");
    else
      {
        fail ("EXTRUDEDSURFACE.twist_angle [BD] %g != %g", extrudedsurface->twist_angle, twist_angle); error++;
      }
  }
  {
    BITCODE_BS u_isolines;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "u_isolines", &u_isolines, NULL) &&
        u_isolines == extrudedsurface->u_isolines)
      pass ("EXTRUDEDSURFACE.u_isolines [BS]");
    else
      {
        fail ("EXTRUDEDSURFACE.u_isolines [BS] %d != %d", extrudedsurface->u_isolines, u_isolines); error++;
      }
  }
  {
    BITCODE_RC unknown;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "unknown", &unknown, NULL) &&
        unknown == extrudedsurface->unknown)
      pass ("EXTRUDEDSURFACE.unknown [RC]");
    else
      {
        fail ("EXTRUDEDSURFACE.unknown [RC] %c != %c", extrudedsurface->unknown, unknown); error++;
      }
  }
  {
    BITCODE_BL unknown_2007;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "unknown_2007", &unknown_2007, NULL) &&
        unknown_2007 == extrudedsurface->unknown_2007)
      pass ("EXTRUDEDSURFACE.unknown_2007 [BL]");
    else
      {
        fail ("EXTRUDEDSURFACE.unknown_2007 [BL] %u != %u", extrudedsurface->unknown_2007, unknown_2007); error++;
      }
  }
  {
    BITCODE_BS v_isolines;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "v_isolines", &v_isolines, NULL) &&
        v_isolines == extrudedsurface->v_isolines)
      pass ("EXTRUDEDSURFACE.v_isolines [BS]");
    else
      {
        fail ("EXTRUDEDSURFACE.v_isolines [BS] %d != %d", extrudedsurface->v_isolines, v_isolines); error++;
      }
  }
  {
    BITCODE_BS version;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "version", &version, NULL) &&
        version == extrudedsurface->version)
      pass ("EXTRUDEDSURFACE.version [BS]");
    else
      {
        fail ("EXTRUDEDSURFACE.version [BS] %d != %d", extrudedsurface->version, version); error++;
      }
  }
  {
    BITCODE_RC wireframe_data_present;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "wireframe_data_present", &wireframe_data_present, NULL) &&
        wireframe_data_present == extrudedsurface->wireframe_data_present)
      pass ("EXTRUDEDSURFACE.wireframe_data_present [RC]");
    else
      {
        fail ("EXTRUDEDSURFACE.wireframe_data_present [RC] %c != %c", extrudedsurface->wireframe_data_present, wireframe_data_present); error++;
      }
  }
  {
    Dwg_3DSOLID_wire* wires;
    if (dwg_dynapi_entity_value(extrudedsurface, "EXTRUDEDSURFACE", "wires", &wires, NULL)
        && !memcmp(&wires, &extrudedsurface->wires, sizeof(extrudedsurface->wires)))
      pass ("EXTRUDEDSURFACE.wires");
    else
      {
        fail ("EXTRUDEDSURFACE.wires"); error++;
      }
  }
  return error;
}
static int test_GEOPOSITIONMARKER (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_GEOPOSITIONMARKER *geopositionmarker = obj->tio.entity->tio.GEOPOSITIONMARKER;
  {
    BITCODE_B enable_frame_text;
    if (dwg_dynapi_entity_value(geopositionmarker, "GEOPOSITIONMARKER", "enable_frame_text", &enable_frame_text, NULL) &&
        enable_frame_text == geopositionmarker->enable_frame_text)
      pass ("GEOPOSITIONMARKER.enable_frame_text [B]");
    else
      {
        fail ("GEOPOSITIONMARKER.enable_frame_text [B] " FORMAT_B " != " FORMAT_B "", geopositionmarker->enable_frame_text, enable_frame_text); error++;
      }
  }
  {
    BITCODE_3BD extrusion;
    if (dwg_dynapi_entity_value(geopositionmarker, "GEOPOSITIONMARKER", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &geopositionmarker->extrusion, sizeof(geopositionmarker->extrusion)))
      pass ("GEOPOSITIONMARKER.extrusion");
    else
      {
        fail ("GEOPOSITIONMARKER.extrusion"); error++;
      }
  }
  {
    BITCODE_BD landing_gap;
    if (dwg_dynapi_entity_value(geopositionmarker, "GEOPOSITIONMARKER", "landing_gap", &landing_gap, NULL) &&
        landing_gap == geopositionmarker->landing_gap)
      pass ("GEOPOSITIONMARKER.landing_gap [BD]");
    else
      {
        fail ("GEOPOSITIONMARKER.landing_gap [BD] %g != %g", geopositionmarker->landing_gap, landing_gap); error++;
      }
  }
  {
    BITCODE_H mtext_handle;
    if (dwg_dynapi_entity_value(geopositionmarker, "GEOPOSITIONMARKER", "mtext_handle", &mtext_handle, NULL) &&
        mtext_handle == geopositionmarker->mtext_handle)
      pass ("GEOPOSITIONMARKER.mtext_handle [H]");
    else
      {
        fail ("GEOPOSITIONMARKER.mtext_handle [H] %p != %p", geopositionmarker->mtext_handle, mtext_handle); error++;
      }
  }
  {
    BITCODE_B mtext_visible;
    if (dwg_dynapi_entity_value(geopositionmarker, "GEOPOSITIONMARKER", "mtext_visible", &mtext_visible, NULL) &&
        mtext_visible == geopositionmarker->mtext_visible)
      pass ("GEOPOSITIONMARKER.mtext_visible [B]");
    else
      {
        fail ("GEOPOSITIONMARKER.mtext_visible [B] " FORMAT_B " != " FORMAT_B "", geopositionmarker->mtext_visible, mtext_visible); error++;
      }
  }
  {
    BITCODE_T notes;
    if (dwg_dynapi_entity_value(geopositionmarker, "GEOPOSITIONMARKER", "notes", &notes, NULL)
        && !memcmp(&notes, &geopositionmarker->notes, sizeof(geopositionmarker->notes)))
      pass ("GEOPOSITIONMARKER.notes");
    else
      {
        fail ("GEOPOSITIONMARKER.notes"); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(geopositionmarker, "GEOPOSITIONMARKER", "parent", &parent, NULL)
        && !memcmp(&parent, &geopositionmarker->parent, sizeof(geopositionmarker->parent)))
      pass ("GEOPOSITIONMARKER.parent");
    else
      {
        fail ("GEOPOSITIONMARKER.parent"); error++;
      }
  }
  {
    BITCODE_3BD position;
    if (dwg_dynapi_entity_value(geopositionmarker, "GEOPOSITIONMARKER", "position", &position, NULL)
        && !memcmp(&position, &geopositionmarker->position, sizeof(geopositionmarker->position)))
      pass ("GEOPOSITIONMARKER.position");
    else
      {
        fail ("GEOPOSITIONMARKER.position"); error++;
      }
  }
  {
    BITCODE_BD radius;
    if (dwg_dynapi_entity_value(geopositionmarker, "GEOPOSITIONMARKER", "radius", &radius, NULL) &&
        radius == geopositionmarker->radius)
      pass ("GEOPOSITIONMARKER.radius [BD]");
    else
      {
        fail ("GEOPOSITIONMARKER.radius [BD] %g != %g", geopositionmarker->radius, radius); error++;
      }
  }
  {
    BITCODE_T text;
    if (dwg_dynapi_entity_value(geopositionmarker, "GEOPOSITIONMARKER", "text", &text, NULL)
        && !memcmp(&text, &geopositionmarker->text, sizeof(geopositionmarker->text)))
      pass ("GEOPOSITIONMARKER.text");
    else
      {
        fail ("GEOPOSITIONMARKER.text"); error++;
      }
  }
  {
    BITCODE_BS text_alignment;
    if (dwg_dynapi_entity_value(geopositionmarker, "GEOPOSITIONMARKER", "text_alignment", &text_alignment, NULL) &&
        text_alignment == geopositionmarker->text_alignment)
      pass ("GEOPOSITIONMARKER.text_alignment [BS]");
    else
      {
        fail ("GEOPOSITIONMARKER.text_alignment [BS] %d != %d", geopositionmarker->text_alignment, text_alignment); error++;
      }
  }
  {
    BITCODE_H text_style;
    if (dwg_dynapi_entity_value(geopositionmarker, "GEOPOSITIONMARKER", "text_style", &text_style, NULL) &&
        text_style == geopositionmarker->text_style)
      pass ("GEOPOSITIONMARKER.text_style [H]");
    else
      {
        fail ("GEOPOSITIONMARKER.text_style [H] %p != %p", geopositionmarker->text_style, text_style); error++;
      }
  }
  {
    BITCODE_BS type;
    if (dwg_dynapi_entity_value(geopositionmarker, "GEOPOSITIONMARKER", "type", &type, NULL) &&
        type == geopositionmarker->type)
      pass ("GEOPOSITIONMARKER.type [BS]");
    else
      {
        fail ("GEOPOSITIONMARKER.type [BS] %d != %d", geopositionmarker->type, type); error++;
      }
  }
  return error;
}
static int test_HATCH (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_HATCH *hatch = obj->tio.entity->tio.HATCH;
  {
    BITCODE_BD angle;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "angle", &angle, NULL) &&
        angle == hatch->angle)
      pass ("HATCH.angle [BD]");
    else
      {
        fail ("HATCH.angle [BD] %g != %g", hatch->angle, angle); error++;
      }
  }
  {
    BITCODE_B associative;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "associative", &associative, NULL) &&
        associative == hatch->associative)
      pass ("HATCH.associative [B]");
    else
      {
        fail ("HATCH.associative [B] " FORMAT_B " != " FORMAT_B "", hatch->associative, associative); error++;
      }
  }
  {
    BITCODE_H* boundary_handles;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "boundary_handles", &boundary_handles, NULL)
        && !memcmp(&boundary_handles, &hatch->boundary_handles, sizeof(hatch->boundary_handles)))
      pass ("HATCH.boundary_handles");
    else
      {
        fail ("HATCH.boundary_handles"); error++;
      }
  }
  {
    Dwg_HATCH_Color* colors;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "colors", &colors, NULL)
        && !memcmp(&colors, &hatch->colors, sizeof(hatch->colors)))
      pass ("HATCH.colors");
    else
      {
        fail ("HATCH.colors"); error++;
      }
  }
  {
    Dwg_HATCH_DefLine* deflines;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "deflines", &deflines, NULL)
        && !memcmp(&deflines, &hatch->deflines, sizeof(hatch->deflines)))
      pass ("HATCH.deflines");
    else
      {
        fail ("HATCH.deflines"); error++;
      }
  }
  {
    BITCODE_B double_flag;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "double_flag", &double_flag, NULL) &&
        double_flag == hatch->double_flag)
      pass ("HATCH.double_flag [B]");
    else
      {
        fail ("HATCH.double_flag [B] " FORMAT_B " != " FORMAT_B "", hatch->double_flag, double_flag); error++;
      }
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "elevation", &elevation, NULL) &&
        elevation == hatch->elevation)
      pass ("HATCH.elevation [BD]");
    else
      {
        fail ("HATCH.elevation [BD] %g != %g", hatch->elevation, elevation); error++;
      }
  }
  {
    BITCODE_3BD extrusion;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &hatch->extrusion, sizeof(hatch->extrusion)))
      pass ("HATCH.extrusion");
    else
      {
        fail ("HATCH.extrusion"); error++;
      }
  }
  {
    BITCODE_BD gradient_angle;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "gradient_angle", &gradient_angle, NULL) &&
        gradient_angle == hatch->gradient_angle)
      pass ("HATCH.gradient_angle [BD]");
    else
      {
        fail ("HATCH.gradient_angle [BD] %g != %g", hatch->gradient_angle, gradient_angle); error++;
      }
  }
  {
    BITCODE_TV gradient_name;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "gradient_name", &gradient_name, NULL)
        && !strcmp((char*)&gradient_name, (char*)&hatch->gradient_name))
      pass ("HATCH.gradient_name");
    else
      {
        fail ("HATCH.gradient_name"); error++;
      }
  }
  {
    BITCODE_BD gradient_shift;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "gradient_shift", &gradient_shift, NULL) &&
        gradient_shift == hatch->gradient_shift)
      pass ("HATCH.gradient_shift [BD]");
    else
      {
        fail ("HATCH.gradient_shift [BD] %g != %g", hatch->gradient_shift, gradient_shift); error++;
      }
  }
  {
    BITCODE_BD gradient_tint;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "gradient_tint", &gradient_tint, NULL) &&
        gradient_tint == hatch->gradient_tint)
      pass ("HATCH.gradient_tint [BD]");
    else
      {
        fail ("HATCH.gradient_tint [BD] %g != %g", hatch->gradient_tint, gradient_tint); error++;
      }
  }
  {
    BITCODE_B has_derived;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "has_derived", &has_derived, NULL) &&
        has_derived == hatch->has_derived)
      pass ("HATCH.has_derived [B]");
    else
      {
        fail ("HATCH.has_derived [B] " FORMAT_B " != " FORMAT_B "", hatch->has_derived, has_derived); error++;
      }
  }
  {
    BITCODE_BL is_gradient_fill;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "is_gradient_fill", &is_gradient_fill, NULL) &&
        is_gradient_fill == hatch->is_gradient_fill)
      pass ("HATCH.is_gradient_fill [BL]");
    else
      {
        fail ("HATCH.is_gradient_fill [BL] %u != %u", hatch->is_gradient_fill, is_gradient_fill); error++;
      }
  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "name", &name, NULL)
        && !strcmp((char*)&name, (char*)&hatch->name))
      pass ("HATCH.name");
    else
      {
        fail ("HATCH.name"); error++;
      }
  }
  {
    BITCODE_BL num_boundary_handles;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "num_boundary_handles", &num_boundary_handles, NULL) &&
        num_boundary_handles == hatch->num_boundary_handles)
      pass ("HATCH.num_boundary_handles [BL]");
    else
      {
        fail ("HATCH.num_boundary_handles [BL] %u != %u", hatch->num_boundary_handles, num_boundary_handles); error++;
      }
  }
  {
    BITCODE_BL num_colors;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "num_colors", &num_colors, NULL) &&
        num_colors == hatch->num_colors)
      pass ("HATCH.num_colors [BL]");
    else
      {
        fail ("HATCH.num_colors [BL] %u != %u", hatch->num_colors, num_colors); error++;
      }
  }
  {
    BITCODE_BS num_deflines;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "num_deflines", &num_deflines, NULL) &&
        num_deflines == hatch->num_deflines)
      pass ("HATCH.num_deflines [BS]");
    else
      {
        fail ("HATCH.num_deflines [BS] %d != %d", hatch->num_deflines, num_deflines); error++;
      }
  }
  {
    BITCODE_BL num_paths;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "num_paths", &num_paths, NULL) &&
        num_paths == hatch->num_paths)
      pass ("HATCH.num_paths [BL]");
    else
      {
        fail ("HATCH.num_paths [BL] %u != %u", hatch->num_paths, num_paths); error++;
      }
  }
  {
    BITCODE_BL num_seeds;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "num_seeds", &num_seeds, NULL) &&
        num_seeds == hatch->num_seeds)
      pass ("HATCH.num_seeds [BL]");
    else
      {
        fail ("HATCH.num_seeds [BL] %u != %u", hatch->num_seeds, num_seeds); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "parent", &parent, NULL)
        && !memcmp(&parent, &hatch->parent, sizeof(hatch->parent)))
      pass ("HATCH.parent");
    else
      {
        fail ("HATCH.parent"); error++;
      }
  }
  {
    Dwg_HATCH_Path* paths;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "paths", &paths, NULL)
        && !memcmp(&paths, &hatch->paths, sizeof(hatch->paths)))
      pass ("HATCH.paths");
    else
      {
        fail ("HATCH.paths"); error++;
      }
  }
  {
    BITCODE_BS pattern_type;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "pattern_type", &pattern_type, NULL) &&
        pattern_type == hatch->pattern_type)
      pass ("HATCH.pattern_type [BS]");
    else
      {
        fail ("HATCH.pattern_type [BS] %d != %d", hatch->pattern_type, pattern_type); error++;
      }
  }
  {
    BITCODE_BD pixel_size;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "pixel_size", &pixel_size, NULL) &&
        pixel_size == hatch->pixel_size)
      pass ("HATCH.pixel_size [BD]");
    else
      {
        fail ("HATCH.pixel_size [BD] %g != %g", hatch->pixel_size, pixel_size); error++;
      }
  }
  {
    BITCODE_BL reserved;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "reserved", &reserved, NULL) &&
        reserved == hatch->reserved)
      pass ("HATCH.reserved [BL]");
    else
      {
        fail ("HATCH.reserved [BL] %u != %u", hatch->reserved, reserved); error++;
      }
  }
  {
    BITCODE_BD scale_spacing;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "scale_spacing", &scale_spacing, NULL) &&
        scale_spacing == hatch->scale_spacing)
      pass ("HATCH.scale_spacing [BD]");
    else
      {
        fail ("HATCH.scale_spacing [BD] %g != %g", hatch->scale_spacing, scale_spacing); error++;
      }
  }
  {
    BITCODE_2RD * seeds;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "seeds", &seeds, NULL)
        && !memcmp(&seeds, &hatch->seeds, sizeof(hatch->seeds)))
      pass ("HATCH.seeds");
    else
      {
        fail ("HATCH.seeds"); error++;
      }
  }
  {
    BITCODE_BL single_color_gradient;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "single_color_gradient", &single_color_gradient, NULL) &&
        single_color_gradient == hatch->single_color_gradient)
      pass ("HATCH.single_color_gradient [BL]");
    else
      {
        fail ("HATCH.single_color_gradient [BL] %u != %u", hatch->single_color_gradient, single_color_gradient); error++;
      }
  }
  {
    BITCODE_B solid_fill;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "solid_fill", &solid_fill, NULL) &&
        solid_fill == hatch->solid_fill)
      pass ("HATCH.solid_fill [B]");
    else
      {
        fail ("HATCH.solid_fill [B] " FORMAT_B " != " FORMAT_B "", hatch->solid_fill, solid_fill); error++;
      }
  }
  {
    BITCODE_BS style;
    if (dwg_dynapi_entity_value(hatch, "HATCH", "style", &style, NULL) &&
        style == hatch->style)
      pass ("HATCH.style [BS]");
    else
      {
        fail ("HATCH.style [BS] %d != %d", hatch->style, style); error++;
      }
  }
  return error;
}
static int test_HELIX (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_HELIX *helix = obj->tio.entity->tio.HELIX;
  {
    BITCODE_3BD axis_base_pt;
    if (dwg_dynapi_entity_value(helix, "HELIX", "axis_base_pt", &axis_base_pt, NULL)
        && !memcmp(&axis_base_pt, &helix->axis_base_pt, sizeof(helix->axis_base_pt)))
      pass ("HELIX.axis_base_pt");
    else
      {
        fail ("HELIX.axis_base_pt"); error++;
      }
  }
  {
    BITCODE_3BD axis_vector;
    if (dwg_dynapi_entity_value(helix, "HELIX", "axis_vector", &axis_vector, NULL)
        && !memcmp(&axis_vector, &helix->axis_vector, sizeof(helix->axis_vector)))
      pass ("HELIX.axis_vector");
    else
      {
        fail ("HELIX.axis_vector"); error++;
      }
  }
  {
    BITCODE_3BD beg_tan_vec;
    if (dwg_dynapi_entity_value(helix, "HELIX", "beg_tan_vec", &beg_tan_vec, NULL)
        && !memcmp(&beg_tan_vec, &helix->beg_tan_vec, sizeof(helix->beg_tan_vec)))
      pass ("HELIX.beg_tan_vec");
    else
      {
        fail ("HELIX.beg_tan_vec"); error++;
      }
  }
  {
    BITCODE_B closed_b;
    if (dwg_dynapi_entity_value(helix, "HELIX", "closed_b", &closed_b, NULL) &&
        closed_b == helix->closed_b)
      pass ("HELIX.closed_b [B]");
    else
      {
        fail ("HELIX.closed_b [B] " FORMAT_B " != " FORMAT_B "", helix->closed_b, closed_b); error++;
      }
  }
  {
    BITCODE_BS constraint_type;
    if (dwg_dynapi_entity_value(helix, "HELIX", "constraint_type", &constraint_type, NULL) &&
        constraint_type == helix->constraint_type)
      pass ("HELIX.constraint_type [BS]");
    else
      {
        fail ("HELIX.constraint_type [BS] %d != %d", helix->constraint_type, constraint_type); error++;
      }
  }
  {
    Dwg_SPLINE_control_point* ctrl_pts;
    if (dwg_dynapi_entity_value(helix, "HELIX", "ctrl_pts", &ctrl_pts, NULL)
        && !memcmp(&ctrl_pts, &helix->ctrl_pts, sizeof(helix->ctrl_pts)))
      pass ("HELIX.ctrl_pts");
    else
      {
        fail ("HELIX.ctrl_pts"); error++;
      }
  }
  {
    BITCODE_BD ctrl_tol;
    if (dwg_dynapi_entity_value(helix, "HELIX", "ctrl_tol", &ctrl_tol, NULL) &&
        ctrl_tol == helix->ctrl_tol)
      pass ("HELIX.ctrl_tol [BD]");
    else
      {
        fail ("HELIX.ctrl_tol [BD] %g != %g", helix->ctrl_tol, ctrl_tol); error++;
      }
  }
  {
    BITCODE_BS degree;
    if (dwg_dynapi_entity_value(helix, "HELIX", "degree", &degree, NULL) &&
        degree == helix->degree)
      pass ("HELIX.degree [BS]");
    else
      {
        fail ("HELIX.degree [BS] %d != %d", helix->degree, degree); error++;
      }
  }
  {
    BITCODE_3BD end_tan_vec;
    if (dwg_dynapi_entity_value(helix, "HELIX", "end_tan_vec", &end_tan_vec, NULL)
        && !memcmp(&end_tan_vec, &helix->end_tan_vec, sizeof(helix->end_tan_vec)))
      pass ("HELIX.end_tan_vec");
    else
      {
        fail ("HELIX.end_tan_vec"); error++;
      }
  }
  {
    Dwg_SPLINE_point* fit_pts;
    if (dwg_dynapi_entity_value(helix, "HELIX", "fit_pts", &fit_pts, NULL)
        && !memcmp(&fit_pts, &helix->fit_pts, sizeof(helix->fit_pts)))
      pass ("HELIX.fit_pts");
    else
      {
        fail ("HELIX.fit_pts"); error++;
      }
  }
  {
    BITCODE_BD fit_tol;
    if (dwg_dynapi_entity_value(helix, "HELIX", "fit_tol", &fit_tol, NULL) &&
        fit_tol == helix->fit_tol)
      pass ("HELIX.fit_tol [BD]");
    else
      {
        fail ("HELIX.fit_tol [BD] %g != %g", helix->fit_tol, fit_tol); error++;
      }
  }
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value(helix, "HELIX", "flag", &flag, NULL) &&
        flag == helix->flag)
      pass ("HELIX.flag [BS]");
    else
      {
        fail ("HELIX.flag [BS] %d != %d", helix->flag, flag); error++;
      }
  }
  {
    BITCODE_B handedness;
    if (dwg_dynapi_entity_value(helix, "HELIX", "handedness", &handedness, NULL) &&
        handedness == helix->handedness)
      pass ("HELIX.handedness [B]");
    else
      {
        fail ("HELIX.handedness [B] " FORMAT_B " != " FORMAT_B "", helix->handedness, handedness); error++;
      }
  }
  {
    BITCODE_BD knot_tol;
    if (dwg_dynapi_entity_value(helix, "HELIX", "knot_tol", &knot_tol, NULL) &&
        knot_tol == helix->knot_tol)
      pass ("HELIX.knot_tol [BD]");
    else
      {
        fail ("HELIX.knot_tol [BD] %g != %g", helix->knot_tol, knot_tol); error++;
      }
  }
  {
    BITCODE_BL knotparam;
    if (dwg_dynapi_entity_value(helix, "HELIX", "knotparam", &knotparam, NULL) &&
        knotparam == helix->knotparam)
      pass ("HELIX.knotparam [BL]");
    else
      {
        fail ("HELIX.knotparam [BL] %u != %u", helix->knotparam, knotparam); error++;
      }
  }
  {
    BITCODE_BD* knots;
    if (dwg_dynapi_entity_value(helix, "HELIX", "knots", &knots, NULL)
        && !memcmp(&knots, &helix->knots, sizeof(helix->knots)))
      pass ("HELIX.knots");
    else
      {
        fail ("HELIX.knots"); error++;
      }
  }
  {
    BITCODE_BS maint_version;
    if (dwg_dynapi_entity_value(helix, "HELIX", "maint_version", &maint_version, NULL) &&
        maint_version == helix->maint_version)
      pass ("HELIX.maint_version [BS]");
    else
      {
        fail ("HELIX.maint_version [BS] %d != %d", helix->maint_version, maint_version); error++;
      }
  }
  {
    BITCODE_BS major_version;
    if (dwg_dynapi_entity_value(helix, "HELIX", "major_version", &major_version, NULL) &&
        major_version == helix->major_version)
      pass ("HELIX.major_version [BS]");
    else
      {
        fail ("HELIX.major_version [BS] %d != %d", helix->major_version, major_version); error++;
      }
  }
  {
    BITCODE_BL num_ctrl_pts;
    if (dwg_dynapi_entity_value(helix, "HELIX", "num_ctrl_pts", &num_ctrl_pts, NULL) &&
        num_ctrl_pts == helix->num_ctrl_pts)
      pass ("HELIX.num_ctrl_pts [BL]");
    else
      {
        fail ("HELIX.num_ctrl_pts [BL] %u != %u", helix->num_ctrl_pts, num_ctrl_pts); error++;
      }
  }
  {
    BITCODE_BS num_fit_pts;
    if (dwg_dynapi_entity_value(helix, "HELIX", "num_fit_pts", &num_fit_pts, NULL) &&
        num_fit_pts == helix->num_fit_pts)
      pass ("HELIX.num_fit_pts [BS]");
    else
      {
        fail ("HELIX.num_fit_pts [BS] %d != %d", helix->num_fit_pts, num_fit_pts); error++;
      }
  }
  {
    BITCODE_BL num_knots;
    if (dwg_dynapi_entity_value(helix, "HELIX", "num_knots", &num_knots, NULL) &&
        num_knots == helix->num_knots)
      pass ("HELIX.num_knots [BL]");
    else
      {
        fail ("HELIX.num_knots [BL] %u != %u", helix->num_knots, num_knots); error++;
      }
  }
  {
    BITCODE_BD num_turns;
    if (dwg_dynapi_entity_value(helix, "HELIX", "num_turns", &num_turns, NULL) &&
        num_turns == helix->num_turns)
      pass ("HELIX.num_turns [BD]");
    else
      {
        fail ("HELIX.num_turns [BD] %g != %g", helix->num_turns, num_turns); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(helix, "HELIX", "parent", &parent, NULL)
        && !memcmp(&parent, &helix->parent, sizeof(helix->parent)))
      pass ("HELIX.parent");
    else
      {
        fail ("HELIX.parent"); error++;
      }
  }
  {
    BITCODE_B periodic;
    if (dwg_dynapi_entity_value(helix, "HELIX", "periodic", &periodic, NULL) &&
        periodic == helix->periodic)
      pass ("HELIX.periodic [B]");
    else
      {
        fail ("HELIX.periodic [B] " FORMAT_B " != " FORMAT_B "", helix->periodic, periodic); error++;
      }
  }
  {
    BITCODE_BD radius;
    if (dwg_dynapi_entity_value(helix, "HELIX", "radius", &radius, NULL) &&
        radius == helix->radius)
      pass ("HELIX.radius [BD]");
    else
      {
        fail ("HELIX.radius [BD] %g != %g", helix->radius, radius); error++;
      }
  }
  {
    BITCODE_B rational;
    if (dwg_dynapi_entity_value(helix, "HELIX", "rational", &rational, NULL) &&
        rational == helix->rational)
      pass ("HELIX.rational [B]");
    else
      {
        fail ("HELIX.rational [B] " FORMAT_B " != " FORMAT_B "", helix->rational, rational); error++;
      }
  }
  {
    BITCODE_BS scenario;
    if (dwg_dynapi_entity_value(helix, "HELIX", "scenario", &scenario, NULL) &&
        scenario == helix->scenario)
      pass ("HELIX.scenario [BS]");
    else
      {
        fail ("HELIX.scenario [BS] %d != %d", helix->scenario, scenario); error++;
      }
  }
  {
    BITCODE_BL splineflags1;
    if (dwg_dynapi_entity_value(helix, "HELIX", "splineflags1", &splineflags1, NULL) &&
        splineflags1 == helix->splineflags1)
      pass ("HELIX.splineflags1 [BL]");
    else
      {
        fail ("HELIX.splineflags1 [BL] %u != %u", helix->splineflags1, splineflags1); error++;
      }
  }
  {
    BITCODE_3BD start_pt;
    if (dwg_dynapi_entity_value(helix, "HELIX", "start_pt", &start_pt, NULL)
        && !memcmp(&start_pt, &helix->start_pt, sizeof(helix->start_pt)))
      pass ("HELIX.start_pt");
    else
      {
        fail ("HELIX.start_pt"); error++;
      }
  }
  {
    BITCODE_BD turn_height;
    if (dwg_dynapi_entity_value(helix, "HELIX", "turn_height", &turn_height, NULL) &&
        turn_height == helix->turn_height)
      pass ("HELIX.turn_height [BD]");
    else
      {
        fail ("HELIX.turn_height [BD] %g != %g", helix->turn_height, turn_height); error++;
      }
  }
  {
    BITCODE_B weighted;
    if (dwg_dynapi_entity_value(helix, "HELIX", "weighted", &weighted, NULL) &&
        weighted == helix->weighted)
      pass ("HELIX.weighted [B]");
    else
      {
        fail ("HELIX.weighted [B] " FORMAT_B " != " FORMAT_B "", helix->weighted, weighted); error++;
      }
  }
  return error;
}
static int test_IMAGE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_IMAGE *image = obj->tio.entity->tio.IMAGE;
  {
    BITCODE_2RD boundary_pt0;
    if (dwg_dynapi_entity_value(image, "IMAGE", "boundary_pt0", &boundary_pt0, NULL)
        && !memcmp(&boundary_pt0, &image->boundary_pt0, sizeof(image->boundary_pt0)))
      pass ("IMAGE.boundary_pt0");
    else
      {
        fail ("IMAGE.boundary_pt0"); error++;
      }
  }
  {
    BITCODE_2RD boundary_pt1;
    if (dwg_dynapi_entity_value(image, "IMAGE", "boundary_pt1", &boundary_pt1, NULL)
        && !memcmp(&boundary_pt1, &image->boundary_pt1, sizeof(image->boundary_pt1)))
      pass ("IMAGE.boundary_pt1");
    else
      {
        fail ("IMAGE.boundary_pt1"); error++;
      }
  }
  {
    BITCODE_RC brightness;
    if (dwg_dynapi_entity_value(image, "IMAGE", "brightness", &brightness, NULL) &&
        brightness == image->brightness)
      pass ("IMAGE.brightness [RC]");
    else
      {
        fail ("IMAGE.brightness [RC] %c != %c", image->brightness, brightness); error++;
      }
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value(image, "IMAGE", "class_version", &class_version, NULL) &&
        class_version == image->class_version)
      pass ("IMAGE.class_version [BL]");
    else
      {
        fail ("IMAGE.class_version [BL] %u != %u", image->class_version, class_version); error++;
      }
  }
  {
    BITCODE_BS clip_boundary_type;
    if (dwg_dynapi_entity_value(image, "IMAGE", "clip_boundary_type", &clip_boundary_type, NULL) &&
        clip_boundary_type == image->clip_boundary_type)
      pass ("IMAGE.clip_boundary_type [BS]");
    else
      {
        fail ("IMAGE.clip_boundary_type [BS] %d != %d", image->clip_boundary_type, clip_boundary_type); error++;
      }
  }
  {
    BITCODE_B clip_mode;
    if (dwg_dynapi_entity_value(image, "IMAGE", "clip_mode", &clip_mode, NULL) &&
        clip_mode == image->clip_mode)
      pass ("IMAGE.clip_mode [B]");
    else
      {
        fail ("IMAGE.clip_mode [B] " FORMAT_B " != " FORMAT_B "", image->clip_mode, clip_mode); error++;
      }
  }
  {
    BITCODE_2RD* clip_verts;
    if (dwg_dynapi_entity_value(image, "IMAGE", "clip_verts", &clip_verts, NULL)
        && !memcmp(&clip_verts, &image->clip_verts, sizeof(image->clip_verts)))
      pass ("IMAGE.clip_verts");
    else
      {
        fail ("IMAGE.clip_verts"); error++;
      }
  }
  {
    BITCODE_B clipping;
    if (dwg_dynapi_entity_value(image, "IMAGE", "clipping", &clipping, NULL) &&
        clipping == image->clipping)
      pass ("IMAGE.clipping [B]");
    else
      {
        fail ("IMAGE.clipping [B] " FORMAT_B " != " FORMAT_B "", image->clipping, clipping); error++;
      }
  }
  {
    BITCODE_RC contrast;
    if (dwg_dynapi_entity_value(image, "IMAGE", "contrast", &contrast, NULL) &&
        contrast == image->contrast)
      pass ("IMAGE.contrast [RC]");
    else
      {
        fail ("IMAGE.contrast [RC] %c != %c", image->contrast, contrast); error++;
      }
  }
  {
    BITCODE_BS display_props;
    if (dwg_dynapi_entity_value(image, "IMAGE", "display_props", &display_props, NULL) &&
        display_props == image->display_props)
      pass ("IMAGE.display_props [BS]");
    else
      {
        fail ("IMAGE.display_props [BS] %d != %d", image->display_props, display_props); error++;
      }
  }
  {
    BITCODE_RC fade;
    if (dwg_dynapi_entity_value(image, "IMAGE", "fade", &fade, NULL) &&
        fade == image->fade)
      pass ("IMAGE.fade [RC]");
    else
      {
        fail ("IMAGE.fade [RC] %c != %c", image->fade, fade); error++;
      }
  }
  {
    BITCODE_H imagedef;
    if (dwg_dynapi_entity_value(image, "IMAGE", "imagedef", &imagedef, NULL) &&
        imagedef == image->imagedef)
      pass ("IMAGE.imagedef [H]");
    else
      {
        fail ("IMAGE.imagedef [H] %p != %p", image->imagedef, imagedef); error++;
      }
  }
  {
    BITCODE_H imagedefreactor;
    if (dwg_dynapi_entity_value(image, "IMAGE", "imagedefreactor", &imagedefreactor, NULL) &&
        imagedefreactor == image->imagedefreactor)
      pass ("IMAGE.imagedefreactor [H]");
    else
      {
        fail ("IMAGE.imagedefreactor [H] %p != %p", image->imagedefreactor, imagedefreactor); error++;
      }
  }
  {
    BITCODE_BL num_clip_verts;
    if (dwg_dynapi_entity_value(image, "IMAGE", "num_clip_verts", &num_clip_verts, NULL) &&
        num_clip_verts == image->num_clip_verts)
      pass ("IMAGE.num_clip_verts [BL]");
    else
      {
        fail ("IMAGE.num_clip_verts [BL] %u != %u", image->num_clip_verts, num_clip_verts); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(image, "IMAGE", "parent", &parent, NULL)
        && !memcmp(&parent, &image->parent, sizeof(image->parent)))
      pass ("IMAGE.parent");
    else
      {
        fail ("IMAGE.parent"); error++;
      }
  }
  {
    BITCODE_3BD pt0;
    if (dwg_dynapi_entity_value(image, "IMAGE", "pt0", &pt0, NULL)
        && !memcmp(&pt0, &image->pt0, sizeof(image->pt0)))
      pass ("IMAGE.pt0");
    else
      {
        fail ("IMAGE.pt0"); error++;
      }
  }
  {
    Dwg_Bitcode_2RD size;
    if (dwg_dynapi_entity_value(image, "IMAGE", "size", &size, NULL)
        && !memcmp(&size, &image->size, sizeof(image->size)))
      pass ("IMAGE.size");
    else
      {
        fail ("IMAGE.size"); error++;
      }
  }
  {
    BITCODE_3BD uvec;
    if (dwg_dynapi_entity_value(image, "IMAGE", "uvec", &uvec, NULL)
        && !memcmp(&uvec, &image->uvec, sizeof(image->uvec)))
      pass ("IMAGE.uvec");
    else
      {
        fail ("IMAGE.uvec"); error++;
      }
  }
  {
    BITCODE_3BD vvec;
    if (dwg_dynapi_entity_value(image, "IMAGE", "vvec", &vvec, NULL)
        && !memcmp(&vvec, &image->vvec, sizeof(image->vvec)))
      pass ("IMAGE.vvec");
    else
      {
        fail ("IMAGE.vvec"); error++;
      }
  }
  return error;
}
static int test_INSERT (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_INSERT *insert = obj->tio.entity->tio.INSERT;
  {
    BITCODE_H* attrib_handles;
    if (dwg_dynapi_entity_value(insert, "INSERT", "attrib_handles", &attrib_handles, NULL)
        && !memcmp(&attrib_handles, &insert->attrib_handles, sizeof(insert->attrib_handles)))
      pass ("INSERT.attrib_handles");
    else
      {
        fail ("INSERT.attrib_handles"); error++;
      }
  }
  {
    BITCODE_H  block_header;
    if (dwg_dynapi_entity_value(insert, "INSERT", "block_header", &block_header, NULL) &&
        block_header == insert->block_header)
      pass ("INSERT.block_header [H ]");
    else
      {
        fail ("INSERT.block_header [H ] %p != %p", insert->block_header, block_header); error++;
      }
  }
  {
    BITCODE_3DPOINT  extrusion;
    if (dwg_dynapi_entity_value(insert, "INSERT", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &insert->extrusion, sizeof(insert->extrusion)))
      pass ("INSERT.extrusion");
    else
      {
        fail ("INSERT.extrusion"); error++;
      }
  }
  {
    BITCODE_H  first_attrib;
    if (dwg_dynapi_entity_value(insert, "INSERT", "first_attrib", &first_attrib, NULL) &&
        first_attrib == insert->first_attrib)
      pass ("INSERT.first_attrib [H ]");
    else
      {
        fail ("INSERT.first_attrib [H ] %p != %p", insert->first_attrib, first_attrib); error++;
      }
  }
  {
    BITCODE_B        has_attribs;
    if (dwg_dynapi_entity_value(insert, "INSERT", "has_attribs", &has_attribs, NULL) &&
        has_attribs == insert->has_attribs)
      pass ("INSERT.has_attribs [B       ]");
    else
      {
        fail ("INSERT.has_attribs [B       ] %p != %p", insert->has_attribs, has_attribs); error++;
      }
  }
  {
    BITCODE_3DPOINT  ins_pt;
    if (dwg_dynapi_entity_value(insert, "INSERT", "ins_pt", &ins_pt, NULL)
        && !memcmp(&ins_pt, &insert->ins_pt, sizeof(insert->ins_pt)))
      pass ("INSERT.ins_pt");
    else
      {
        fail ("INSERT.ins_pt"); error++;
      }
  }
  {
    BITCODE_H  last_attrib;
    if (dwg_dynapi_entity_value(insert, "INSERT", "last_attrib", &last_attrib, NULL) &&
        last_attrib == insert->last_attrib)
      pass ("INSERT.last_attrib [H ]");
    else
      {
        fail ("INSERT.last_attrib [H ] %p != %p", insert->last_attrib, last_attrib); error++;
      }
  }
  {
    BITCODE_BL       num_owned;
    if (dwg_dynapi_entity_value(insert, "INSERT", "num_owned", &num_owned, NULL) &&
        num_owned == insert->num_owned)
      pass ("INSERT.num_owned [BL      ]");
    else
      {
        fail ("INSERT.num_owned [BL      ] %p != %p", insert->num_owned, num_owned); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(insert, "INSERT", "parent", &parent, NULL)
        && !memcmp(&parent, &insert->parent, sizeof(insert->parent)))
      pass ("INSERT.parent");
    else
      {
        fail ("INSERT.parent"); error++;
      }
  }
  {
    BITCODE_BD       rotation;
    if (dwg_dynapi_entity_value(insert, "INSERT", "rotation", &rotation, NULL) &&
        rotation == insert->rotation)
      pass ("INSERT.rotation [BD      ]");
    else
      {
        fail ("INSERT.rotation [BD      ] %p != %p", insert->rotation, rotation); error++;
      }
  }
  {
    BITCODE_3DPOINT  scale;
    if (dwg_dynapi_entity_value(insert, "INSERT", "scale", &scale, NULL)
        && !memcmp(&scale, &insert->scale, sizeof(insert->scale)))
      pass ("INSERT.scale");
    else
      {
        fail ("INSERT.scale"); error++;
      }
  }
  {
    BITCODE_BB       scale_flag;
    if (dwg_dynapi_entity_value(insert, "INSERT", "scale_flag", &scale_flag, NULL) &&
        scale_flag == insert->scale_flag)
      pass ("INSERT.scale_flag [BB      ]");
    else
      {
        fail ("INSERT.scale_flag [BB      ] %p != %p", insert->scale_flag, scale_flag); error++;
      }
  }
  {
    BITCODE_H  seqend;
    if (dwg_dynapi_entity_value(insert, "INSERT", "seqend", &seqend, NULL) &&
        seqend == insert->seqend)
      pass ("INSERT.seqend [H ]");
    else
      {
        fail ("INSERT.seqend [H ] %p != %p", insert->seqend, seqend); error++;
      }
  }
  return error;
}
static int test_LEADER (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_LEADER *leader = obj->tio.entity->tio.LEADER;
  {
    BITCODE_BS annot_type;
    if (dwg_dynapi_entity_value(leader, "LEADER", "annot_type", &annot_type, NULL) &&
        annot_type == leader->annot_type)
      pass ("LEADER.annot_type [BS]");
    else
      {
        fail ("LEADER.annot_type [BS] %d != %d", leader->annot_type, annot_type); error++;
      }
  }
  {
    BITCODE_B arrowhead_on;
    if (dwg_dynapi_entity_value(leader, "LEADER", "arrowhead_on", &arrowhead_on, NULL) &&
        arrowhead_on == leader->arrowhead_on)
      pass ("LEADER.arrowhead_on [B]");
    else
      {
        fail ("LEADER.arrowhead_on [B] " FORMAT_B " != " FORMAT_B "", leader->arrowhead_on, arrowhead_on); error++;
      }
  }
  {
    BITCODE_BS arrowhead_type;
    if (dwg_dynapi_entity_value(leader, "LEADER", "arrowhead_type", &arrowhead_type, NULL) &&
        arrowhead_type == leader->arrowhead_type)
      pass ("LEADER.arrowhead_type [BS]");
    else
      {
        fail ("LEADER.arrowhead_type [BS] %d != %d", leader->arrowhead_type, arrowhead_type); error++;
      }
  }
  {
    BITCODE_H associated_annotation;
    if (dwg_dynapi_entity_value(leader, "LEADER", "associated_annotation", &associated_annotation, NULL) &&
        associated_annotation == leader->associated_annotation)
      pass ("LEADER.associated_annotation [H]");
    else
      {
        fail ("LEADER.associated_annotation [H] %p != %p", leader->associated_annotation, associated_annotation); error++;
      }
  }
  {
    BITCODE_BD box_height;
    if (dwg_dynapi_entity_value(leader, "LEADER", "box_height", &box_height, NULL) &&
        box_height == leader->box_height)
      pass ("LEADER.box_height [BD]");
    else
      {
        fail ("LEADER.box_height [BD] %g != %g", leader->box_height, box_height); error++;
      }
  }
  {
    BITCODE_BD box_width;
    if (dwg_dynapi_entity_value(leader, "LEADER", "box_width", &box_width, NULL) &&
        box_width == leader->box_width)
      pass ("LEADER.box_width [BD]");
    else
      {
        fail ("LEADER.box_width [BD] %g != %g", leader->box_width, box_width); error++;
      }
  }
  {
    BITCODE_BS byblock_color;
    if (dwg_dynapi_entity_value(leader, "LEADER", "byblock_color", &byblock_color, NULL) &&
        byblock_color == leader->byblock_color)
      pass ("LEADER.byblock_color [BS]");
    else
      {
        fail ("LEADER.byblock_color [BS] %d != %d", leader->byblock_color, byblock_color); error++;
      }
  }
  {
    BITCODE_BD dimasz;
    if (dwg_dynapi_entity_value(leader, "LEADER", "dimasz", &dimasz, NULL) &&
        dimasz == leader->dimasz)
      pass ("LEADER.dimasz [BD]");
    else
      {
        fail ("LEADER.dimasz [BD] %g != %g", leader->dimasz, dimasz); error++;
      }
  }
  {
    BITCODE_BD dimgap;
    if (dwg_dynapi_entity_value(leader, "LEADER", "dimgap", &dimgap, NULL) &&
        dimgap == leader->dimgap)
      pass ("LEADER.dimgap [BD]");
    else
      {
        fail ("LEADER.dimgap [BD] %g != %g", leader->dimgap, dimgap); error++;
      }
  }
  {
    BITCODE_H dimstyle;
    if (dwg_dynapi_entity_value(leader, "LEADER", "dimstyle", &dimstyle, NULL) &&
        dimstyle == leader->dimstyle)
      pass ("LEADER.dimstyle [H]");
    else
      {
        fail ("LEADER.dimstyle [H] %p != %p", leader->dimstyle, dimstyle); error++;
      }
  }
  {
    BITCODE_3DPOINT endptproj;
    if (dwg_dynapi_entity_value(leader, "LEADER", "endptproj", &endptproj, NULL)
        && !memcmp(&endptproj, &leader->endptproj, sizeof(leader->endptproj)))
      pass ("LEADER.endptproj");
    else
      {
        fail ("LEADER.endptproj"); error++;
      }
  }
  {
    BITCODE_3DPOINT extrusion;
    if (dwg_dynapi_entity_value(leader, "LEADER", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &leader->extrusion, sizeof(leader->extrusion)))
      pass ("LEADER.extrusion");
    else
      {
        fail ("LEADER.extrusion"); error++;
      }
  }
  {
    BITCODE_B hookline_dir;
    if (dwg_dynapi_entity_value(leader, "LEADER", "hookline_dir", &hookline_dir, NULL) &&
        hookline_dir == leader->hookline_dir)
      pass ("LEADER.hookline_dir [B]");
    else
      {
        fail ("LEADER.hookline_dir [B] " FORMAT_B " != " FORMAT_B "", leader->hookline_dir, hookline_dir); error++;
      }
  }
  {
    BITCODE_B hookline_on;
    if (dwg_dynapi_entity_value(leader, "LEADER", "hookline_on", &hookline_on, NULL) &&
        hookline_on == leader->hookline_on)
      pass ("LEADER.hookline_on [B]");
    else
      {
        fail ("LEADER.hookline_on [B] " FORMAT_B " != " FORMAT_B "", leader->hookline_on, hookline_on); error++;
      }
  }
  {
    BITCODE_BL numpts;
    if (dwg_dynapi_entity_value(leader, "LEADER", "numpts", &numpts, NULL) &&
        numpts == leader->numpts)
      pass ("LEADER.numpts [BL]");
    else
      {
        fail ("LEADER.numpts [BL] %u != %u", leader->numpts, numpts); error++;
      }
  }
  {
    BITCODE_3DPOINT offset_to_block_ins_pt;
    if (dwg_dynapi_entity_value(leader, "LEADER", "offset_to_block_ins_pt", &offset_to_block_ins_pt, NULL)
        && !memcmp(&offset_to_block_ins_pt, &leader->offset_to_block_ins_pt, sizeof(leader->offset_to_block_ins_pt)))
      pass ("LEADER.offset_to_block_ins_pt");
    else
      {
        fail ("LEADER.offset_to_block_ins_pt"); error++;
      }
  }
  {
    BITCODE_3DPOINT origin;
    if (dwg_dynapi_entity_value(leader, "LEADER", "origin", &origin, NULL)
        && !memcmp(&origin, &leader->origin, sizeof(leader->origin)))
      pass ("LEADER.origin");
    else
      {
        fail ("LEADER.origin"); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(leader, "LEADER", "parent", &parent, NULL)
        && !memcmp(&parent, &leader->parent, sizeof(leader->parent)))
      pass ("LEADER.parent");
    else
      {
        fail ("LEADER.parent"); error++;
      }
  }
  {
    BITCODE_BS path_type;
    if (dwg_dynapi_entity_value(leader, "LEADER", "path_type", &path_type, NULL) &&
        path_type == leader->path_type)
      pass ("LEADER.path_type [BS]");
    else
      {
        fail ("LEADER.path_type [BS] %d != %d", leader->path_type, path_type); error++;
      }
  }
  {
    BITCODE_3DPOINT* points;
    if (dwg_dynapi_entity_value(leader, "LEADER", "points", &points, NULL)
        && !memcmp(&points, &leader->points, sizeof(leader->points)))
      pass ("LEADER.points");
    else
      {
        fail ("LEADER.points"); error++;
      }
  }
  {
    BITCODE_B unknown_bit_1;
    if (dwg_dynapi_entity_value(leader, "LEADER", "unknown_bit_1", &unknown_bit_1, NULL) &&
        unknown_bit_1 == leader->unknown_bit_1)
      pass ("LEADER.unknown_bit_1 [B]");
    else
      {
        fail ("LEADER.unknown_bit_1 [B] " FORMAT_B " != " FORMAT_B "", leader->unknown_bit_1, unknown_bit_1); error++;
      }
  }
  {
    BITCODE_B unknown_bit_2;
    if (dwg_dynapi_entity_value(leader, "LEADER", "unknown_bit_2", &unknown_bit_2, NULL) &&
        unknown_bit_2 == leader->unknown_bit_2)
      pass ("LEADER.unknown_bit_2 [B]");
    else
      {
        fail ("LEADER.unknown_bit_2 [B] " FORMAT_B " != " FORMAT_B "", leader->unknown_bit_2, unknown_bit_2); error++;
      }
  }
  {
    BITCODE_B unknown_bit_3;
    if (dwg_dynapi_entity_value(leader, "LEADER", "unknown_bit_3", &unknown_bit_3, NULL) &&
        unknown_bit_3 == leader->unknown_bit_3)
      pass ("LEADER.unknown_bit_3 [B]");
    else
      {
        fail ("LEADER.unknown_bit_3 [B] " FORMAT_B " != " FORMAT_B "", leader->unknown_bit_3, unknown_bit_3); error++;
      }
  }
  {
    BITCODE_B unknown_bit_5;
    if (dwg_dynapi_entity_value(leader, "LEADER", "unknown_bit_5", &unknown_bit_5, NULL) &&
        unknown_bit_5 == leader->unknown_bit_5)
      pass ("LEADER.unknown_bit_5 [B]");
    else
      {
        fail ("LEADER.unknown_bit_5 [B] " FORMAT_B " != " FORMAT_B "", leader->unknown_bit_5, unknown_bit_5); error++;
      }
  }
  {
    BITCODE_BS unknown_short_1;
    if (dwg_dynapi_entity_value(leader, "LEADER", "unknown_short_1", &unknown_short_1, NULL) &&
        unknown_short_1 == leader->unknown_short_1)
      pass ("LEADER.unknown_short_1 [BS]");
    else
      {
        fail ("LEADER.unknown_short_1 [BS] %d != %d", leader->unknown_short_1, unknown_short_1); error++;
      }
  }
  {
    BITCODE_3DPOINT x_direction;
    if (dwg_dynapi_entity_value(leader, "LEADER", "x_direction", &x_direction, NULL)
        && !memcmp(&x_direction, &leader->x_direction, sizeof(leader->x_direction)))
      pass ("LEADER.x_direction");
    else
      {
        fail ("LEADER.x_direction"); error++;
      }
  }
  return error;
}
static int test_LIGHT (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_LIGHT *light = obj->tio.entity->tio.LIGHT;
  {
    BITCODE_BD attenuation_end_limit;
    if (dwg_dynapi_entity_value(light, "LIGHT", "attenuation_end_limit", &attenuation_end_limit, NULL) &&
        attenuation_end_limit == light->attenuation_end_limit)
      pass ("LIGHT.attenuation_end_limit [BD]");
    else
      {
        fail ("LIGHT.attenuation_end_limit [BD] %g != %g", light->attenuation_end_limit, attenuation_end_limit); error++;
      }
  }
  {
    BITCODE_BD attenuation_start_limit;
    if (dwg_dynapi_entity_value(light, "LIGHT", "attenuation_start_limit", &attenuation_start_limit, NULL) &&
        attenuation_start_limit == light->attenuation_start_limit)
      pass ("LIGHT.attenuation_start_limit [BD]");
    else
      {
        fail ("LIGHT.attenuation_start_limit [BD] %g != %g", light->attenuation_start_limit, attenuation_start_limit); error++;
      }
  }
  {
    BITCODE_BS attenuation_type;
    if (dwg_dynapi_entity_value(light, "LIGHT", "attenuation_type", &attenuation_type, NULL) &&
        attenuation_type == light->attenuation_type)
      pass ("LIGHT.attenuation_type [BS]");
    else
      {
        fail ("LIGHT.attenuation_type [BS] %d != %d", light->attenuation_type, attenuation_type); error++;
      }
  }
  {
    BITCODE_B cast_shadows;
    if (dwg_dynapi_entity_value(light, "LIGHT", "cast_shadows", &cast_shadows, NULL) &&
        cast_shadows == light->cast_shadows)
      pass ("LIGHT.cast_shadows [B]");
    else
      {
        fail ("LIGHT.cast_shadows [B] " FORMAT_B " != " FORMAT_B "", light->cast_shadows, cast_shadows); error++;
      }
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value(light, "LIGHT", "class_version", &class_version, NULL) &&
        class_version == light->class_version)
      pass ("LIGHT.class_version [BL]");
    else
      {
        fail ("LIGHT.class_version [BL] %u != %u", light->class_version, class_version); error++;
      }
  }
  {
    BITCODE_CMC color;
    if (dwg_dynapi_entity_value(light, "LIGHT", "color", &color, NULL)
        && !memcmp(&color, &light->color, sizeof(light->color)))
      pass ("LIGHT.color");
    else
      {
        fail ("LIGHT.color"); error++;
      }
  }
  {
    BITCODE_BD falloff_angle;
    if (dwg_dynapi_entity_value(light, "LIGHT", "falloff_angle", &falloff_angle, NULL) &&
        falloff_angle == light->falloff_angle)
      pass ("LIGHT.falloff_angle [BD]");
    else
      {
        fail ("LIGHT.falloff_angle [BD] %g != %g", light->falloff_angle, falloff_angle); error++;
      }
  }
  {
    BITCODE_BD hotspot_angle;
    if (dwg_dynapi_entity_value(light, "LIGHT", "hotspot_angle", &hotspot_angle, NULL) &&
        hotspot_angle == light->hotspot_angle)
      pass ("LIGHT.hotspot_angle [BD]");
    else
      {
        fail ("LIGHT.hotspot_angle [BD] %g != %g", light->hotspot_angle, hotspot_angle); error++;
      }
  }
  {
    BITCODE_BD intensity;
    if (dwg_dynapi_entity_value(light, "LIGHT", "intensity", &intensity, NULL) &&
        intensity == light->intensity)
      pass ("LIGHT.intensity [BD]");
    else
      {
        fail ("LIGHT.intensity [BD] %g != %g", light->intensity, intensity); error++;
      }
  }
  {
    BITCODE_H lights_layer;
    if (dwg_dynapi_entity_value(light, "LIGHT", "lights_layer", &lights_layer, NULL) &&
        lights_layer == light->lights_layer)
      pass ("LIGHT.lights_layer [H]");
    else
      {
        fail ("LIGHT.lights_layer [H] %p != %p", light->lights_layer, lights_layer); error++;
      }
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value(light, "LIGHT", "name", &name, NULL)
        && !memcmp(&name, &light->name, sizeof(light->name)))
      pass ("LIGHT.name");
    else
      {
        fail ("LIGHT.name"); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(light, "LIGHT", "parent", &parent, NULL)
        && !memcmp(&parent, &light->parent, sizeof(light->parent)))
      pass ("LIGHT.parent");
    else
      {
        fail ("LIGHT.parent"); error++;
      }
  }
  {
    BITCODE_B plot_glyph;
    if (dwg_dynapi_entity_value(light, "LIGHT", "plot_glyph", &plot_glyph, NULL) &&
        plot_glyph == light->plot_glyph)
      pass ("LIGHT.plot_glyph [B]");
    else
      {
        fail ("LIGHT.plot_glyph [B] " FORMAT_B " != " FORMAT_B "", light->plot_glyph, plot_glyph); error++;
      }
  }
  {
    BITCODE_3BD position;
    if (dwg_dynapi_entity_value(light, "LIGHT", "position", &position, NULL)
        && !memcmp(&position, &light->position, sizeof(light->position)))
      pass ("LIGHT.position");
    else
      {
        fail ("LIGHT.position"); error++;
      }
  }
  {
    BITCODE_BS shadow_map_size;
    if (dwg_dynapi_entity_value(light, "LIGHT", "shadow_map_size", &shadow_map_size, NULL) &&
        shadow_map_size == light->shadow_map_size)
      pass ("LIGHT.shadow_map_size [BS]");
    else
      {
        fail ("LIGHT.shadow_map_size [BS] %d != %d", light->shadow_map_size, shadow_map_size); error++;
      }
  }
  {
    BITCODE_RC shadow_map_softness;
    if (dwg_dynapi_entity_value(light, "LIGHT", "shadow_map_softness", &shadow_map_softness, NULL) &&
        shadow_map_softness == light->shadow_map_softness)
      pass ("LIGHT.shadow_map_softness [RC]");
    else
      {
        fail ("LIGHT.shadow_map_softness [RC] %c != %c", light->shadow_map_softness, shadow_map_softness); error++;
      }
  }
  {
    BITCODE_BS shadow_type;
    if (dwg_dynapi_entity_value(light, "LIGHT", "shadow_type", &shadow_type, NULL) &&
        shadow_type == light->shadow_type)
      pass ("LIGHT.shadow_type [BS]");
    else
      {
        fail ("LIGHT.shadow_type [BS] %d != %d", light->shadow_type, shadow_type); error++;
      }
  }
  {
    BITCODE_B status;
    if (dwg_dynapi_entity_value(light, "LIGHT", "status", &status, NULL) &&
        status == light->status)
      pass ("LIGHT.status [B]");
    else
      {
        fail ("LIGHT.status [B] " FORMAT_B " != " FORMAT_B "", light->status, status); error++;
      }
  }
  {
    BITCODE_3BD target;
    if (dwg_dynapi_entity_value(light, "LIGHT", "target", &target, NULL)
        && !memcmp(&target, &light->target, sizeof(light->target)))
      pass ("LIGHT.target");
    else
      {
        fail ("LIGHT.target"); error++;
      }
  }
  {
    BITCODE_BS type;
    if (dwg_dynapi_entity_value(light, "LIGHT", "type", &type, NULL) &&
        type == light->type)
      pass ("LIGHT.type [BS]");
    else
      {
        fail ("LIGHT.type [BS] %d != %d", light->type, type); error++;
      }
  }
  {
    BITCODE_B use_attenuation_limits;
    if (dwg_dynapi_entity_value(light, "LIGHT", "use_attenuation_limits", &use_attenuation_limits, NULL) &&
        use_attenuation_limits == light->use_attenuation_limits)
      pass ("LIGHT.use_attenuation_limits [B]");
    else
      {
        fail ("LIGHT.use_attenuation_limits [B] " FORMAT_B " != " FORMAT_B "", light->use_attenuation_limits, use_attenuation_limits); error++;
      }
  }
  return error;
}
static int test_LINE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_LINE *line = obj->tio.entity->tio.LINE;
  {
    BITCODE_RC Zs_are_zero;
    if (dwg_dynapi_entity_value(line, "LINE", "Zs_are_zero", &Zs_are_zero, NULL) &&
        Zs_are_zero == line->Zs_are_zero)
      pass ("LINE.Zs_are_zero [RC]");
    else
      {
        fail ("LINE.Zs_are_zero [RC] %c != %c", line->Zs_are_zero, Zs_are_zero); error++;
      }
  }
  {
    BITCODE_3BD end;
    if (dwg_dynapi_entity_value(line, "LINE", "end", &end, NULL)
        && !memcmp(&end, &line->end, sizeof(line->end)))
      pass ("LINE.end");
    else
      {
        fail ("LINE.end"); error++;
      }
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value(line, "LINE", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &line->extrusion, sizeof(line->extrusion)))
      pass ("LINE.extrusion");
    else
      {
        fail ("LINE.extrusion"); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(line, "LINE", "parent", &parent, NULL)
        && !memcmp(&parent, &line->parent, sizeof(line->parent)))
      pass ("LINE.parent");
    else
      {
        fail ("LINE.parent"); error++;
      }
  }
  {
    BITCODE_3BD start;
    if (dwg_dynapi_entity_value(line, "LINE", "start", &start, NULL)
        && !memcmp(&start, &line->start, sizeof(line->start)))
      pass ("LINE.start");
    else
      {
        fail ("LINE.start"); error++;
      }
  }
  {
    BITCODE_BT thickness;
    if (dwg_dynapi_entity_value(line, "LINE", "thickness", &thickness, NULL) &&
        thickness == line->thickness)
      pass ("LINE.thickness [BT]");
    else
      {
        fail ("LINE.thickness [BT] " FORMAT_BT " != " FORMAT_BT "", line->thickness, thickness); error++;
      }
  }
  return error;
}
static int test_LOFTEDSURFACE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_LOFTEDSURFACE *loftedsurface = obj->tio.entity->tio.LOFTEDSURFACE;
  {
    unsigned char* acis_data;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "acis_data", &acis_data, NULL)
        && !strcmp((char*)&acis_data, (char*)&loftedsurface->acis_data))
      pass ("LOFTEDSURFACE.acis_data");
    else
      {
        fail ("LOFTEDSURFACE.acis_data"); error++;
      }
  }
  {
    BITCODE_RC acis_empty;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "acis_empty", &acis_empty, NULL) &&
        acis_empty == loftedsurface->acis_empty)
      pass ("LOFTEDSURFACE.acis_empty [RC]");
    else
      {
        fail ("LOFTEDSURFACE.acis_empty [RC] %c != %c", loftedsurface->acis_empty, acis_empty); error++;
      }
  }
  {
    BITCODE_RC acis_empty2;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "acis_empty2", &acis_empty2, NULL) &&
        acis_empty2 == loftedsurface->acis_empty2)
      pass ("LOFTEDSURFACE.acis_empty2 [RC]");
    else
      {
        fail ("LOFTEDSURFACE.acis_empty2 [RC] %c != %c", loftedsurface->acis_empty2, acis_empty2); error++;
      }
  }
  {
    BITCODE_RC acis_empty_bit;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "acis_empty_bit", &acis_empty_bit, NULL) &&
        acis_empty_bit == loftedsurface->acis_empty_bit)
      pass ("LOFTEDSURFACE.acis_empty_bit [RC]");
    else
      {
        fail ("LOFTEDSURFACE.acis_empty_bit [RC] %c != %c", loftedsurface->acis_empty_bit, acis_empty_bit); error++;
      }
  }
  {
    BITCODE_B align_direction;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "align_direction", &align_direction, NULL) &&
        align_direction == loftedsurface->align_direction)
      pass ("LOFTEDSURFACE.align_direction [B]");
    else
      {
        fail ("LOFTEDSURFACE.align_direction [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->align_direction, align_direction); error++;
      }
  }
  {
    BITCODE_B arc_length_parameterization;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "arc_length_parameterization", &arc_length_parameterization, NULL) &&
        arc_length_parameterization == loftedsurface->arc_length_parameterization)
      pass ("LOFTEDSURFACE.arc_length_parameterization [B]");
    else
      {
        fail ("LOFTEDSURFACE.arc_length_parameterization [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->arc_length_parameterization, arc_length_parameterization); error++;
      }
  }
  {
    unsigned int* block_size;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "block_size", &block_size, NULL)
        && !memcmp(&block_size, &loftedsurface->block_size, sizeof(loftedsurface->block_size)))
      pass ("LOFTEDSURFACE.block_size");
    else
      {
        fail ("LOFTEDSURFACE.block_size"); error++;
      }
  }
  {
    BITCODE_B closed_surfaces;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "closed_surfaces", &closed_surfaces, NULL) &&
        closed_surfaces == loftedsurface->closed_surfaces)
      pass ("LOFTEDSURFACE.closed_surfaces [B]");
    else
      {
        fail ("LOFTEDSURFACE.closed_surfaces [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->closed_surfaces, closed_surfaces); error++;
      }
  }
  {
    Dwg_Object_Ref* cross_sections;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "cross_sections", &cross_sections, NULL)
        && !memcmp(&cross_sections, &loftedsurface->cross_sections, sizeof(loftedsurface->cross_sections)))
      pass ("LOFTEDSURFACE.cross_sections");
    else
      {
        fail ("LOFTEDSURFACE.cross_sections"); error++;
      }
  }
  {
    BITCODE_TV encr_sat_data;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "encr_sat_data", &encr_sat_data, NULL)
        && !strcmp((char*)&encr_sat_data, (char*)&loftedsurface->encr_sat_data))
      pass ("LOFTEDSURFACE.encr_sat_data");
    else
      {
        fail ("LOFTEDSURFACE.encr_sat_data"); error++;
      }
  }
  {
    BITCODE_BD end_draft_angle;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "end_draft_angle", &end_draft_angle, NULL) &&
        end_draft_angle == loftedsurface->end_draft_angle)
      pass ("LOFTEDSURFACE.end_draft_angle [BD]");
    else
      {
        fail ("LOFTEDSURFACE.end_draft_angle [BD] %g != %g", loftedsurface->end_draft_angle, end_draft_angle); error++;
      }
  }
  {
    BITCODE_BD end_draft_magnitude;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "end_draft_magnitude", &end_draft_magnitude, NULL) &&
        end_draft_magnitude == loftedsurface->end_draft_magnitude)
      pass ("LOFTEDSURFACE.end_draft_magnitude [BD]");
    else
      {
        fail ("LOFTEDSURFACE.end_draft_magnitude [BD] %g != %g", loftedsurface->end_draft_magnitude, end_draft_magnitude); error++;
      }
  }
  {
    struct _dwg_entity_3DSOLID* extra_acis_data;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "extra_acis_data", &extra_acis_data, NULL)
        && !memcmp(&extra_acis_data, &loftedsurface->extra_acis_data, sizeof(loftedsurface->extra_acis_data)))
      pass ("LOFTEDSURFACE.extra_acis_data");
    else
      {
        fail ("LOFTEDSURFACE.extra_acis_data"); error++;
      }
  }
  {
    Dwg_Object_Ref* guide_curves;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "guide_curves", &guide_curves, NULL)
        && !memcmp(&guide_curves, &loftedsurface->guide_curves, sizeof(loftedsurface->guide_curves)))
      pass ("LOFTEDSURFACE.guide_curves");
    else
      {
        fail ("LOFTEDSURFACE.guide_curves"); error++;
      }
  }
  {
    Dwg_Object_Ref* history_id;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "history_id", &history_id, NULL)
        && !memcmp(&history_id, &loftedsurface->history_id, sizeof(loftedsurface->history_id)))
      pass ("LOFTEDSURFACE.history_id");
    else
      {
        fail ("LOFTEDSURFACE.history_id"); error++;
      }
  }
  {
    BITCODE_RC isoline_present;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "isoline_present", &isoline_present, NULL) &&
        isoline_present == loftedsurface->isoline_present)
      pass ("LOFTEDSURFACE.isoline_present [RC]");
    else
      {
        fail ("LOFTEDSURFACE.isoline_present [RC] %c != %c", loftedsurface->isoline_present, isoline_present); error++;
      }
  }
  {
    BITCODE_BD* loft_entity_transmatrix;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "loft_entity_transmatrix", &loft_entity_transmatrix, NULL)
        && !memcmp(&loft_entity_transmatrix, &loftedsurface->loft_entity_transmatrix, sizeof(loftedsurface->loft_entity_transmatrix)))
      pass ("LOFTEDSURFACE.loft_entity_transmatrix");
    else
      {
        fail ("LOFTEDSURFACE.loft_entity_transmatrix"); error++;
      }
  }
  {
    BITCODE_BS modeler_format_version;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "modeler_format_version", &modeler_format_version, NULL) &&
        modeler_format_version == loftedsurface->modeler_format_version)
      pass ("LOFTEDSURFACE.modeler_format_version [BS]");
    else
      {
        fail ("LOFTEDSURFACE.modeler_format_version [BS] %d != %d", loftedsurface->modeler_format_version, modeler_format_version); error++;
      }
  }
  {
    BITCODE_B no_twist;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "no_twist", &no_twist, NULL) &&
        no_twist == loftedsurface->no_twist)
      pass ("LOFTEDSURFACE.no_twist [B]");
    else
      {
        fail ("LOFTEDSURFACE.no_twist [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->no_twist, no_twist); error++;
      }
  }
  {
    BITCODE_BL num_blocks;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "num_blocks", &num_blocks, NULL) &&
        num_blocks == loftedsurface->num_blocks)
      pass ("LOFTEDSURFACE.num_blocks [BL]");
    else
      {
        fail ("LOFTEDSURFACE.num_blocks [BL] %u != %u", loftedsurface->num_blocks, num_blocks); error++;
      }
  }
  {
    BITCODE_BS num_cross_sections;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "num_cross_sections", &num_cross_sections, NULL) &&
        num_cross_sections == loftedsurface->num_cross_sections)
      pass ("LOFTEDSURFACE.num_cross_sections [BS]");
    else
      {
        fail ("LOFTEDSURFACE.num_cross_sections [BS] %d != %d", loftedsurface->num_cross_sections, num_cross_sections); error++;
      }
  }
  {
    BITCODE_BS num_guide_curves;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "num_guide_curves", &num_guide_curves, NULL) &&
        num_guide_curves == loftedsurface->num_guide_curves)
      pass ("LOFTEDSURFACE.num_guide_curves [BS]");
    else
      {
        fail ("LOFTEDSURFACE.num_guide_curves [BS] %d != %d", loftedsurface->num_guide_curves, num_guide_curves); error++;
      }
  }
  {
    BITCODE_BL num_isolines;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "num_isolines", &num_isolines, NULL) &&
        num_isolines == loftedsurface->num_isolines)
      pass ("LOFTEDSURFACE.num_isolines [BL]");
    else
      {
        fail ("LOFTEDSURFACE.num_isolines [BL] %u != %u", loftedsurface->num_isolines, num_isolines); error++;
      }
  }
  {
    BITCODE_BL num_silhouettes;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "num_silhouettes", &num_silhouettes, NULL) &&
        num_silhouettes == loftedsurface->num_silhouettes)
      pass ("LOFTEDSURFACE.num_silhouettes [BL]");
    else
      {
        fail ("LOFTEDSURFACE.num_silhouettes [BL] %u != %u", loftedsurface->num_silhouettes, num_silhouettes); error++;
      }
  }
  {
    BITCODE_BL num_wires;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "num_wires", &num_wires, NULL) &&
        num_wires == loftedsurface->num_wires)
      pass ("LOFTEDSURFACE.num_wires [BL]");
    else
      {
        fail ("LOFTEDSURFACE.num_wires [BL] %u != %u", loftedsurface->num_wires, num_wires); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "parent", &parent, NULL)
        && !memcmp(&parent, &loftedsurface->parent, sizeof(loftedsurface->parent)))
      pass ("LOFTEDSURFACE.parent");
    else
      {
        fail ("LOFTEDSURFACE.parent"); error++;
      }
  }
  {
    BITCODE_H path_curve;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "path_curve", &path_curve, NULL) &&
        path_curve == loftedsurface->path_curve)
      pass ("LOFTEDSURFACE.path_curve [H]");
    else
      {
        fail ("LOFTEDSURFACE.path_curve [H] %p != %p", loftedsurface->path_curve, path_curve); error++;
      }
  }
  {
    BITCODE_BL plane_normal_lofting_type;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "plane_normal_lofting_type", &plane_normal_lofting_type, NULL) &&
        plane_normal_lofting_type == loftedsurface->plane_normal_lofting_type)
      pass ("LOFTEDSURFACE.plane_normal_lofting_type [BL]");
    else
      {
        fail ("LOFTEDSURFACE.plane_normal_lofting_type [BL] %u != %u", loftedsurface->plane_normal_lofting_type, plane_normal_lofting_type); error++;
      }
  }
  {
    Dwg_Bitcode_3BD point;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "point", &point, NULL)
        && !memcmp(&point, &loftedsurface->point, sizeof(loftedsurface->point)))
      pass ("LOFTEDSURFACE.point");
    else
      {
        fail ("LOFTEDSURFACE.point"); error++;
      }
  }
  {
    BITCODE_RC point_present;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "point_present", &point_present, NULL) &&
        point_present == loftedsurface->point_present)
      pass ("LOFTEDSURFACE.point_present [RC]");
    else
      {
        fail ("LOFTEDSURFACE.point_present [RC] %c != %c", loftedsurface->point_present, point_present); error++;
      }
  }
  {
    BITCODE_B ruled_surface;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "ruled_surface", &ruled_surface, NULL) &&
        ruled_surface == loftedsurface->ruled_surface)
      pass ("LOFTEDSURFACE.ruled_surface [B]");
    else
      {
        fail ("LOFTEDSURFACE.ruled_surface [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->ruled_surface, ruled_surface); error++;
      }
  }
  {
    Dwg_3DSOLID_silhouette* silhouettes;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "silhouettes", &silhouettes, NULL)
        && !memcmp(&silhouettes, &loftedsurface->silhouettes, sizeof(loftedsurface->silhouettes)))
      pass ("LOFTEDSURFACE.silhouettes");
    else
      {
        fail ("LOFTEDSURFACE.silhouettes"); error++;
      }
  }
  {
    BITCODE_B simple_surfaces;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "simple_surfaces", &simple_surfaces, NULL) &&
        simple_surfaces == loftedsurface->simple_surfaces)
      pass ("LOFTEDSURFACE.simple_surfaces [B]");
    else
      {
        fail ("LOFTEDSURFACE.simple_surfaces [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->simple_surfaces, simple_surfaces); error++;
      }
  }
  {
    BITCODE_B solid;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "solid", &solid, NULL) &&
        solid == loftedsurface->solid)
      pass ("LOFTEDSURFACE.solid [B]");
    else
      {
        fail ("LOFTEDSURFACE.solid [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->solid, solid); error++;
      }
  }
  {
    BITCODE_BD start_draft_angle;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "start_draft_angle", &start_draft_angle, NULL) &&
        start_draft_angle == loftedsurface->start_draft_angle)
      pass ("LOFTEDSURFACE.start_draft_angle [BD]");
    else
      {
        fail ("LOFTEDSURFACE.start_draft_angle [BD] %g != %g", loftedsurface->start_draft_angle, start_draft_angle); error++;
      }
  }
  {
    BITCODE_BD start_draft_magnitude;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "start_draft_magnitude", &start_draft_magnitude, NULL) &&
        start_draft_magnitude == loftedsurface->start_draft_magnitude)
      pass ("LOFTEDSURFACE.start_draft_magnitude [BD]");
    else
      {
        fail ("LOFTEDSURFACE.start_draft_magnitude [BD] %g != %g", loftedsurface->start_draft_magnitude, start_draft_magnitude); error++;
      }
  }
  {
    BITCODE_BS u_isolines;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "u_isolines", &u_isolines, NULL) &&
        u_isolines == loftedsurface->u_isolines)
      pass ("LOFTEDSURFACE.u_isolines [BS]");
    else
      {
        fail ("LOFTEDSURFACE.u_isolines [BS] %d != %d", loftedsurface->u_isolines, u_isolines); error++;
      }
  }
  {
    BITCODE_RC unknown;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "unknown", &unknown, NULL) &&
        unknown == loftedsurface->unknown)
      pass ("LOFTEDSURFACE.unknown [RC]");
    else
      {
        fail ("LOFTEDSURFACE.unknown [RC] %c != %c", loftedsurface->unknown, unknown); error++;
      }
  }
  {
    BITCODE_BL unknown_2007;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "unknown_2007", &unknown_2007, NULL) &&
        unknown_2007 == loftedsurface->unknown_2007)
      pass ("LOFTEDSURFACE.unknown_2007 [BL]");
    else
      {
        fail ("LOFTEDSURFACE.unknown_2007 [BL] %u != %u", loftedsurface->unknown_2007, unknown_2007); error++;
      }
  }
  {
    BITCODE_BS v_isolines;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "v_isolines", &v_isolines, NULL) &&
        v_isolines == loftedsurface->v_isolines)
      pass ("LOFTEDSURFACE.v_isolines [BS]");
    else
      {
        fail ("LOFTEDSURFACE.v_isolines [BS] %d != %d", loftedsurface->v_isolines, v_isolines); error++;
      }
  }
  {
    BITCODE_BS version;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "version", &version, NULL) &&
        version == loftedsurface->version)
      pass ("LOFTEDSURFACE.version [BS]");
    else
      {
        fail ("LOFTEDSURFACE.version [BS] %d != %d", loftedsurface->version, version); error++;
      }
  }
  {
    BITCODE_B virtual_guide;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "virtual_guide", &virtual_guide, NULL) &&
        virtual_guide == loftedsurface->virtual_guide)
      pass ("LOFTEDSURFACE.virtual_guide [B]");
    else
      {
        fail ("LOFTEDSURFACE.virtual_guide [B] " FORMAT_B " != " FORMAT_B "", loftedsurface->virtual_guide, virtual_guide); error++;
      }
  }
  {
    BITCODE_RC wireframe_data_present;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "wireframe_data_present", &wireframe_data_present, NULL) &&
        wireframe_data_present == loftedsurface->wireframe_data_present)
      pass ("LOFTEDSURFACE.wireframe_data_present [RC]");
    else
      {
        fail ("LOFTEDSURFACE.wireframe_data_present [RC] %c != %c", loftedsurface->wireframe_data_present, wireframe_data_present); error++;
      }
  }
  {
    Dwg_3DSOLID_wire* wires;
    if (dwg_dynapi_entity_value(loftedsurface, "LOFTEDSURFACE", "wires", &wires, NULL)
        && !memcmp(&wires, &loftedsurface->wires, sizeof(loftedsurface->wires)))
      pass ("LOFTEDSURFACE.wires");
    else
      {
        fail ("LOFTEDSURFACE.wires"); error++;
      }
  }
  return error;
}
static int test_LWPOLYLINE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_LWPOLYLINE *lwpolyline = obj->tio.entity->tio.LWPOLYLINE;
  {
    BITCODE_BD* bulges;
    if (dwg_dynapi_entity_value(lwpolyline, "LWPOLYLINE", "bulges", &bulges, NULL)
        && !memcmp(&bulges, &lwpolyline->bulges, sizeof(lwpolyline->bulges)))
      pass ("LWPOLYLINE.bulges");
    else
      {
        fail ("LWPOLYLINE.bulges"); error++;
      }
  }
  {
    BITCODE_BD const_width;
    if (dwg_dynapi_entity_value(lwpolyline, "LWPOLYLINE", "const_width", &const_width, NULL) &&
        const_width == lwpolyline->const_width)
      pass ("LWPOLYLINE.const_width [BD]");
    else
      {
        fail ("LWPOLYLINE.const_width [BD] %g != %g", lwpolyline->const_width, const_width); error++;
      }
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value(lwpolyline, "LWPOLYLINE", "elevation", &elevation, NULL) &&
        elevation == lwpolyline->elevation)
      pass ("LWPOLYLINE.elevation [BD]");
    else
      {
        fail ("LWPOLYLINE.elevation [BD] %g != %g", lwpolyline->elevation, elevation); error++;
      }
  }
  {
    BITCODE_3BD extrusion;
    if (dwg_dynapi_entity_value(lwpolyline, "LWPOLYLINE", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &lwpolyline->extrusion, sizeof(lwpolyline->extrusion)))
      pass ("LWPOLYLINE.extrusion");
    else
      {
        fail ("LWPOLYLINE.extrusion"); error++;
      }
  }
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value(lwpolyline, "LWPOLYLINE", "flag", &flag, NULL) &&
        flag == lwpolyline->flag)
      pass ("LWPOLYLINE.flag [BS]");
    else
      {
        fail ("LWPOLYLINE.flag [BS] %d != %d", lwpolyline->flag, flag); error++;
      }
  }
  {
    BITCODE_BL num_bulges;
    if (dwg_dynapi_entity_value(lwpolyline, "LWPOLYLINE", "num_bulges", &num_bulges, NULL) &&
        num_bulges == lwpolyline->num_bulges)
      pass ("LWPOLYLINE.num_bulges [BL]");
    else
      {
        fail ("LWPOLYLINE.num_bulges [BL] %u != %u", lwpolyline->num_bulges, num_bulges); error++;
      }
  }
  {
    BITCODE_BL num_points;
    if (dwg_dynapi_entity_value(lwpolyline, "LWPOLYLINE", "num_points", &num_points, NULL) &&
        num_points == lwpolyline->num_points)
      pass ("LWPOLYLINE.num_points [BL]");
    else
      {
        fail ("LWPOLYLINE.num_points [BL] %u != %u", lwpolyline->num_points, num_points); error++;
      }
  }
  {
    BITCODE_BL num_vertexids;
    if (dwg_dynapi_entity_value(lwpolyline, "LWPOLYLINE", "num_vertexids", &num_vertexids, NULL) &&
        num_vertexids == lwpolyline->num_vertexids)
      pass ("LWPOLYLINE.num_vertexids [BL]");
    else
      {
        fail ("LWPOLYLINE.num_vertexids [BL] %u != %u", lwpolyline->num_vertexids, num_vertexids); error++;
      }
  }
  {
    BITCODE_BL num_widths;
    if (dwg_dynapi_entity_value(lwpolyline, "LWPOLYLINE", "num_widths", &num_widths, NULL) &&
        num_widths == lwpolyline->num_widths)
      pass ("LWPOLYLINE.num_widths [BL]");
    else
      {
        fail ("LWPOLYLINE.num_widths [BL] %u != %u", lwpolyline->num_widths, num_widths); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(lwpolyline, "LWPOLYLINE", "parent", &parent, NULL)
        && !memcmp(&parent, &lwpolyline->parent, sizeof(lwpolyline->parent)))
      pass ("LWPOLYLINE.parent");
    else
      {
        fail ("LWPOLYLINE.parent"); error++;
      }
  }
  {
    BITCODE_2RD* points;
    if (dwg_dynapi_entity_value(lwpolyline, "LWPOLYLINE", "points", &points, NULL)
        && !memcmp(&points, &lwpolyline->points, sizeof(lwpolyline->points)))
      pass ("LWPOLYLINE.points");
    else
      {
        fail ("LWPOLYLINE.points"); error++;
      }
  }
  {
    BITCODE_BD thickness;
    if (dwg_dynapi_entity_value(lwpolyline, "LWPOLYLINE", "thickness", &thickness, NULL) &&
        thickness == lwpolyline->thickness)
      pass ("LWPOLYLINE.thickness [BD]");
    else
      {
        fail ("LWPOLYLINE.thickness [BD] %g != %g", lwpolyline->thickness, thickness); error++;
      }
  }
  {
    BITCODE_BL* vertexids;
    if (dwg_dynapi_entity_value(lwpolyline, "LWPOLYLINE", "vertexids", &vertexids, NULL)
        && !memcmp(&vertexids, &lwpolyline->vertexids, sizeof(lwpolyline->vertexids)))
      pass ("LWPOLYLINE.vertexids");
    else
      {
        fail ("LWPOLYLINE.vertexids"); error++;
      }
  }
  {
    Dwg_LWPOLYLINE_width* widths;
    if (dwg_dynapi_entity_value(lwpolyline, "LWPOLYLINE", "widths", &widths, NULL)
        && !memcmp(&widths, &lwpolyline->widths, sizeof(lwpolyline->widths)))
      pass ("LWPOLYLINE.widths");
    else
      {
        fail ("LWPOLYLINE.widths"); error++;
      }
  }
  return error;
}
static int test_MINSERT (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_MINSERT *minsert = obj->tio.entity->tio.MINSERT;
  {
    BITCODE_H* attrib_handles;
    if (dwg_dynapi_entity_value(minsert, "MINSERT", "attrib_handles", &attrib_handles, NULL)
        && !memcmp(&attrib_handles, &minsert->attrib_handles, sizeof(minsert->attrib_handles)))
      pass ("MINSERT.attrib_handles");
    else
      {
        fail ("MINSERT.attrib_handles"); error++;
      }
  }
  {
    BITCODE_H  block_header;
    if (dwg_dynapi_entity_value(minsert, "MINSERT", "block_header", &block_header, NULL) &&
        block_header == minsert->block_header)
      pass ("MINSERT.block_header [H ]");
    else
      {
        fail ("MINSERT.block_header [H ] %p != %p", minsert->block_header, block_header); error++;
      }
  }
  {
    BITCODE_BD       col_spacing;
    if (dwg_dynapi_entity_value(minsert, "MINSERT", "col_spacing", &col_spacing, NULL) &&
        col_spacing == minsert->col_spacing)
      pass ("MINSERT.col_spacing [BD      ]");
    else
      {
        fail ("MINSERT.col_spacing [BD      ] %p != %p", minsert->col_spacing, col_spacing); error++;
      }
  }
  {
    BITCODE_3DPOINT  extrusion;
    if (dwg_dynapi_entity_value(minsert, "MINSERT", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &minsert->extrusion, sizeof(minsert->extrusion)))
      pass ("MINSERT.extrusion");
    else
      {
        fail ("MINSERT.extrusion"); error++;
      }
  }
  {
    BITCODE_H  first_attrib;
    if (dwg_dynapi_entity_value(minsert, "MINSERT", "first_attrib", &first_attrib, NULL) &&
        first_attrib == minsert->first_attrib)
      pass ("MINSERT.first_attrib [H ]");
    else
      {
        fail ("MINSERT.first_attrib [H ] %p != %p", minsert->first_attrib, first_attrib); error++;
      }
  }
  {
    BITCODE_B        has_attribs;
    if (dwg_dynapi_entity_value(minsert, "MINSERT", "has_attribs", &has_attribs, NULL) &&
        has_attribs == minsert->has_attribs)
      pass ("MINSERT.has_attribs [B       ]");
    else
      {
        fail ("MINSERT.has_attribs [B       ] %p != %p", minsert->has_attribs, has_attribs); error++;
      }
  }
  {
    BITCODE_3DPOINT  ins_pt;
    if (dwg_dynapi_entity_value(minsert, "MINSERT", "ins_pt", &ins_pt, NULL)
        && !memcmp(&ins_pt, &minsert->ins_pt, sizeof(minsert->ins_pt)))
      pass ("MINSERT.ins_pt");
    else
      {
        fail ("MINSERT.ins_pt"); error++;
      }
  }
  {
    BITCODE_H  last_attrib;
    if (dwg_dynapi_entity_value(minsert, "MINSERT", "last_attrib", &last_attrib, NULL) &&
        last_attrib == minsert->last_attrib)
      pass ("MINSERT.last_attrib [H ]");
    else
      {
        fail ("MINSERT.last_attrib [H ] %p != %p", minsert->last_attrib, last_attrib); error++;
      }
  }
  {
    BITCODE_BS       num_cols;
    if (dwg_dynapi_entity_value(minsert, "MINSERT", "num_cols", &num_cols, NULL) &&
        num_cols == minsert->num_cols)
      pass ("MINSERT.num_cols [BS      ]");
    else
      {
        fail ("MINSERT.num_cols [BS      ] %p != %p", minsert->num_cols, num_cols); error++;
      }
  }
  {
    BITCODE_BL       num_owned;
    if (dwg_dynapi_entity_value(minsert, "MINSERT", "num_owned", &num_owned, NULL) &&
        num_owned == minsert->num_owned)
      pass ("MINSERT.num_owned [BL      ]");
    else
      {
        fail ("MINSERT.num_owned [BL      ] %p != %p", minsert->num_owned, num_owned); error++;
      }
  }
  {
    BITCODE_BS       num_rows;
    if (dwg_dynapi_entity_value(minsert, "MINSERT", "num_rows", &num_rows, NULL) &&
        num_rows == minsert->num_rows)
      pass ("MINSERT.num_rows [BS      ]");
    else
      {
        fail ("MINSERT.num_rows [BS      ] %p != %p", minsert->num_rows, num_rows); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(minsert, "MINSERT", "parent", &parent, NULL)
        && !memcmp(&parent, &minsert->parent, sizeof(minsert->parent)))
      pass ("MINSERT.parent");
    else
      {
        fail ("MINSERT.parent"); error++;
      }
  }
  {
    BITCODE_BD       rotation;
    if (dwg_dynapi_entity_value(minsert, "MINSERT", "rotation", &rotation, NULL) &&
        rotation == minsert->rotation)
      pass ("MINSERT.rotation [BD      ]");
    else
      {
        fail ("MINSERT.rotation [BD      ] %p != %p", minsert->rotation, rotation); error++;
      }
  }
  {
    BITCODE_BD       row_spacing;
    if (dwg_dynapi_entity_value(minsert, "MINSERT", "row_spacing", &row_spacing, NULL) &&
        row_spacing == minsert->row_spacing)
      pass ("MINSERT.row_spacing [BD      ]");
    else
      {
        fail ("MINSERT.row_spacing [BD      ] %p != %p", minsert->row_spacing, row_spacing); error++;
      }
  }
  {
    BITCODE_3DPOINT  scale;
    if (dwg_dynapi_entity_value(minsert, "MINSERT", "scale", &scale, NULL)
        && !memcmp(&scale, &minsert->scale, sizeof(minsert->scale)))
      pass ("MINSERT.scale");
    else
      {
        fail ("MINSERT.scale"); error++;
      }
  }
  {
    BITCODE_BB       scale_flag;
    if (dwg_dynapi_entity_value(minsert, "MINSERT", "scale_flag", &scale_flag, NULL) &&
        scale_flag == minsert->scale_flag)
      pass ("MINSERT.scale_flag [BB      ]");
    else
      {
        fail ("MINSERT.scale_flag [BB      ] %p != %p", minsert->scale_flag, scale_flag); error++;
      }
  }
  {
    BITCODE_H  seqend;
    if (dwg_dynapi_entity_value(minsert, "MINSERT", "seqend", &seqend, NULL) &&
        seqend == minsert->seqend)
      pass ("MINSERT.seqend [H ]");
    else
      {
        fail ("MINSERT.seqend [H ] %p != %p", minsert->seqend, seqend); error++;
      }
  }
  return error;
}
static int test_MLINE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_MLINE *mline = obj->tio.entity->tio.MLINE;
  {
    BITCODE_3BD base_point;
    if (dwg_dynapi_entity_value(mline, "MLINE", "base_point", &base_point, NULL)
        && !memcmp(&base_point, &mline->base_point, sizeof(mline->base_point)))
      pass ("MLINE.base_point");
    else
      {
        fail ("MLINE.base_point"); error++;
      }
  }
  {
    BITCODE_3BD extrusion;
    if (dwg_dynapi_entity_value(mline, "MLINE", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &mline->extrusion, sizeof(mline->extrusion)))
      pass ("MLINE.extrusion");
    else
      {
        fail ("MLINE.extrusion"); error++;
      }
  }
  {
    BITCODE_BS flags;
    if (dwg_dynapi_entity_value(mline, "MLINE", "flags", &flags, NULL) &&
        flags == mline->flags)
      pass ("MLINE.flags [BS]");
    else
      {
        fail ("MLINE.flags [BS] %d != %d", mline->flags, flags); error++;
      }
  }
  {
    BITCODE_RC justification;
    if (dwg_dynapi_entity_value(mline, "MLINE", "justification", &justification, NULL) &&
        justification == mline->justification)
      pass ("MLINE.justification [RC]");
    else
      {
        fail ("MLINE.justification [RC] %c != %c", mline->justification, justification); error++;
      }
  }
  {
    BITCODE_H mlinestyle;
    if (dwg_dynapi_entity_value(mline, "MLINE", "mlinestyle", &mlinestyle, NULL) &&
        mlinestyle == mline->mlinestyle)
      pass ("MLINE.mlinestyle [H]");
    else
      {
        fail ("MLINE.mlinestyle [H] %p != %p", mline->mlinestyle, mlinestyle); error++;
      }
  }
  {
    BITCODE_RC num_lines;
    if (dwg_dynapi_entity_value(mline, "MLINE", "num_lines", &num_lines, NULL) &&
        num_lines == mline->num_lines)
      pass ("MLINE.num_lines [RC]");
    else
      {
        fail ("MLINE.num_lines [RC] %c != %c", mline->num_lines, num_lines); error++;
      }
  }
  {
    BITCODE_BS num_verts;
    if (dwg_dynapi_entity_value(mline, "MLINE", "num_verts", &num_verts, NULL) &&
        num_verts == mline->num_verts)
      pass ("MLINE.num_verts [BS]");
    else
      {
        fail ("MLINE.num_verts [BS] %d != %d", mline->num_verts, num_verts); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(mline, "MLINE", "parent", &parent, NULL)
        && !memcmp(&parent, &mline->parent, sizeof(mline->parent)))
      pass ("MLINE.parent");
    else
      {
        fail ("MLINE.parent"); error++;
      }
  }
  {
    BITCODE_BD scale;
    if (dwg_dynapi_entity_value(mline, "MLINE", "scale", &scale, NULL) &&
        scale == mline->scale)
      pass ("MLINE.scale [BD]");
    else
      {
        fail ("MLINE.scale [BD] %g != %g", mline->scale, scale); error++;
      }
  }
  {
    Dwg_MLINE_vertex* verts;
    if (dwg_dynapi_entity_value(mline, "MLINE", "verts", &verts, NULL)
        && !memcmp(&verts, &mline->verts, sizeof(mline->verts)))
      pass ("MLINE.verts");
    else
      {
        fail ("MLINE.verts"); error++;
      }
  }
  return error;
}
static int test_MTEXT (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_MTEXT *mtext = obj->tio.entity->tio.MTEXT;
  {
    BITCODE_B annotative;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "annotative", &annotative, NULL) &&
        annotative == mtext->annotative)
      pass ("MTEXT.annotative [B]");
    else
      {
        fail ("MTEXT.annotative [B] " FORMAT_B " != " FORMAT_B "", mtext->annotative, annotative); error++;
      }
  }
  {
    BITCODE_H appid;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "appid", &appid, NULL) &&
        appid == mtext->appid)
      pass ("MTEXT.appid [H]");
    else
      {
        fail ("MTEXT.appid [H] %p != %p", mtext->appid, appid); error++;
      }
  }
  {
    BITCODE_BS attachment;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "attachment", &attachment, NULL) &&
        attachment == mtext->attachment)
      pass ("MTEXT.attachment [BS]");
    else
      {
        fail ("MTEXT.attachment [BS] %d != %d", mtext->attachment, attachment); error++;
      }
  }
  {
    BITCODE_B auto_height;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "auto_height", &auto_height, NULL) &&
        auto_height == mtext->auto_height)
      pass ("MTEXT.auto_height [B]");
    else
      {
        fail ("MTEXT.auto_height [B] " FORMAT_B " != " FORMAT_B "", mtext->auto_height, auto_height); error++;
      }
  }
  {
    BITCODE_CMC bg_fill_color;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "bg_fill_color", &bg_fill_color, NULL)
        && !memcmp(&bg_fill_color, &mtext->bg_fill_color, sizeof(mtext->bg_fill_color)))
      pass ("MTEXT.bg_fill_color");
    else
      {
        fail ("MTEXT.bg_fill_color"); error++;
      }
  }
  {
    BITCODE_BL bg_fill_flag;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "bg_fill_flag", &bg_fill_flag, NULL) &&
        bg_fill_flag == mtext->bg_fill_flag)
      pass ("MTEXT.bg_fill_flag [BL]");
    else
      {
        fail ("MTEXT.bg_fill_flag [BL] %u != %u", mtext->bg_fill_flag, bg_fill_flag); error++;
      }
  }
  {
    BITCODE_BL bg_fill_scale;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "bg_fill_scale", &bg_fill_scale, NULL) &&
        bg_fill_scale == mtext->bg_fill_scale)
      pass ("MTEXT.bg_fill_scale [BL]");
    else
      {
        fail ("MTEXT.bg_fill_scale [BL] %u != %u", mtext->bg_fill_scale, bg_fill_scale); error++;
      }
  }
  {
    BITCODE_BL bg_fill_trans;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "bg_fill_trans", &bg_fill_trans, NULL) &&
        bg_fill_trans == mtext->bg_fill_trans)
      pass ("MTEXT.bg_fill_trans [BL]");
    else
      {
        fail ("MTEXT.bg_fill_trans [BL] %u != %u", mtext->bg_fill_trans, bg_fill_trans); error++;
      }
  }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "class_version", &class_version, NULL) &&
        class_version == mtext->class_version)
      pass ("MTEXT.class_version [BS]");
    else
      {
        fail ("MTEXT.class_version [BS] %d != %d", mtext->class_version, class_version); error++;
      }
  }
  {
    double* column_heights;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "column_heights", &column_heights, NULL)
        && !memcmp(&column_heights, &mtext->column_heights, sizeof(mtext->column_heights)))
      pass ("MTEXT.column_heights");
    else
      {
        fail ("MTEXT.column_heights"); error++;
      }
  }
  {
    BITCODE_BL column_type;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "column_type", &column_type, NULL) &&
        column_type == mtext->column_type)
      pass ("MTEXT.column_type [BL]");
    else
      {
        fail ("MTEXT.column_type [BL] %u != %u", mtext->column_type, column_type); error++;
      }
  }
  {
    BITCODE_BD column_width;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "column_width", &column_width, NULL) &&
        column_width == mtext->column_width)
      pass ("MTEXT.column_width [BD]");
    else
      {
        fail ("MTEXT.column_width [BD] %g != %g", mtext->column_width, column_width); error++;
      }
  }
  {
    BITCODE_B default_flag;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "default_flag", &default_flag, NULL) &&
        default_flag == mtext->default_flag)
      pass ("MTEXT.default_flag [B]");
    else
      {
        fail ("MTEXT.default_flag [B] " FORMAT_B " != " FORMAT_B "", mtext->default_flag, default_flag); error++;
      }
  }
  {
    BITCODE_BS drawing_dir;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "drawing_dir", &drawing_dir, NULL) &&
        drawing_dir == mtext->drawing_dir)
      pass ("MTEXT.drawing_dir [BS]");
    else
      {
        fail ("MTEXT.drawing_dir [BS] %d != %d", mtext->drawing_dir, drawing_dir); error++;
      }
  }
  {
    BITCODE_BD extents_height;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "extents_height", &extents_height, NULL) &&
        extents_height == mtext->extents_height)
      pass ("MTEXT.extents_height [BD]");
    else
      {
        fail ("MTEXT.extents_height [BD] %g != %g", mtext->extents_height, extents_height); error++;
      }
  }
  {
    BITCODE_BD extents_width;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "extents_width", &extents_width, NULL) &&
        extents_width == mtext->extents_width)
      pass ("MTEXT.extents_width [BD]");
    else
      {
        fail ("MTEXT.extents_width [BD] %g != %g", mtext->extents_width, extents_width); error++;
      }
  }
  {
    BITCODE_3BD extrusion;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &mtext->extrusion, sizeof(mtext->extrusion)))
      pass ("MTEXT.extrusion");
    else
      {
        fail ("MTEXT.extrusion"); error++;
      }
  }
  {
    BITCODE_B flow_reversed;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "flow_reversed", &flow_reversed, NULL) &&
        flow_reversed == mtext->flow_reversed)
      pass ("MTEXT.flow_reversed [B]");
    else
      {
        fail ("MTEXT.flow_reversed [B] " FORMAT_B " != " FORMAT_B "", mtext->flow_reversed, flow_reversed); error++;
      }
  }
  {
    BITCODE_BD gutter;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "gutter", &gutter, NULL) &&
        gutter == mtext->gutter)
      pass ("MTEXT.gutter [BD]");
    else
      {
        fail ("MTEXT.gutter [BD] %g != %g", mtext->gutter, gutter); error++;
      }
  }
  {
    BITCODE_3BD insertion_pt;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "insertion_pt", &insertion_pt, NULL)
        && !memcmp(&insertion_pt, &mtext->insertion_pt, sizeof(mtext->insertion_pt)))
      pass ("MTEXT.insertion_pt");
    else
      {
        fail ("MTEXT.insertion_pt"); error++;
      }
  }
  {
    BITCODE_BD linespace_factor;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "linespace_factor", &linespace_factor, NULL) &&
        linespace_factor == mtext->linespace_factor)
      pass ("MTEXT.linespace_factor [BD]");
    else
      {
        fail ("MTEXT.linespace_factor [BD] %g != %g", mtext->linespace_factor, linespace_factor); error++;
      }
  }
  {
    BITCODE_BS linespace_style;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "linespace_style", &linespace_style, NULL) &&
        linespace_style == mtext->linespace_style)
      pass ("MTEXT.linespace_style [BS]");
    else
      {
        fail ("MTEXT.linespace_style [BS] %d != %d", mtext->linespace_style, linespace_style); error++;
      }
  }
  {
    BITCODE_BL num_column_heights;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "num_column_heights", &num_column_heights, NULL) &&
        num_column_heights == mtext->num_column_heights)
      pass ("MTEXT.num_column_heights [BL]");
    else
      {
        fail ("MTEXT.num_column_heights [BL] %u != %u", mtext->num_column_heights, num_column_heights); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "parent", &parent, NULL)
        && !memcmp(&parent, &mtext->parent, sizeof(mtext->parent)))
      pass ("MTEXT.parent");
    else
      {
        fail ("MTEXT.parent"); error++;
      }
  }
  {
    BITCODE_BD rect_height;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "rect_height", &rect_height, NULL) &&
        rect_height == mtext->rect_height)
      pass ("MTEXT.rect_height [BD]");
    else
      {
        fail ("MTEXT.rect_height [BD] %g != %g", mtext->rect_height, rect_height); error++;
      }
  }
  {
    BITCODE_BD rect_width;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "rect_width", &rect_width, NULL) &&
        rect_width == mtext->rect_width)
      pass ("MTEXT.rect_width [BD]");
    else
      {
        fail ("MTEXT.rect_width [BD] %g != %g", mtext->rect_width, rect_width); error++;
      }
  }
  {
    BITCODE_H style;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "style", &style, NULL) &&
        style == mtext->style)
      pass ("MTEXT.style [H]");
    else
      {
        fail ("MTEXT.style [H] %p != %p", mtext->style, style); error++;
      }
  }
  {
    BITCODE_TV text;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "text", &text, NULL)
        && !strcmp((char*)&text, (char*)&mtext->text))
      pass ("MTEXT.text");
    else
      {
        fail ("MTEXT.text"); error++;
      }
  }
  {
    BITCODE_BD text_height;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "text_height", &text_height, NULL) &&
        text_height == mtext->text_height)
      pass ("MTEXT.text_height [BD]");
    else
      {
        fail ("MTEXT.text_height [BD] %g != %g", mtext->text_height, text_height); error++;
      }
  }
  {
    BITCODE_B unknown_bit;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "unknown_bit", &unknown_bit, NULL) &&
        unknown_bit == mtext->unknown_bit)
      pass ("MTEXT.unknown_bit [B]");
    else
      {
        fail ("MTEXT.unknown_bit [B] " FORMAT_B " != " FORMAT_B "", mtext->unknown_bit, unknown_bit); error++;
      }
  }
  {
    BITCODE_3BD x_axis_dir;
    if (dwg_dynapi_entity_value(mtext, "MTEXT", "x_axis_dir", &x_axis_dir, NULL)
        && !memcmp(&x_axis_dir, &mtext->x_axis_dir, sizeof(mtext->x_axis_dir)))
      pass ("MTEXT.x_axis_dir");
    else
      {
        fail ("MTEXT.x_axis_dir"); error++;
      }
  }
  return error;
}
static int test_MULTILEADER (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_MULTILEADER *multileader = obj->tio.entity->tio.MULTILEADER;
  {
    BITCODE_H arrow_handle;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "arrow_handle", &arrow_handle, NULL) &&
        arrow_handle == multileader->arrow_handle)
      pass ("MULTILEADER.arrow_handle [H]");
    else
      {
        fail ("MULTILEADER.arrow_handle [H] %p != %p", multileader->arrow_handle, arrow_handle); error++;
      }
  }
  {
    BITCODE_BD arrow_size;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "arrow_size", &arrow_size, NULL) &&
        arrow_size == multileader->arrow_size)
      pass ("MULTILEADER.arrow_size [BD]");
    else
      {
        fail ("MULTILEADER.arrow_size [BD] %g != %g", multileader->arrow_size, arrow_size); error++;
      }
  }
  {
    Dwg_LEADER_ArrowHead* arrowheads;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "arrowheads", &arrowheads, NULL)
        && !memcmp(&arrowheads, &multileader->arrowheads, sizeof(multileader->arrowheads)))
      pass ("MULTILEADER.arrowheads");
    else
      {
        fail ("MULTILEADER.arrowheads"); error++;
      }
  }
  {
    BITCODE_BS attach_bottom;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "attach_bottom", &attach_bottom, NULL) &&
        attach_bottom == multileader->attach_bottom)
      pass ("MULTILEADER.attach_bottom [BS]");
    else
      {
        fail ("MULTILEADER.attach_bottom [BS] %d != %d", multileader->attach_bottom, attach_bottom); error++;
      }
  }
  {
    BITCODE_BS attach_dir;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "attach_dir", &attach_dir, NULL) &&
        attach_dir == multileader->attach_dir)
      pass ("MULTILEADER.attach_dir [BS]");
    else
      {
        fail ("MULTILEADER.attach_dir [BS] %d != %d", multileader->attach_dir, attach_dir); error++;
      }
  }
  {
    BITCODE_BS attach_top;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "attach_top", &attach_top, NULL) &&
        attach_top == multileader->attach_top)
      pass ("MULTILEADER.attach_top [BS]");
    else
      {
        fail ("MULTILEADER.attach_top [BS] %d != %d", multileader->attach_top, attach_top); error++;
      }
  }
  {
    BITCODE_BS attach_type;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "attach_type", &attach_type, NULL) &&
        attach_type == multileader->attach_type)
      pass ("MULTILEADER.attach_type [BS]");
    else
      {
        fail ("MULTILEADER.attach_type [BS] %d != %d", multileader->attach_type, attach_type); error++;
      }
  }
  {
    BITCODE_CMC block_color;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "block_color", &block_color, NULL)
        && !memcmp(&block_color, &multileader->block_color, sizeof(multileader->block_color)))
      pass ("MULTILEADER.block_color");
    else
      {
        fail ("MULTILEADER.block_color"); error++;
      }
  }
  {
    BITCODE_BD block_rotation;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "block_rotation", &block_rotation, NULL) &&
        block_rotation == multileader->block_rotation)
      pass ("MULTILEADER.block_rotation [BD]");
    else
      {
        fail ("MULTILEADER.block_rotation [BD] %g != %g", multileader->block_rotation, block_rotation); error++;
      }
  }
  {
    BITCODE_3BD block_scale;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "block_scale", &block_scale, NULL)
        && !memcmp(&block_scale, &multileader->block_scale, sizeof(multileader->block_scale)))
      pass ("MULTILEADER.block_scale");
    else
      {
        fail ("MULTILEADER.block_scale"); error++;
      }
  }
  {
    BITCODE_H block_style;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "block_style", &block_style, NULL) &&
        block_style == multileader->block_style)
      pass ("MULTILEADER.block_style [H]");
    else
      {
        fail ("MULTILEADER.block_style [H] %p != %p", multileader->block_style, block_style); error++;
      }
  }
  {
    Dwg_LEADER_BlockLabel* blocklabels;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "blocklabels", &blocklabels, NULL)
        && !memcmp(&blocklabels, &multileader->blocklabels, sizeof(multileader->blocklabels)))
      pass ("MULTILEADER.blocklabels");
    else
      {
        fail ("MULTILEADER.blocklabels"); error++;
      }
  }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "class_version", &class_version, NULL) &&
        class_version == multileader->class_version)
      pass ("MULTILEADER.class_version [BS]");
    else
      {
        fail ("MULTILEADER.class_version [BS] %d != %d", multileader->class_version, class_version); error++;
      }
  }
  {
    BITCODE_CMC color;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "color", &color, NULL)
        && !memcmp(&color, &multileader->color, sizeof(multileader->color)))
      pass ("MULTILEADER.color");
    else
      {
        fail ("MULTILEADER.color"); error++;
      }
  }
  {
    Dwg_MLEADER_AnnotContext ctx;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "ctx", &ctx, NULL)
        && !memcmp(&ctx, &multileader->ctx, sizeof(multileader->ctx)))
      pass ("MULTILEADER.ctx");
    else
      {
        fail ("MULTILEADER.ctx"); error++;
      }
  }
  {
    BITCODE_BL flags;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "flags", &flags, NULL) &&
        flags == multileader->flags)
      pass ("MULTILEADER.flags [BL]");
    else
      {
        fail ("MULTILEADER.flags [BL] %u != %u", multileader->flags, flags); error++;
      }
  }
  {
    BITCODE_B has_dogleg;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "has_dogleg", &has_dogleg, NULL) &&
        has_dogleg == multileader->has_dogleg)
      pass ("MULTILEADER.has_dogleg [B]");
    else
      {
        fail ("MULTILEADER.has_dogleg [B] " FORMAT_B " != " FORMAT_B "", multileader->has_dogleg, has_dogleg); error++;
      }
  }
  {
    BITCODE_B has_landing;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "has_landing", &has_landing, NULL) &&
        has_landing == multileader->has_landing)
      pass ("MULTILEADER.has_landing [B]");
    else
      {
        fail ("MULTILEADER.has_landing [B] " FORMAT_B " != " FORMAT_B "", multileader->has_landing, has_landing); error++;
      }
  }
  {
    BITCODE_B has_text_frame;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "has_text_frame", &has_text_frame, NULL) &&
        has_text_frame == multileader->has_text_frame)
      pass ("MULTILEADER.has_text_frame [B]");
    else
      {
        fail ("MULTILEADER.has_text_frame [B] " FORMAT_B " != " FORMAT_B "", multileader->has_text_frame, has_text_frame); error++;
      }
  }
  {
    BITCODE_BS ipe_alignment;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "ipe_alignment", &ipe_alignment, NULL) &&
        ipe_alignment == multileader->ipe_alignment)
      pass ("MULTILEADER.ipe_alignment [BS]");
    else
      {
        fail ("MULTILEADER.ipe_alignment [BS] %d != %d", multileader->ipe_alignment, ipe_alignment); error++;
      }
  }
  {
    BITCODE_B is_annotative;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "is_annotative", &is_annotative, NULL) &&
        is_annotative == multileader->is_annotative)
      pass ("MULTILEADER.is_annotative [B]");
    else
      {
        fail ("MULTILEADER.is_annotative [B] " FORMAT_B " != " FORMAT_B "", multileader->is_annotative, is_annotative); error++;
      }
  }
  {
    BITCODE_BS justification;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "justification", &justification, NULL) &&
        justification == multileader->justification)
      pass ("MULTILEADER.justification [BS]");
    else
      {
        fail ("MULTILEADER.justification [BS] %d != %d", multileader->justification, justification); error++;
      }
  }
  {
    BITCODE_BD landing_dist;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "landing_dist", &landing_dist, NULL) &&
        landing_dist == multileader->landing_dist)
      pass ("MULTILEADER.landing_dist [BD]");
    else
      {
        fail ("MULTILEADER.landing_dist [BD] %g != %g", multileader->landing_dist, landing_dist); error++;
      }
  }
  {
    BITCODE_BL linewt;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "linewt", &linewt, NULL) &&
        linewt == multileader->linewt)
      pass ("MULTILEADER.linewt [BL]");
    else
      {
        fail ("MULTILEADER.linewt [BL] %u != %u", multileader->linewt, linewt); error++;
      }
  }
  {
    BITCODE_H ltype;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "ltype", &ltype, NULL) &&
        ltype == multileader->ltype)
      pass ("MULTILEADER.ltype [H]");
    else
      {
        fail ("MULTILEADER.ltype [H] %p != %p", multileader->ltype, ltype); error++;
      }
  }
  {
    BITCODE_H mleaderstyle;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "mleaderstyle", &mleaderstyle, NULL) &&
        mleaderstyle == multileader->mleaderstyle)
      pass ("MULTILEADER.mleaderstyle [H]");
    else
      {
        fail ("MULTILEADER.mleaderstyle [H] %p != %p", multileader->mleaderstyle, mleaderstyle); error++;
      }
  }
  {
    BITCODE_B neg_textdir;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "neg_textdir", &neg_textdir, NULL) &&
        neg_textdir == multileader->neg_textdir)
      pass ("MULTILEADER.neg_textdir [B]");
    else
      {
        fail ("MULTILEADER.neg_textdir [B] " FORMAT_B " != " FORMAT_B "", multileader->neg_textdir, neg_textdir); error++;
      }
  }
  {
    BITCODE_BL num_arrowheads;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "num_arrowheads", &num_arrowheads, NULL) &&
        num_arrowheads == multileader->num_arrowheads)
      pass ("MULTILEADER.num_arrowheads [BL]");
    else
      {
        fail ("MULTILEADER.num_arrowheads [BL] %u != %u", multileader->num_arrowheads, num_arrowheads); error++;
      }
  }
  {
    BITCODE_BL num_blocklabels;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "num_blocklabels", &num_blocklabels, NULL) &&
        num_blocklabels == multileader->num_blocklabels)
      pass ("MULTILEADER.num_blocklabels [BL]");
    else
      {
        fail ("MULTILEADER.num_blocklabels [BL] %u != %u", multileader->num_blocklabels, num_blocklabels); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "parent", &parent, NULL)
        && !memcmp(&parent, &multileader->parent, sizeof(multileader->parent)))
      pass ("MULTILEADER.parent");
    else
      {
        fail ("MULTILEADER.parent"); error++;
      }
  }
  {
    BITCODE_BD scale_factor;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "scale_factor", &scale_factor, NULL) &&
        scale_factor == multileader->scale_factor)
      pass ("MULTILEADER.scale_factor [BD]");
    else
      {
        fail ("MULTILEADER.scale_factor [BD] %g != %g", multileader->scale_factor, scale_factor); error++;
      }
  }
  {
    BITCODE_BS style_attachment;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "style_attachment", &style_attachment, NULL) &&
        style_attachment == multileader->style_attachment)
      pass ("MULTILEADER.style_attachment [BS]");
    else
      {
        fail ("MULTILEADER.style_attachment [BS] %d != %d", multileader->style_attachment, style_attachment); error++;
      }
  }
  {
    BITCODE_BS style_content;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "style_content", &style_content, NULL) &&
        style_content == multileader->style_content)
      pass ("MULTILEADER.style_content [BS]");
    else
      {
        fail ("MULTILEADER.style_content [BS] %d != %d", multileader->style_content, style_content); error++;
      }
  }
  {
    BITCODE_BS text_angletype;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "text_angletype", &text_angletype, NULL) &&
        text_angletype == multileader->text_angletype)
      pass ("MULTILEADER.text_angletype [BS]");
    else
      {
        fail ("MULTILEADER.text_angletype [BS] %d != %d", multileader->text_angletype, text_angletype); error++;
      }
  }
  {
    BITCODE_CMC text_color;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "text_color", &text_color, NULL)
        && !memcmp(&text_color, &multileader->text_color, sizeof(multileader->text_color)))
      pass ("MULTILEADER.text_color");
    else
      {
        fail ("MULTILEADER.text_color"); error++;
      }
  }
  {
    BITCODE_B text_extended;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "text_extended", &text_extended, NULL) &&
        text_extended == multileader->text_extended)
      pass ("MULTILEADER.text_extended [B]");
    else
      {
        fail ("MULTILEADER.text_extended [B] " FORMAT_B " != " FORMAT_B "", multileader->text_extended, text_extended); error++;
      }
  }
  {
    BITCODE_BS text_left;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "text_left", &text_left, NULL) &&
        text_left == multileader->text_left)
      pass ("MULTILEADER.text_left [BS]");
    else
      {
        fail ("MULTILEADER.text_left [BS] %d != %d", multileader->text_left, text_left); error++;
      }
  }
  {
    BITCODE_BS text_right;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "text_right", &text_right, NULL) &&
        text_right == multileader->text_right)
      pass ("MULTILEADER.text_right [BS]");
    else
      {
        fail ("MULTILEADER.text_right [BS] %d != %d", multileader->text_right, text_right); error++;
      }
  }
  {
    BITCODE_H text_style;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "text_style", &text_style, NULL) &&
        text_style == multileader->text_style)
      pass ("MULTILEADER.text_style [H]");
    else
      {
        fail ("MULTILEADER.text_style [H] %p != %p", multileader->text_style, text_style); error++;
      }
  }
  {
    BITCODE_BS type;
    if (dwg_dynapi_entity_value(multileader, "MULTILEADER", "type", &type, NULL) &&
        type == multileader->type)
      pass ("MULTILEADER.type [BS]");
    else
      {
        fail ("MULTILEADER.type [BS] %d != %d", multileader->type, type); error++;
      }
  }
  return error;
}
static int test_OLE2FRAME (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_OLE2FRAME *ole2frame = obj->tio.entity->tio.OLE2FRAME;
  {
    BITCODE_TV data;
    if (dwg_dynapi_entity_value(ole2frame, "OLE2FRAME", "data", &data, NULL)
        && !strcmp((char*)&data, (char*)&ole2frame->data))
      pass ("OLE2FRAME.data");
    else
      {
        fail ("OLE2FRAME.data"); error++;
      }
  }
  {
    BITCODE_BL data_length;
    if (dwg_dynapi_entity_value(ole2frame, "OLE2FRAME", "data_length", &data_length, NULL) &&
        data_length == ole2frame->data_length)
      pass ("OLE2FRAME.data_length [BL]");
    else
      {
        fail ("OLE2FRAME.data_length [BL] %u != %u", ole2frame->data_length, data_length); error++;
      }
  }
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value(ole2frame, "OLE2FRAME", "flag", &flag, NULL) &&
        flag == ole2frame->flag)
      pass ("OLE2FRAME.flag [BS]");
    else
      {
        fail ("OLE2FRAME.flag [BS] %d != %d", ole2frame->flag, flag); error++;
      }
  }
  {
    BITCODE_BS mode;
    if (dwg_dynapi_entity_value(ole2frame, "OLE2FRAME", "mode", &mode, NULL) &&
        mode == ole2frame->mode)
      pass ("OLE2FRAME.mode [BS]");
    else
      {
        fail ("OLE2FRAME.mode [BS] %d != %d", ole2frame->mode, mode); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(ole2frame, "OLE2FRAME", "parent", &parent, NULL)
        && !memcmp(&parent, &ole2frame->parent, sizeof(ole2frame->parent)))
      pass ("OLE2FRAME.parent");
    else
      {
        fail ("OLE2FRAME.parent"); error++;
      }
  }
  {
    BITCODE_RC unknown;
    if (dwg_dynapi_entity_value(ole2frame, "OLE2FRAME", "unknown", &unknown, NULL) &&
        unknown == ole2frame->unknown)
      pass ("OLE2FRAME.unknown [RC]");
    else
      {
        fail ("OLE2FRAME.unknown [RC] %c != %c", ole2frame->unknown, unknown); error++;
      }
  }
  return error;
}
static int test_OLEFRAME (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_OLEFRAME *oleframe = obj->tio.entity->tio.OLEFRAME;
  {
    BITCODE_TV data;
    if (dwg_dynapi_entity_value(oleframe, "OLEFRAME", "data", &data, NULL)
        && !strcmp((char*)&data, (char*)&oleframe->data))
      pass ("OLEFRAME.data");
    else
      {
        fail ("OLEFRAME.data"); error++;
      }
  }
  {
    BITCODE_BL data_length;
    if (dwg_dynapi_entity_value(oleframe, "OLEFRAME", "data_length", &data_length, NULL) &&
        data_length == oleframe->data_length)
      pass ("OLEFRAME.data_length [BL]");
    else
      {
        fail ("OLEFRAME.data_length [BL] %u != %u", oleframe->data_length, data_length); error++;
      }
  }
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value(oleframe, "OLEFRAME", "flag", &flag, NULL) &&
        flag == oleframe->flag)
      pass ("OLEFRAME.flag [BS]");
    else
      {
        fail ("OLEFRAME.flag [BS] %d != %d", oleframe->flag, flag); error++;
      }
  }
  {
    BITCODE_BS mode;
    if (dwg_dynapi_entity_value(oleframe, "OLEFRAME", "mode", &mode, NULL) &&
        mode == oleframe->mode)
      pass ("OLEFRAME.mode [BS]");
    else
      {
        fail ("OLEFRAME.mode [BS] %d != %d", oleframe->mode, mode); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(oleframe, "OLEFRAME", "parent", &parent, NULL)
        && !memcmp(&parent, &oleframe->parent, sizeof(oleframe->parent)))
      pass ("OLEFRAME.parent");
    else
      {
        fail ("OLEFRAME.parent"); error++;
      }
  }
  return error;
}
static int test_PLANESURFACE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_PLANESURFACE *planesurface = obj->tio.entity->tio.PLANESURFACE;
  {
    unsigned char* acis_data;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "acis_data", &acis_data, NULL)
        && !strcmp((char*)&acis_data, (char*)&planesurface->acis_data))
      pass ("PLANESURFACE.acis_data");
    else
      {
        fail ("PLANESURFACE.acis_data"); error++;
      }
  }
  {
    BITCODE_RC acis_empty;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "acis_empty", &acis_empty, NULL) &&
        acis_empty == planesurface->acis_empty)
      pass ("PLANESURFACE.acis_empty [RC]");
    else
      {
        fail ("PLANESURFACE.acis_empty [RC] %c != %c", planesurface->acis_empty, acis_empty); error++;
      }
  }
  {
    BITCODE_RC acis_empty2;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "acis_empty2", &acis_empty2, NULL) &&
        acis_empty2 == planesurface->acis_empty2)
      pass ("PLANESURFACE.acis_empty2 [RC]");
    else
      {
        fail ("PLANESURFACE.acis_empty2 [RC] %c != %c", planesurface->acis_empty2, acis_empty2); error++;
      }
  }
  {
    BITCODE_RC acis_empty_bit;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "acis_empty_bit", &acis_empty_bit, NULL) &&
        acis_empty_bit == planesurface->acis_empty_bit)
      pass ("PLANESURFACE.acis_empty_bit [RC]");
    else
      {
        fail ("PLANESURFACE.acis_empty_bit [RC] %c != %c", planesurface->acis_empty_bit, acis_empty_bit); error++;
      }
  }
  {
    unsigned int* block_size;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "block_size", &block_size, NULL)
        && !memcmp(&block_size, &planesurface->block_size, sizeof(planesurface->block_size)))
      pass ("PLANESURFACE.block_size");
    else
      {
        fail ("PLANESURFACE.block_size"); error++;
      }
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "class_version", &class_version, NULL) &&
        class_version == planesurface->class_version)
      pass ("PLANESURFACE.class_version [BL]");
    else
      {
        fail ("PLANESURFACE.class_version [BL] %u != %u", planesurface->class_version, class_version); error++;
      }
  }
  {
    BITCODE_TV encr_sat_data;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "encr_sat_data", &encr_sat_data, NULL)
        && !strcmp((char*)&encr_sat_data, (char*)&planesurface->encr_sat_data))
      pass ("PLANESURFACE.encr_sat_data");
    else
      {
        fail ("PLANESURFACE.encr_sat_data"); error++;
      }
  }
  {
    struct _dwg_entity_3DSOLID* extra_acis_data;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "extra_acis_data", &extra_acis_data, NULL)
        && !memcmp(&extra_acis_data, &planesurface->extra_acis_data, sizeof(planesurface->extra_acis_data)))
      pass ("PLANESURFACE.extra_acis_data");
    else
      {
        fail ("PLANESURFACE.extra_acis_data"); error++;
      }
  }
  {
    Dwg_Object_Ref* history_id;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "history_id", &history_id, NULL)
        && !memcmp(&history_id, &planesurface->history_id, sizeof(planesurface->history_id)))
      pass ("PLANESURFACE.history_id");
    else
      {
        fail ("PLANESURFACE.history_id"); error++;
      }
  }
  {
    BITCODE_RC isoline_present;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "isoline_present", &isoline_present, NULL) &&
        isoline_present == planesurface->isoline_present)
      pass ("PLANESURFACE.isoline_present [RC]");
    else
      {
        fail ("PLANESURFACE.isoline_present [RC] %c != %c", planesurface->isoline_present, isoline_present); error++;
      }
  }
  {
    BITCODE_BS modeler_format_version;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "modeler_format_version", &modeler_format_version, NULL) &&
        modeler_format_version == planesurface->modeler_format_version)
      pass ("PLANESURFACE.modeler_format_version [BS]");
    else
      {
        fail ("PLANESURFACE.modeler_format_version [BS] %d != %d", planesurface->modeler_format_version, modeler_format_version); error++;
      }
  }
  {
    BITCODE_BL num_blocks;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "num_blocks", &num_blocks, NULL) &&
        num_blocks == planesurface->num_blocks)
      pass ("PLANESURFACE.num_blocks [BL]");
    else
      {
        fail ("PLANESURFACE.num_blocks [BL] %u != %u", planesurface->num_blocks, num_blocks); error++;
      }
  }
  {
    BITCODE_BL num_isolines;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "num_isolines", &num_isolines, NULL) &&
        num_isolines == planesurface->num_isolines)
      pass ("PLANESURFACE.num_isolines [BL]");
    else
      {
        fail ("PLANESURFACE.num_isolines [BL] %u != %u", planesurface->num_isolines, num_isolines); error++;
      }
  }
  {
    BITCODE_BL num_silhouettes;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "num_silhouettes", &num_silhouettes, NULL) &&
        num_silhouettes == planesurface->num_silhouettes)
      pass ("PLANESURFACE.num_silhouettes [BL]");
    else
      {
        fail ("PLANESURFACE.num_silhouettes [BL] %u != %u", planesurface->num_silhouettes, num_silhouettes); error++;
      }
  }
  {
    BITCODE_BL num_wires;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "num_wires", &num_wires, NULL) &&
        num_wires == planesurface->num_wires)
      pass ("PLANESURFACE.num_wires [BL]");
    else
      {
        fail ("PLANESURFACE.num_wires [BL] %u != %u", planesurface->num_wires, num_wires); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "parent", &parent, NULL)
        && !memcmp(&parent, &planesurface->parent, sizeof(planesurface->parent)))
      pass ("PLANESURFACE.parent");
    else
      {
        fail ("PLANESURFACE.parent"); error++;
      }
  }
  {
    Dwg_Bitcode_3BD point;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "point", &point, NULL)
        && !memcmp(&point, &planesurface->point, sizeof(planesurface->point)))
      pass ("PLANESURFACE.point");
    else
      {
        fail ("PLANESURFACE.point"); error++;
      }
  }
  {
    BITCODE_RC point_present;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "point_present", &point_present, NULL) &&
        point_present == planesurface->point_present)
      pass ("PLANESURFACE.point_present [RC]");
    else
      {
        fail ("PLANESURFACE.point_present [RC] %c != %c", planesurface->point_present, point_present); error++;
      }
  }
  {
    Dwg_3DSOLID_silhouette* silhouettes;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "silhouettes", &silhouettes, NULL)
        && !memcmp(&silhouettes, &planesurface->silhouettes, sizeof(planesurface->silhouettes)))
      pass ("PLANESURFACE.silhouettes");
    else
      {
        fail ("PLANESURFACE.silhouettes"); error++;
      }
  }
  {
    BITCODE_BS u_isolines;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "u_isolines", &u_isolines, NULL) &&
        u_isolines == planesurface->u_isolines)
      pass ("PLANESURFACE.u_isolines [BS]");
    else
      {
        fail ("PLANESURFACE.u_isolines [BS] %d != %d", planesurface->u_isolines, u_isolines); error++;
      }
  }
  {
    BITCODE_RC unknown;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "unknown", &unknown, NULL) &&
        unknown == planesurface->unknown)
      pass ("PLANESURFACE.unknown [RC]");
    else
      {
        fail ("PLANESURFACE.unknown [RC] %c != %c", planesurface->unknown, unknown); error++;
      }
  }
  {
    BITCODE_BL unknown_2007;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "unknown_2007", &unknown_2007, NULL) &&
        unknown_2007 == planesurface->unknown_2007)
      pass ("PLANESURFACE.unknown_2007 [BL]");
    else
      {
        fail ("PLANESURFACE.unknown_2007 [BL] %u != %u", planesurface->unknown_2007, unknown_2007); error++;
      }
  }
  {
    BITCODE_BS v_isolines;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "v_isolines", &v_isolines, NULL) &&
        v_isolines == planesurface->v_isolines)
      pass ("PLANESURFACE.v_isolines [BS]");
    else
      {
        fail ("PLANESURFACE.v_isolines [BS] %d != %d", planesurface->v_isolines, v_isolines); error++;
      }
  }
  {
    BITCODE_BS version;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "version", &version, NULL) &&
        version == planesurface->version)
      pass ("PLANESURFACE.version [BS]");
    else
      {
        fail ("PLANESURFACE.version [BS] %d != %d", planesurface->version, version); error++;
      }
  }
  {
    BITCODE_RC wireframe_data_present;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "wireframe_data_present", &wireframe_data_present, NULL) &&
        wireframe_data_present == planesurface->wireframe_data_present)
      pass ("PLANESURFACE.wireframe_data_present [RC]");
    else
      {
        fail ("PLANESURFACE.wireframe_data_present [RC] %c != %c", planesurface->wireframe_data_present, wireframe_data_present); error++;
      }
  }
  {
    Dwg_3DSOLID_wire* wires;
    if (dwg_dynapi_entity_value(planesurface, "PLANESURFACE", "wires", &wires, NULL)
        && !memcmp(&wires, &planesurface->wires, sizeof(planesurface->wires)))
      pass ("PLANESURFACE.wires");
    else
      {
        fail ("PLANESURFACE.wires"); error++;
      }
  }
  return error;
}
static int test_POINT (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_POINT *point = obj->tio.entity->tio.POINT;
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value(point, "POINT", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &point->extrusion, sizeof(point->extrusion)))
      pass ("POINT.extrusion");
    else
      {
        fail ("POINT.extrusion"); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(point, "POINT", "parent", &parent, NULL)
        && !memcmp(&parent, &point->parent, sizeof(point->parent)))
      pass ("POINT.parent");
    else
      {
        fail ("POINT.parent"); error++;
      }
  }
  {
    BITCODE_BT thickness;
    if (dwg_dynapi_entity_value(point, "POINT", "thickness", &thickness, NULL) &&
        thickness == point->thickness)
      pass ("POINT.thickness [BT]");
    else
      {
        fail ("POINT.thickness [BT] " FORMAT_BT " != " FORMAT_BT "", point->thickness, thickness); error++;
      }
  }
  {
    BITCODE_BD x;
    if (dwg_dynapi_entity_value(point, "POINT", "x", &x, NULL) &&
        x == point->x)
      pass ("POINT.x [BD]");
    else
      {
        fail ("POINT.x [BD] %g != %g", point->x, x); error++;
      }
  }
  {
    BITCODE_BD x_ang;
    if (dwg_dynapi_entity_value(point, "POINT", "x_ang", &x_ang, NULL) &&
        x_ang == point->x_ang)
      pass ("POINT.x_ang [BD]");
    else
      {
        fail ("POINT.x_ang [BD] %g != %g", point->x_ang, x_ang); error++;
      }
  }
  {
    BITCODE_BD y;
    if (dwg_dynapi_entity_value(point, "POINT", "y", &y, NULL) &&
        y == point->y)
      pass ("POINT.y [BD]");
    else
      {
        fail ("POINT.y [BD] %g != %g", point->y, y); error++;
      }
  }
  {
    BITCODE_BD z;
    if (dwg_dynapi_entity_value(point, "POINT", "z", &z, NULL) &&
        z == point->z)
      pass ("POINT.z [BD]");
    else
      {
        fail ("POINT.z [BD] %g != %g", point->z, z); error++;
      }
  }
  return error;
}
static int test_POLYLINE_2D (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_POLYLINE_2D *polyline_2d = obj->tio.entity->tio.POLYLINE_2D;
  {
    BITCODE_BS curve_type;
    if (dwg_dynapi_entity_value(polyline_2d, "POLYLINE_2D", "curve_type", &curve_type, NULL) &&
        curve_type == polyline_2d->curve_type)
      pass ("POLYLINE_2D.curve_type [BS]");
    else
      {
        fail ("POLYLINE_2D.curve_type [BS] %d != %d", polyline_2d->curve_type, curve_type); error++;
      }
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value(polyline_2d, "POLYLINE_2D", "elevation", &elevation, NULL) &&
        elevation == polyline_2d->elevation)
      pass ("POLYLINE_2D.elevation [BD]");
    else
      {
        fail ("POLYLINE_2D.elevation [BD] %g != %g", polyline_2d->elevation, elevation); error++;
      }
  }
  {
    BITCODE_BD end_width;
    if (dwg_dynapi_entity_value(polyline_2d, "POLYLINE_2D", "end_width", &end_width, NULL) &&
        end_width == polyline_2d->end_width)
      pass ("POLYLINE_2D.end_width [BD]");
    else
      {
        fail ("POLYLINE_2D.end_width [BD] %g != %g", polyline_2d->end_width, end_width); error++;
      }
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value(polyline_2d, "POLYLINE_2D", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &polyline_2d->extrusion, sizeof(polyline_2d->extrusion)))
      pass ("POLYLINE_2D.extrusion");
    else
      {
        fail ("POLYLINE_2D.extrusion"); error++;
      }
  }
  {
    Dwg_Object_Ref* first_vertex;
    if (dwg_dynapi_entity_value(polyline_2d, "POLYLINE_2D", "first_vertex", &first_vertex, NULL)
        && !memcmp(&first_vertex, &polyline_2d->first_vertex, sizeof(polyline_2d->first_vertex)))
      pass ("POLYLINE_2D.first_vertex");
    else
      {
        fail ("POLYLINE_2D.first_vertex"); error++;
      }
  }
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value(polyline_2d, "POLYLINE_2D", "flag", &flag, NULL) &&
        flag == polyline_2d->flag)
      pass ("POLYLINE_2D.flag [BS]");
    else
      {
        fail ("POLYLINE_2D.flag [BS] %d != %d", polyline_2d->flag, flag); error++;
      }
  }
  {
    Dwg_Object_Ref* last_vertex;
    if (dwg_dynapi_entity_value(polyline_2d, "POLYLINE_2D", "last_vertex", &last_vertex, NULL)
        && !memcmp(&last_vertex, &polyline_2d->last_vertex, sizeof(polyline_2d->last_vertex)))
      pass ("POLYLINE_2D.last_vertex");
    else
      {
        fail ("POLYLINE_2D.last_vertex"); error++;
      }
  }
  {
    BITCODE_BL num_owned;
    if (dwg_dynapi_entity_value(polyline_2d, "POLYLINE_2D", "num_owned", &num_owned, NULL) &&
        num_owned == polyline_2d->num_owned)
      pass ("POLYLINE_2D.num_owned [BL]");
    else
      {
        fail ("POLYLINE_2D.num_owned [BL] %u != %u", polyline_2d->num_owned, num_owned); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(polyline_2d, "POLYLINE_2D", "parent", &parent, NULL)
        && !memcmp(&parent, &polyline_2d->parent, sizeof(polyline_2d->parent)))
      pass ("POLYLINE_2D.parent");
    else
      {
        fail ("POLYLINE_2D.parent"); error++;
      }
  }
  {
    Dwg_Object_Ref* seqend;
    if (dwg_dynapi_entity_value(polyline_2d, "POLYLINE_2D", "seqend", &seqend, NULL)
        && !memcmp(&seqend, &polyline_2d->seqend, sizeof(polyline_2d->seqend)))
      pass ("POLYLINE_2D.seqend");
    else
      {
        fail ("POLYLINE_2D.seqend"); error++;
      }
  }
  {
    BITCODE_BD start_width;
    if (dwg_dynapi_entity_value(polyline_2d, "POLYLINE_2D", "start_width", &start_width, NULL) &&
        start_width == polyline_2d->start_width)
      pass ("POLYLINE_2D.start_width [BD]");
    else
      {
        fail ("POLYLINE_2D.start_width [BD] %g != %g", polyline_2d->start_width, start_width); error++;
      }
  }
  {
    BITCODE_BT thickness;
    if (dwg_dynapi_entity_value(polyline_2d, "POLYLINE_2D", "thickness", &thickness, NULL) &&
        thickness == polyline_2d->thickness)
      pass ("POLYLINE_2D.thickness [BT]");
    else
      {
        fail ("POLYLINE_2D.thickness [BT] " FORMAT_BT " != " FORMAT_BT "", polyline_2d->thickness, thickness); error++;
      }
  }
  {
    Dwg_Object_Ref* vertex;
    if (dwg_dynapi_entity_value(polyline_2d, "POLYLINE_2D", "vertex", &vertex, NULL)
        && !memcmp(&vertex, &polyline_2d->vertex, sizeof(polyline_2d->vertex)))
      pass ("POLYLINE_2D.vertex");
    else
      {
        fail ("POLYLINE_2D.vertex"); error++;
      }
  }
  return error;
}
static int test_POLYLINE_3D (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_POLYLINE_3D *polyline_3d = obj->tio.entity->tio.POLYLINE_3D;
  {
    BITCODE_RC curve_type;
    if (dwg_dynapi_entity_value(polyline_3d, "POLYLINE_3D", "curve_type", &curve_type, NULL) &&
        curve_type == polyline_3d->curve_type)
      pass ("POLYLINE_3D.curve_type [RC]");
    else
      {
        fail ("POLYLINE_3D.curve_type [RC] %c != %c", polyline_3d->curve_type, curve_type); error++;
      }
  }
  {
    Dwg_Object_Ref* first_vertex;
    if (dwg_dynapi_entity_value(polyline_3d, "POLYLINE_3D", "first_vertex", &first_vertex, NULL)
        && !memcmp(&first_vertex, &polyline_3d->first_vertex, sizeof(polyline_3d->first_vertex)))
      pass ("POLYLINE_3D.first_vertex");
    else
      {
        fail ("POLYLINE_3D.first_vertex"); error++;
      }
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value(polyline_3d, "POLYLINE_3D", "flag", &flag, NULL) &&
        flag == polyline_3d->flag)
      pass ("POLYLINE_3D.flag [RC]");
    else
      {
        fail ("POLYLINE_3D.flag [RC] %c != %c", polyline_3d->flag, flag); error++;
      }
  }
  {
    Dwg_Object_Ref* last_vertex;
    if (dwg_dynapi_entity_value(polyline_3d, "POLYLINE_3D", "last_vertex", &last_vertex, NULL)
        && !memcmp(&last_vertex, &polyline_3d->last_vertex, sizeof(polyline_3d->last_vertex)))
      pass ("POLYLINE_3D.last_vertex");
    else
      {
        fail ("POLYLINE_3D.last_vertex"); error++;
      }
  }
  {
    BITCODE_BL num_owned;
    if (dwg_dynapi_entity_value(polyline_3d, "POLYLINE_3D", "num_owned", &num_owned, NULL) &&
        num_owned == polyline_3d->num_owned)
      pass ("POLYLINE_3D.num_owned [BL]");
    else
      {
        fail ("POLYLINE_3D.num_owned [BL] %u != %u", polyline_3d->num_owned, num_owned); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(polyline_3d, "POLYLINE_3D", "parent", &parent, NULL)
        && !memcmp(&parent, &polyline_3d->parent, sizeof(polyline_3d->parent)))
      pass ("POLYLINE_3D.parent");
    else
      {
        fail ("POLYLINE_3D.parent"); error++;
      }
  }
  {
    Dwg_Object_Ref* seqend;
    if (dwg_dynapi_entity_value(polyline_3d, "POLYLINE_3D", "seqend", &seqend, NULL)
        && !memcmp(&seqend, &polyline_3d->seqend, sizeof(polyline_3d->seqend)))
      pass ("POLYLINE_3D.seqend");
    else
      {
        fail ("POLYLINE_3D.seqend"); error++;
      }
  }
  {
    Dwg_Object_Ref* vertex;
    if (dwg_dynapi_entity_value(polyline_3d, "POLYLINE_3D", "vertex", &vertex, NULL)
        && !memcmp(&vertex, &polyline_3d->vertex, sizeof(polyline_3d->vertex)))
      pass ("POLYLINE_3D.vertex");
    else
      {
        fail ("POLYLINE_3D.vertex"); error++;
      }
  }
  return error;
}
static int test_POLYLINE_MESH (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_POLYLINE_MESH *polyline_mesh = obj->tio.entity->tio.POLYLINE_MESH;
  {
    BITCODE_BS curve_type;
    if (dwg_dynapi_entity_value(polyline_mesh, "POLYLINE_MESH", "curve_type", &curve_type, NULL) &&
        curve_type == polyline_mesh->curve_type)
      pass ("POLYLINE_MESH.curve_type [BS]");
    else
      {
        fail ("POLYLINE_MESH.curve_type [BS] %d != %d", polyline_mesh->curve_type, curve_type); error++;
      }
  }
  {
    Dwg_Object_Ref* first_vertex;
    if (dwg_dynapi_entity_value(polyline_mesh, "POLYLINE_MESH", "first_vertex", &first_vertex, NULL)
        && !memcmp(&first_vertex, &polyline_mesh->first_vertex, sizeof(polyline_mesh->first_vertex)))
      pass ("POLYLINE_MESH.first_vertex");
    else
      {
        fail ("POLYLINE_MESH.first_vertex"); error++;
      }
  }
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value(polyline_mesh, "POLYLINE_MESH", "flag", &flag, NULL) &&
        flag == polyline_mesh->flag)
      pass ("POLYLINE_MESH.flag [BS]");
    else
      {
        fail ("POLYLINE_MESH.flag [BS] %d != %d", polyline_mesh->flag, flag); error++;
      }
  }
  {
    Dwg_Object_Ref* last_vertex;
    if (dwg_dynapi_entity_value(polyline_mesh, "POLYLINE_MESH", "last_vertex", &last_vertex, NULL)
        && !memcmp(&last_vertex, &polyline_mesh->last_vertex, sizeof(polyline_mesh->last_vertex)))
      pass ("POLYLINE_MESH.last_vertex");
    else
      {
        fail ("POLYLINE_MESH.last_vertex"); error++;
      }
  }
  {
    BITCODE_BS m_density;
    if (dwg_dynapi_entity_value(polyline_mesh, "POLYLINE_MESH", "m_density", &m_density, NULL) &&
        m_density == polyline_mesh->m_density)
      pass ("POLYLINE_MESH.m_density [BS]");
    else
      {
        fail ("POLYLINE_MESH.m_density [BS] %d != %d", polyline_mesh->m_density, m_density); error++;
      }
  }
  {
    BITCODE_BS n_density;
    if (dwg_dynapi_entity_value(polyline_mesh, "POLYLINE_MESH", "n_density", &n_density, NULL) &&
        n_density == polyline_mesh->n_density)
      pass ("POLYLINE_MESH.n_density [BS]");
    else
      {
        fail ("POLYLINE_MESH.n_density [BS] %d != %d", polyline_mesh->n_density, n_density); error++;
      }
  }
  {
    BITCODE_BS num_m_verts;
    if (dwg_dynapi_entity_value(polyline_mesh, "POLYLINE_MESH", "num_m_verts", &num_m_verts, NULL) &&
        num_m_verts == polyline_mesh->num_m_verts)
      pass ("POLYLINE_MESH.num_m_verts [BS]");
    else
      {
        fail ("POLYLINE_MESH.num_m_verts [BS] %d != %d", polyline_mesh->num_m_verts, num_m_verts); error++;
      }
  }
  {
    BITCODE_BS num_n_verts;
    if (dwg_dynapi_entity_value(polyline_mesh, "POLYLINE_MESH", "num_n_verts", &num_n_verts, NULL) &&
        num_n_verts == polyline_mesh->num_n_verts)
      pass ("POLYLINE_MESH.num_n_verts [BS]");
    else
      {
        fail ("POLYLINE_MESH.num_n_verts [BS] %d != %d", polyline_mesh->num_n_verts, num_n_verts); error++;
      }
  }
  {
    BITCODE_BL num_owned;
    if (dwg_dynapi_entity_value(polyline_mesh, "POLYLINE_MESH", "num_owned", &num_owned, NULL) &&
        num_owned == polyline_mesh->num_owned)
      pass ("POLYLINE_MESH.num_owned [BL]");
    else
      {
        fail ("POLYLINE_MESH.num_owned [BL] %u != %u", polyline_mesh->num_owned, num_owned); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(polyline_mesh, "POLYLINE_MESH", "parent", &parent, NULL)
        && !memcmp(&parent, &polyline_mesh->parent, sizeof(polyline_mesh->parent)))
      pass ("POLYLINE_MESH.parent");
    else
      {
        fail ("POLYLINE_MESH.parent"); error++;
      }
  }
  {
    Dwg_Object_Ref* seqend;
    if (dwg_dynapi_entity_value(polyline_mesh, "POLYLINE_MESH", "seqend", &seqend, NULL)
        && !memcmp(&seqend, &polyline_mesh->seqend, sizeof(polyline_mesh->seqend)))
      pass ("POLYLINE_MESH.seqend");
    else
      {
        fail ("POLYLINE_MESH.seqend"); error++;
      }
  }
  {
    Dwg_Object_Ref* vertex;
    if (dwg_dynapi_entity_value(polyline_mesh, "POLYLINE_MESH", "vertex", &vertex, NULL)
        && !memcmp(&vertex, &polyline_mesh->vertex, sizeof(polyline_mesh->vertex)))
      pass ("POLYLINE_MESH.vertex");
    else
      {
        fail ("POLYLINE_MESH.vertex"); error++;
      }
  }
  return error;
}
static int test_POLYLINE_PFACE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_POLYLINE_PFACE *polyline_pface = obj->tio.entity->tio.POLYLINE_PFACE;
  {
    Dwg_Object_Ref* first_vertex;
    if (dwg_dynapi_entity_value(polyline_pface, "POLYLINE_PFACE", "first_vertex", &first_vertex, NULL)
        && !memcmp(&first_vertex, &polyline_pface->first_vertex, sizeof(polyline_pface->first_vertex)))
      pass ("POLYLINE_PFACE.first_vertex");
    else
      {
        fail ("POLYLINE_PFACE.first_vertex"); error++;
      }
  }
  {
    Dwg_Object_Ref* last_vertex;
    if (dwg_dynapi_entity_value(polyline_pface, "POLYLINE_PFACE", "last_vertex", &last_vertex, NULL)
        && !memcmp(&last_vertex, &polyline_pface->last_vertex, sizeof(polyline_pface->last_vertex)))
      pass ("POLYLINE_PFACE.last_vertex");
    else
      {
        fail ("POLYLINE_PFACE.last_vertex"); error++;
      }
  }
  {
    BITCODE_BL num_owned;
    if (dwg_dynapi_entity_value(polyline_pface, "POLYLINE_PFACE", "num_owned", &num_owned, NULL) &&
        num_owned == polyline_pface->num_owned)
      pass ("POLYLINE_PFACE.num_owned [BL]");
    else
      {
        fail ("POLYLINE_PFACE.num_owned [BL] %u != %u", polyline_pface->num_owned, num_owned); error++;
      }
  }
  {
    BITCODE_BS numfaces;
    if (dwg_dynapi_entity_value(polyline_pface, "POLYLINE_PFACE", "numfaces", &numfaces, NULL) &&
        numfaces == polyline_pface->numfaces)
      pass ("POLYLINE_PFACE.numfaces [BS]");
    else
      {
        fail ("POLYLINE_PFACE.numfaces [BS] %d != %d", polyline_pface->numfaces, numfaces); error++;
      }
  }
  {
    BITCODE_BS numverts;
    if (dwg_dynapi_entity_value(polyline_pface, "POLYLINE_PFACE", "numverts", &numverts, NULL) &&
        numverts == polyline_pface->numverts)
      pass ("POLYLINE_PFACE.numverts [BS]");
    else
      {
        fail ("POLYLINE_PFACE.numverts [BS] %d != %d", polyline_pface->numverts, numverts); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(polyline_pface, "POLYLINE_PFACE", "parent", &parent, NULL)
        && !memcmp(&parent, &polyline_pface->parent, sizeof(polyline_pface->parent)))
      pass ("POLYLINE_PFACE.parent");
    else
      {
        fail ("POLYLINE_PFACE.parent"); error++;
      }
  }
  {
    Dwg_Object_Ref* seqend;
    if (dwg_dynapi_entity_value(polyline_pface, "POLYLINE_PFACE", "seqend", &seqend, NULL)
        && !memcmp(&seqend, &polyline_pface->seqend, sizeof(polyline_pface->seqend)))
      pass ("POLYLINE_PFACE.seqend");
    else
      {
        fail ("POLYLINE_PFACE.seqend"); error++;
      }
  }
  {
    Dwg_Object_Ref* vertex;
    if (dwg_dynapi_entity_value(polyline_pface, "POLYLINE_PFACE", "vertex", &vertex, NULL)
        && !memcmp(&vertex, &polyline_pface->vertex, sizeof(polyline_pface->vertex)))
      pass ("POLYLINE_PFACE.vertex");
    else
      {
        fail ("POLYLINE_PFACE.vertex"); error++;
      }
  }
  return error;
}
static int test_PROXY_ENTITY (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_PROXY_ENTITY *proxy_entity = obj->tio.entity->tio.PROXY_ENTITY;
  {
    BITCODE_BL class_id;
    if (dwg_dynapi_entity_value(proxy_entity, "PROXY_ENTITY", "class_id", &class_id, NULL) &&
        class_id == proxy_entity->class_id)
      pass ("PROXY_ENTITY.class_id [BL]");
    else
      {
        fail ("PROXY_ENTITY.class_id [BL] %u != %u", proxy_entity->class_id, class_id); error++;
      }
  }
  {
    BITCODE_TV data;
    if (dwg_dynapi_entity_value(proxy_entity, "PROXY_ENTITY", "data", &data, NULL)
        && !strcmp((char*)&data, (char*)&proxy_entity->data))
      pass ("PROXY_ENTITY.data");
    else
      {
        fail ("PROXY_ENTITY.data"); error++;
      }
  }
  {
    BITCODE_B from_dxf;
    if (dwg_dynapi_entity_value(proxy_entity, "PROXY_ENTITY", "from_dxf", &from_dxf, NULL) &&
        from_dxf == proxy_entity->from_dxf)
      pass ("PROXY_ENTITY.from_dxf [B]");
    else
      {
        fail ("PROXY_ENTITY.from_dxf [B] " FORMAT_B " != " FORMAT_B "", proxy_entity->from_dxf, from_dxf); error++;
      }
  }
  {
    BITCODE_BL maint_version;
    if (dwg_dynapi_entity_value(proxy_entity, "PROXY_ENTITY", "maint_version", &maint_version, NULL) &&
        maint_version == proxy_entity->maint_version)
      pass ("PROXY_ENTITY.maint_version [BL]");
    else
      {
        fail ("PROXY_ENTITY.maint_version [BL] %u != %u", proxy_entity->maint_version, maint_version); error++;
      }
  }
  {
    BITCODE_H* objid_object_handles;
    if (dwg_dynapi_entity_value(proxy_entity, "PROXY_ENTITY", "objid_object_handles", &objid_object_handles, NULL)
        && !memcmp(&objid_object_handles, &proxy_entity->objid_object_handles, sizeof(proxy_entity->objid_object_handles)))
      pass ("PROXY_ENTITY.objid_object_handles");
    else
      {
        fail ("PROXY_ENTITY.objid_object_handles"); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(proxy_entity, "PROXY_ENTITY", "ownerhandle", &ownerhandle, NULL) &&
        ownerhandle == proxy_entity->ownerhandle)
      pass ("PROXY_ENTITY.ownerhandle [H]");
    else
      {
        fail ("PROXY_ENTITY.ownerhandle [H] %p != %p", proxy_entity->ownerhandle, ownerhandle); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(proxy_entity, "PROXY_ENTITY", "parent", &parent, NULL)
        && !memcmp(&parent, &proxy_entity->parent, sizeof(proxy_entity->parent)))
      pass ("PROXY_ENTITY.parent");
    else
      {
        fail ("PROXY_ENTITY.parent"); error++;
      }
  }
  {
    BITCODE_MS size;
    if (dwg_dynapi_entity_value(proxy_entity, "PROXY_ENTITY", "size", &size, NULL) &&
        size == proxy_entity->size)
      pass ("PROXY_ENTITY.size [MS]");
    else
      {
        fail ("PROXY_ENTITY.size [MS] " FORMAT_MS " != " FORMAT_MS "", proxy_entity->size, size); error++;
      }
  }
  {
    BITCODE_BL version;
    if (dwg_dynapi_entity_value(proxy_entity, "PROXY_ENTITY", "version", &version, NULL) &&
        version == proxy_entity->version)
      pass ("PROXY_ENTITY.version [BL]");
    else
      {
        fail ("PROXY_ENTITY.version [BL] %u != %u", proxy_entity->version, version); error++;
      }
  }
  return error;
}
static int test_RAY (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_RAY *ray = obj->tio.entity->tio.RAY;
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(ray, "RAY", "parent", &parent, NULL)
        && !memcmp(&parent, &ray->parent, sizeof(ray->parent)))
      pass ("RAY.parent");
    else
      {
        fail ("RAY.parent"); error++;
      }
  }
  {
    BITCODE_3BD point;
    if (dwg_dynapi_entity_value(ray, "RAY", "point", &point, NULL)
        && !memcmp(&point, &ray->point, sizeof(ray->point)))
      pass ("RAY.point");
    else
      {
        fail ("RAY.point"); error++;
      }
  }
  {
    BITCODE_3BD vector;
    if (dwg_dynapi_entity_value(ray, "RAY", "vector", &vector, NULL)
        && !memcmp(&vector, &ray->vector, sizeof(ray->vector)))
      pass ("RAY.vector");
    else
      {
        fail ("RAY.vector"); error++;
      }
  }
  return error;
}
static int test_REVOLVEDSURFACE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_REVOLVEDSURFACE *revolvedsurface = obj->tio.entity->tio.REVOLVEDSURFACE;
  {
    unsigned char* acis_data;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "acis_data", &acis_data, NULL)
        && !strcmp((char*)&acis_data, (char*)&revolvedsurface->acis_data))
      pass ("REVOLVEDSURFACE.acis_data");
    else
      {
        fail ("REVOLVEDSURFACE.acis_data"); error++;
      }
  }
  {
    BITCODE_RC acis_empty;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "acis_empty", &acis_empty, NULL) &&
        acis_empty == revolvedsurface->acis_empty)
      pass ("REVOLVEDSURFACE.acis_empty [RC]");
    else
      {
        fail ("REVOLVEDSURFACE.acis_empty [RC] %c != %c", revolvedsurface->acis_empty, acis_empty); error++;
      }
  }
  {
    BITCODE_RC acis_empty2;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "acis_empty2", &acis_empty2, NULL) &&
        acis_empty2 == revolvedsurface->acis_empty2)
      pass ("REVOLVEDSURFACE.acis_empty2 [RC]");
    else
      {
        fail ("REVOLVEDSURFACE.acis_empty2 [RC] %c != %c", revolvedsurface->acis_empty2, acis_empty2); error++;
      }
  }
  {
    BITCODE_RC acis_empty_bit;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "acis_empty_bit", &acis_empty_bit, NULL) &&
        acis_empty_bit == revolvedsurface->acis_empty_bit)
      pass ("REVOLVEDSURFACE.acis_empty_bit [RC]");
    else
      {
        fail ("REVOLVEDSURFACE.acis_empty_bit [RC] %c != %c", revolvedsurface->acis_empty_bit, acis_empty_bit); error++;
      }
  }
  {
    BITCODE_3BD axis_point;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "axis_point", &axis_point, NULL)
        && !memcmp(&axis_point, &revolvedsurface->axis_point, sizeof(revolvedsurface->axis_point)))
      pass ("REVOLVEDSURFACE.axis_point");
    else
      {
        fail ("REVOLVEDSURFACE.axis_point"); error++;
      }
  }
  {
    BITCODE_3BD axis_vector;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "axis_vector", &axis_vector, NULL)
        && !memcmp(&axis_vector, &revolvedsurface->axis_vector, sizeof(revolvedsurface->axis_vector)))
      pass ("REVOLVEDSURFACE.axis_vector");
    else
      {
        fail ("REVOLVEDSURFACE.axis_vector"); error++;
      }
  }
  {
    unsigned int* block_size;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "block_size", &block_size, NULL)
        && !memcmp(&block_size, &revolvedsurface->block_size, sizeof(revolvedsurface->block_size)))
      pass ("REVOLVEDSURFACE.block_size");
    else
      {
        fail ("REVOLVEDSURFACE.block_size"); error++;
      }
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "class_version", &class_version, NULL) &&
        class_version == revolvedsurface->class_version)
      pass ("REVOLVEDSURFACE.class_version [BL]");
    else
      {
        fail ("REVOLVEDSURFACE.class_version [BL] %u != %u", revolvedsurface->class_version, class_version); error++;
      }
  }
  {
    BITCODE_B close_to_axis;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "close_to_axis", &close_to_axis, NULL) &&
        close_to_axis == revolvedsurface->close_to_axis)
      pass ("REVOLVEDSURFACE.close_to_axis [B]");
    else
      {
        fail ("REVOLVEDSURFACE.close_to_axis [B] " FORMAT_B " != " FORMAT_B "", revolvedsurface->close_to_axis, close_to_axis); error++;
      }
  }
  {
    BITCODE_BD draft_angle;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "draft_angle", &draft_angle, NULL) &&
        draft_angle == revolvedsurface->draft_angle)
      pass ("REVOLVEDSURFACE.draft_angle [BD]");
    else
      {
        fail ("REVOLVEDSURFACE.draft_angle [BD] %g != %g", revolvedsurface->draft_angle, draft_angle); error++;
      }
  }
  {
    BITCODE_BD draft_end_distance;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "draft_end_distance", &draft_end_distance, NULL) &&
        draft_end_distance == revolvedsurface->draft_end_distance)
      pass ("REVOLVEDSURFACE.draft_end_distance [BD]");
    else
      {
        fail ("REVOLVEDSURFACE.draft_end_distance [BD] %g != %g", revolvedsurface->draft_end_distance, draft_end_distance); error++;
      }
  }
  {
    BITCODE_BD draft_start_distance;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "draft_start_distance", &draft_start_distance, NULL) &&
        draft_start_distance == revolvedsurface->draft_start_distance)
      pass ("REVOLVEDSURFACE.draft_start_distance [BD]");
    else
      {
        fail ("REVOLVEDSURFACE.draft_start_distance [BD] %g != %g", revolvedsurface->draft_start_distance, draft_start_distance); error++;
      }
  }
  {
    BITCODE_TV encr_sat_data;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "encr_sat_data", &encr_sat_data, NULL)
        && !strcmp((char*)&encr_sat_data, (char*)&revolvedsurface->encr_sat_data))
      pass ("REVOLVEDSURFACE.encr_sat_data");
    else
      {
        fail ("REVOLVEDSURFACE.encr_sat_data"); error++;
      }
  }
  {
    struct _dwg_entity_3DSOLID* extra_acis_data;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "extra_acis_data", &extra_acis_data, NULL)
        && !memcmp(&extra_acis_data, &revolvedsurface->extra_acis_data, sizeof(revolvedsurface->extra_acis_data)))
      pass ("REVOLVEDSURFACE.extra_acis_data");
    else
      {
        fail ("REVOLVEDSURFACE.extra_acis_data"); error++;
      }
  }
  {
    Dwg_Object_Ref* history_id;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "history_id", &history_id, NULL)
        && !memcmp(&history_id, &revolvedsurface->history_id, sizeof(revolvedsurface->history_id)))
      pass ("REVOLVEDSURFACE.history_id");
    else
      {
        fail ("REVOLVEDSURFACE.history_id"); error++;
      }
  }
  {
    BITCODE_BL id;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "id", &id, NULL) &&
        id == revolvedsurface->id)
      pass ("REVOLVEDSURFACE.id [BL]");
    else
      {
        fail ("REVOLVEDSURFACE.id [BL] %u != %u", revolvedsurface->id, id); error++;
      }
  }
  {
    BITCODE_RC isoline_present;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "isoline_present", &isoline_present, NULL) &&
        isoline_present == revolvedsurface->isoline_present)
      pass ("REVOLVEDSURFACE.isoline_present [RC]");
    else
      {
        fail ("REVOLVEDSURFACE.isoline_present [RC] %c != %c", revolvedsurface->isoline_present, isoline_present); error++;
      }
  }
  {
    BITCODE_BS modeler_format_version;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "modeler_format_version", &modeler_format_version, NULL) &&
        modeler_format_version == revolvedsurface->modeler_format_version)
      pass ("REVOLVEDSURFACE.modeler_format_version [BS]");
    else
      {
        fail ("REVOLVEDSURFACE.modeler_format_version [BS] %d != %d", revolvedsurface->modeler_format_version, modeler_format_version); error++;
      }
  }
  {
    BITCODE_BL num_blocks;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "num_blocks", &num_blocks, NULL) &&
        num_blocks == revolvedsurface->num_blocks)
      pass ("REVOLVEDSURFACE.num_blocks [BL]");
    else
      {
        fail ("REVOLVEDSURFACE.num_blocks [BL] %u != %u", revolvedsurface->num_blocks, num_blocks); error++;
      }
  }
  {
    BITCODE_BL num_isolines;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "num_isolines", &num_isolines, NULL) &&
        num_isolines == revolvedsurface->num_isolines)
      pass ("REVOLVEDSURFACE.num_isolines [BL]");
    else
      {
        fail ("REVOLVEDSURFACE.num_isolines [BL] %u != %u", revolvedsurface->num_isolines, num_isolines); error++;
      }
  }
  {
    BITCODE_BL num_silhouettes;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "num_silhouettes", &num_silhouettes, NULL) &&
        num_silhouettes == revolvedsurface->num_silhouettes)
      pass ("REVOLVEDSURFACE.num_silhouettes [BL]");
    else
      {
        fail ("REVOLVEDSURFACE.num_silhouettes [BL] %u != %u", revolvedsurface->num_silhouettes, num_silhouettes); error++;
      }
  }
  {
    BITCODE_BL num_wires;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "num_wires", &num_wires, NULL) &&
        num_wires == revolvedsurface->num_wires)
      pass ("REVOLVEDSURFACE.num_wires [BL]");
    else
      {
        fail ("REVOLVEDSURFACE.num_wires [BL] %u != %u", revolvedsurface->num_wires, num_wires); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "parent", &parent, NULL)
        && !memcmp(&parent, &revolvedsurface->parent, sizeof(revolvedsurface->parent)))
      pass ("REVOLVEDSURFACE.parent");
    else
      {
        fail ("REVOLVEDSURFACE.parent"); error++;
      }
  }
  {
    Dwg_Bitcode_3BD point;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "point", &point, NULL)
        && !memcmp(&point, &revolvedsurface->point, sizeof(revolvedsurface->point)))
      pass ("REVOLVEDSURFACE.point");
    else
      {
        fail ("REVOLVEDSURFACE.point"); error++;
      }
  }
  {
    BITCODE_RC point_present;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "point_present", &point_present, NULL) &&
        point_present == revolvedsurface->point_present)
      pass ("REVOLVEDSURFACE.point_present [RC]");
    else
      {
        fail ("REVOLVEDSURFACE.point_present [RC] %c != %c", revolvedsurface->point_present, point_present); error++;
      }
  }
  {
    BITCODE_BD revolve_angle;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "revolve_angle", &revolve_angle, NULL) &&
        revolve_angle == revolvedsurface->revolve_angle)
      pass ("REVOLVEDSURFACE.revolve_angle [BD]");
    else
      {
        fail ("REVOLVEDSURFACE.revolve_angle [BD] %g != %g", revolvedsurface->revolve_angle, revolve_angle); error++;
      }
  }
  {
    BITCODE_BD* revolved_entity_transmatrix;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "revolved_entity_transmatrix", &revolved_entity_transmatrix, NULL)
        && !memcmp(&revolved_entity_transmatrix, &revolvedsurface->revolved_entity_transmatrix, sizeof(revolvedsurface->revolved_entity_transmatrix)))
      pass ("REVOLVEDSURFACE.revolved_entity_transmatrix");
    else
      {
        fail ("REVOLVEDSURFACE.revolved_entity_transmatrix"); error++;
      }
  }
  {
    Dwg_3DSOLID_silhouette* silhouettes;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "silhouettes", &silhouettes, NULL)
        && !memcmp(&silhouettes, &revolvedsurface->silhouettes, sizeof(revolvedsurface->silhouettes)))
      pass ("REVOLVEDSURFACE.silhouettes");
    else
      {
        fail ("REVOLVEDSURFACE.silhouettes"); error++;
      }
  }
  {
    BITCODE_B solid;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "solid", &solid, NULL) &&
        solid == revolvedsurface->solid)
      pass ("REVOLVEDSURFACE.solid [B]");
    else
      {
        fail ("REVOLVEDSURFACE.solid [B] " FORMAT_B " != " FORMAT_B "", revolvedsurface->solid, solid); error++;
      }
  }
  {
    BITCODE_BD start_angle;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "start_angle", &start_angle, NULL) &&
        start_angle == revolvedsurface->start_angle)
      pass ("REVOLVEDSURFACE.start_angle [BD]");
    else
      {
        fail ("REVOLVEDSURFACE.start_angle [BD] %g != %g", revolvedsurface->start_angle, start_angle); error++;
      }
  }
  {
    BITCODE_BD twist_angle;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "twist_angle", &twist_angle, NULL) &&
        twist_angle == revolvedsurface->twist_angle)
      pass ("REVOLVEDSURFACE.twist_angle [BD]");
    else
      {
        fail ("REVOLVEDSURFACE.twist_angle [BD] %g != %g", revolvedsurface->twist_angle, twist_angle); error++;
      }
  }
  {
    BITCODE_BS u_isolines;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "u_isolines", &u_isolines, NULL) &&
        u_isolines == revolvedsurface->u_isolines)
      pass ("REVOLVEDSURFACE.u_isolines [BS]");
    else
      {
        fail ("REVOLVEDSURFACE.u_isolines [BS] %d != %d", revolvedsurface->u_isolines, u_isolines); error++;
      }
  }
  {
    BITCODE_RC unknown;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "unknown", &unknown, NULL) &&
        unknown == revolvedsurface->unknown)
      pass ("REVOLVEDSURFACE.unknown [RC]");
    else
      {
        fail ("REVOLVEDSURFACE.unknown [RC] %c != %c", revolvedsurface->unknown, unknown); error++;
      }
  }
  {
    BITCODE_BL unknown_2007;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "unknown_2007", &unknown_2007, NULL) &&
        unknown_2007 == revolvedsurface->unknown_2007)
      pass ("REVOLVEDSURFACE.unknown_2007 [BL]");
    else
      {
        fail ("REVOLVEDSURFACE.unknown_2007 [BL] %u != %u", revolvedsurface->unknown_2007, unknown_2007); error++;
      }
  }
  {
    BITCODE_BS v_isolines;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "v_isolines", &v_isolines, NULL) &&
        v_isolines == revolvedsurface->v_isolines)
      pass ("REVOLVEDSURFACE.v_isolines [BS]");
    else
      {
        fail ("REVOLVEDSURFACE.v_isolines [BS] %d != %d", revolvedsurface->v_isolines, v_isolines); error++;
      }
  }
  {
    BITCODE_BS version;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "version", &version, NULL) &&
        version == revolvedsurface->version)
      pass ("REVOLVEDSURFACE.version [BS]");
    else
      {
        fail ("REVOLVEDSURFACE.version [BS] %d != %d", revolvedsurface->version, version); error++;
      }
  }
  {
    BITCODE_RC wireframe_data_present;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "wireframe_data_present", &wireframe_data_present, NULL) &&
        wireframe_data_present == revolvedsurface->wireframe_data_present)
      pass ("REVOLVEDSURFACE.wireframe_data_present [RC]");
    else
      {
        fail ("REVOLVEDSURFACE.wireframe_data_present [RC] %c != %c", revolvedsurface->wireframe_data_present, wireframe_data_present); error++;
      }
  }
  {
    Dwg_3DSOLID_wire* wires;
    if (dwg_dynapi_entity_value(revolvedsurface, "REVOLVEDSURFACE", "wires", &wires, NULL)
        && !memcmp(&wires, &revolvedsurface->wires, sizeof(revolvedsurface->wires)))
      pass ("REVOLVEDSURFACE.wires");
    else
      {
        fail ("REVOLVEDSURFACE.wires"); error++;
      }
  }
  return error;
}
static int test_SEQEND (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_SEQEND *seqend = obj->tio.entity->tio.SEQEND;
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(seqend, "SEQEND", "parent", &parent, NULL)
        && !memcmp(&parent, &seqend->parent, sizeof(seqend->parent)))
      pass ("SEQEND.parent");
    else
      {
        fail ("SEQEND.parent"); error++;
      }
  }
  return error;
}
static int test_SHAPE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_SHAPE *shape = obj->tio.entity->tio.SHAPE;
  {
    BITCODE_3BD extrusion;
    if (dwg_dynapi_entity_value(shape, "SHAPE", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &shape->extrusion, sizeof(shape->extrusion)))
      pass ("SHAPE.extrusion");
    else
      {
        fail ("SHAPE.extrusion"); error++;
      }
  }
  {
    BITCODE_3BD ins_pt;
    if (dwg_dynapi_entity_value(shape, "SHAPE", "ins_pt", &ins_pt, NULL)
        && !memcmp(&ins_pt, &shape->ins_pt, sizeof(shape->ins_pt)))
      pass ("SHAPE.ins_pt");
    else
      {
        fail ("SHAPE.ins_pt"); error++;
      }
  }
  {
    BITCODE_BD oblique;
    if (dwg_dynapi_entity_value(shape, "SHAPE", "oblique", &oblique, NULL) &&
        oblique == shape->oblique)
      pass ("SHAPE.oblique [BD]");
    else
      {
        fail ("SHAPE.oblique [BD] %g != %g", shape->oblique, oblique); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(shape, "SHAPE", "parent", &parent, NULL)
        && !memcmp(&parent, &shape->parent, sizeof(shape->parent)))
      pass ("SHAPE.parent");
    else
      {
        fail ("SHAPE.parent"); error++;
      }
  }
  {
    BITCODE_BD rotation;
    if (dwg_dynapi_entity_value(shape, "SHAPE", "rotation", &rotation, NULL) &&
        rotation == shape->rotation)
      pass ("SHAPE.rotation [BD]");
    else
      {
        fail ("SHAPE.rotation [BD] %g != %g", shape->rotation, rotation); error++;
      }
  }
  {
    BITCODE_BD scale;
    if (dwg_dynapi_entity_value(shape, "SHAPE", "scale", &scale, NULL) &&
        scale == shape->scale)
      pass ("SHAPE.scale [BD]");
    else
      {
        fail ("SHAPE.scale [BD] %g != %g", shape->scale, scale); error++;
      }
  }
  {
    BITCODE_BS shape_no;
    if (dwg_dynapi_entity_value(shape, "SHAPE", "shape_no", &shape_no, NULL) &&
        shape_no == shape->shape_no)
      pass ("SHAPE.shape_no [BS]");
    else
      {
        fail ("SHAPE.shape_no [BS] %d != %d", shape->shape_no, shape_no); error++;
      }
  }
  {
    BITCODE_H style;
    if (dwg_dynapi_entity_value(shape, "SHAPE", "style", &style, NULL) &&
        style == shape->style)
      pass ("SHAPE.style [H]");
    else
      {
        fail ("SHAPE.style [H] %p != %p", shape->style, style); error++;
      }
  }
  {
    BITCODE_BD thickness;
    if (dwg_dynapi_entity_value(shape, "SHAPE", "thickness", &thickness, NULL) &&
        thickness == shape->thickness)
      pass ("SHAPE.thickness [BD]");
    else
      {
        fail ("SHAPE.thickness [BD] %g != %g", shape->thickness, thickness); error++;
      }
  }
  {
    BITCODE_BD width_factor;
    if (dwg_dynapi_entity_value(shape, "SHAPE", "width_factor", &width_factor, NULL) &&
        width_factor == shape->width_factor)
      pass ("SHAPE.width_factor [BD]");
    else
      {
        fail ("SHAPE.width_factor [BD] %g != %g", shape->width_factor, width_factor); error++;
      }
  }
  return error;
}
static int test_SOLID (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_SOLID *solid = obj->tio.entity->tio.SOLID;
  {
    BITCODE_2RD corner1;
    if (dwg_dynapi_entity_value(solid, "SOLID", "corner1", &corner1, NULL)
        && !memcmp(&corner1, &solid->corner1, sizeof(solid->corner1)))
      pass ("SOLID.corner1");
    else
      {
        fail ("SOLID.corner1"); error++;
      }
  }
  {
    BITCODE_2RD corner2;
    if (dwg_dynapi_entity_value(solid, "SOLID", "corner2", &corner2, NULL)
        && !memcmp(&corner2, &solid->corner2, sizeof(solid->corner2)))
      pass ("SOLID.corner2");
    else
      {
        fail ("SOLID.corner2"); error++;
      }
  }
  {
    BITCODE_2RD corner3;
    if (dwg_dynapi_entity_value(solid, "SOLID", "corner3", &corner3, NULL)
        && !memcmp(&corner3, &solid->corner3, sizeof(solid->corner3)))
      pass ("SOLID.corner3");
    else
      {
        fail ("SOLID.corner3"); error++;
      }
  }
  {
    BITCODE_2RD corner4;
    if (dwg_dynapi_entity_value(solid, "SOLID", "corner4", &corner4, NULL)
        && !memcmp(&corner4, &solid->corner4, sizeof(solid->corner4)))
      pass ("SOLID.corner4");
    else
      {
        fail ("SOLID.corner4"); error++;
      }
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value(solid, "SOLID", "elevation", &elevation, NULL) &&
        elevation == solid->elevation)
      pass ("SOLID.elevation [BD]");
    else
      {
        fail ("SOLID.elevation [BD] %g != %g", solid->elevation, elevation); error++;
      }
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value(solid, "SOLID", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &solid->extrusion, sizeof(solid->extrusion)))
      pass ("SOLID.extrusion");
    else
      {
        fail ("SOLID.extrusion"); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(solid, "SOLID", "parent", &parent, NULL)
        && !memcmp(&parent, &solid->parent, sizeof(solid->parent)))
      pass ("SOLID.parent");
    else
      {
        fail ("SOLID.parent"); error++;
      }
  }
  {
    BITCODE_BT thickness;
    if (dwg_dynapi_entity_value(solid, "SOLID", "thickness", &thickness, NULL) &&
        thickness == solid->thickness)
      pass ("SOLID.thickness [BT]");
    else
      {
        fail ("SOLID.thickness [BT] " FORMAT_BT " != " FORMAT_BT "", solid->thickness, thickness); error++;
      }
  }
  return error;
}
static int test_SPLINE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_SPLINE *spline = obj->tio.entity->tio.SPLINE;
  {
    BITCODE_3BD beg_tan_vec;
    if (dwg_dynapi_entity_value(spline, "SPLINE", "beg_tan_vec", &beg_tan_vec, NULL)
        && !memcmp(&beg_tan_vec, &spline->beg_tan_vec, sizeof(spline->beg_tan_vec)))
      pass ("SPLINE.beg_tan_vec");
    else
      {
        fail ("SPLINE.beg_tan_vec"); error++;
      }
  }
  {
    BITCODE_B closed_b;
    if (dwg_dynapi_entity_value(spline, "SPLINE", "closed_b", &closed_b, NULL) &&
        closed_b == spline->closed_b)
      pass ("SPLINE.closed_b [B]");
    else
      {
        fail ("SPLINE.closed_b [B] " FORMAT_B " != " FORMAT_B "", spline->closed_b, closed_b); error++;
      }
  }
  {
    Dwg_SPLINE_control_point* ctrl_pts;
    if (dwg_dynapi_entity_value(spline, "SPLINE", "ctrl_pts", &ctrl_pts, NULL)
        && !memcmp(&ctrl_pts, &spline->ctrl_pts, sizeof(spline->ctrl_pts)))
      pass ("SPLINE.ctrl_pts");
    else
      {
        fail ("SPLINE.ctrl_pts"); error++;
      }
  }
  {
    BITCODE_BD ctrl_tol;
    if (dwg_dynapi_entity_value(spline, "SPLINE", "ctrl_tol", &ctrl_tol, NULL) &&
        ctrl_tol == spline->ctrl_tol)
      pass ("SPLINE.ctrl_tol [BD]");
    else
      {
        fail ("SPLINE.ctrl_tol [BD] %g != %g", spline->ctrl_tol, ctrl_tol); error++;
      }
  }
  {
    BITCODE_BS degree;
    if (dwg_dynapi_entity_value(spline, "SPLINE", "degree", &degree, NULL) &&
        degree == spline->degree)
      pass ("SPLINE.degree [BS]");
    else
      {
        fail ("SPLINE.degree [BS] %d != %d", spline->degree, degree); error++;
      }
  }
  {
    BITCODE_3BD end_tan_vec;
    if (dwg_dynapi_entity_value(spline, "SPLINE", "end_tan_vec", &end_tan_vec, NULL)
        && !memcmp(&end_tan_vec, &spline->end_tan_vec, sizeof(spline->end_tan_vec)))
      pass ("SPLINE.end_tan_vec");
    else
      {
        fail ("SPLINE.end_tan_vec"); error++;
      }
  }
  {
    Dwg_SPLINE_point* fit_pts;
    if (dwg_dynapi_entity_value(spline, "SPLINE", "fit_pts", &fit_pts, NULL)
        && !memcmp(&fit_pts, &spline->fit_pts, sizeof(spline->fit_pts)))
      pass ("SPLINE.fit_pts");
    else
      {
        fail ("SPLINE.fit_pts"); error++;
      }
  }
  {
    BITCODE_BD fit_tol;
    if (dwg_dynapi_entity_value(spline, "SPLINE", "fit_tol", &fit_tol, NULL) &&
        fit_tol == spline->fit_tol)
      pass ("SPLINE.fit_tol [BD]");
    else
      {
        fail ("SPLINE.fit_tol [BD] %g != %g", spline->fit_tol, fit_tol); error++;
      }
  }
  {
    BITCODE_RS flag;
    if (dwg_dynapi_entity_value(spline, "SPLINE", "flag", &flag, NULL) &&
        flag == spline->flag)
      pass ("SPLINE.flag [RS]");
    else
      {
        fail ("SPLINE.flag [RS] " FORMAT_RS " != " FORMAT_RS "", spline->flag, flag); error++;
      }
  }
  {
    BITCODE_BD knot_tol;
    if (dwg_dynapi_entity_value(spline, "SPLINE", "knot_tol", &knot_tol, NULL) &&
        knot_tol == spline->knot_tol)
      pass ("SPLINE.knot_tol [BD]");
    else
      {
        fail ("SPLINE.knot_tol [BD] %g != %g", spline->knot_tol, knot_tol); error++;
      }
  }
  {
    BITCODE_BL knotparam;
    if (dwg_dynapi_entity_value(spline, "SPLINE", "knotparam", &knotparam, NULL) &&
        knotparam == spline->knotparam)
      pass ("SPLINE.knotparam [BL]");
    else
      {
        fail ("SPLINE.knotparam [BL] %u != %u", spline->knotparam, knotparam); error++;
      }
  }
  {
    BITCODE_BD* knots;
    if (dwg_dynapi_entity_value(spline, "SPLINE", "knots", &knots, NULL)
        && !memcmp(&knots, &spline->knots, sizeof(spline->knots)))
      pass ("SPLINE.knots");
    else
      {
        fail ("SPLINE.knots"); error++;
      }
  }
  {
    BITCODE_BL num_ctrl_pts;
    if (dwg_dynapi_entity_value(spline, "SPLINE", "num_ctrl_pts", &num_ctrl_pts, NULL) &&
        num_ctrl_pts == spline->num_ctrl_pts)
      pass ("SPLINE.num_ctrl_pts [BL]");
    else
      {
        fail ("SPLINE.num_ctrl_pts [BL] %u != %u", spline->num_ctrl_pts, num_ctrl_pts); error++;
      }
  }
  {
    BITCODE_BS num_fit_pts;
    if (dwg_dynapi_entity_value(spline, "SPLINE", "num_fit_pts", &num_fit_pts, NULL) &&
        num_fit_pts == spline->num_fit_pts)
      pass ("SPLINE.num_fit_pts [BS]");
    else
      {
        fail ("SPLINE.num_fit_pts [BS] %d != %d", spline->num_fit_pts, num_fit_pts); error++;
      }
  }
  {
    BITCODE_BL num_knots;
    if (dwg_dynapi_entity_value(spline, "SPLINE", "num_knots", &num_knots, NULL) &&
        num_knots == spline->num_knots)
      pass ("SPLINE.num_knots [BL]");
    else
      {
        fail ("SPLINE.num_knots [BL] %u != %u", spline->num_knots, num_knots); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(spline, "SPLINE", "parent", &parent, NULL)
        && !memcmp(&parent, &spline->parent, sizeof(spline->parent)))
      pass ("SPLINE.parent");
    else
      {
        fail ("SPLINE.parent"); error++;
      }
  }
  {
    BITCODE_B periodic;
    if (dwg_dynapi_entity_value(spline, "SPLINE", "periodic", &periodic, NULL) &&
        periodic == spline->periodic)
      pass ("SPLINE.periodic [B]");
    else
      {
        fail ("SPLINE.periodic [B] " FORMAT_B " != " FORMAT_B "", spline->periodic, periodic); error++;
      }
  }
  {
    BITCODE_B rational;
    if (dwg_dynapi_entity_value(spline, "SPLINE", "rational", &rational, NULL) &&
        rational == spline->rational)
      pass ("SPLINE.rational [B]");
    else
      {
        fail ("SPLINE.rational [B] " FORMAT_B " != " FORMAT_B "", spline->rational, rational); error++;
      }
  }
  {
    BITCODE_BS scenario;
    if (dwg_dynapi_entity_value(spline, "SPLINE", "scenario", &scenario, NULL) &&
        scenario == spline->scenario)
      pass ("SPLINE.scenario [BS]");
    else
      {
        fail ("SPLINE.scenario [BS] %d != %d", spline->scenario, scenario); error++;
      }
  }
  {
    BITCODE_BL splineflags1;
    if (dwg_dynapi_entity_value(spline, "SPLINE", "splineflags1", &splineflags1, NULL) &&
        splineflags1 == spline->splineflags1)
      pass ("SPLINE.splineflags1 [BL]");
    else
      {
        fail ("SPLINE.splineflags1 [BL] %u != %u", spline->splineflags1, splineflags1); error++;
      }
  }
  {
    BITCODE_B weighted;
    if (dwg_dynapi_entity_value(spline, "SPLINE", "weighted", &weighted, NULL) &&
        weighted == spline->weighted)
      pass ("SPLINE.weighted [B]");
    else
      {
        fail ("SPLINE.weighted [B] " FORMAT_B " != " FORMAT_B "", spline->weighted, weighted); error++;
      }
  }
  return error;
}
static int test_SWEPTSURFACE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_SWEPTSURFACE *sweptsurface = obj->tio.entity->tio.SWEPTSURFACE;
  {
    unsigned char* acis_data;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "acis_data", &acis_data, NULL)
        && !strcmp((char*)&acis_data, (char*)&sweptsurface->acis_data))
      pass ("SWEPTSURFACE.acis_data");
    else
      {
        fail ("SWEPTSURFACE.acis_data"); error++;
      }
  }
  {
    BITCODE_RC acis_empty;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "acis_empty", &acis_empty, NULL) &&
        acis_empty == sweptsurface->acis_empty)
      pass ("SWEPTSURFACE.acis_empty [RC]");
    else
      {
        fail ("SWEPTSURFACE.acis_empty [RC] %c != %c", sweptsurface->acis_empty, acis_empty); error++;
      }
  }
  {
    BITCODE_RC acis_empty2;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "acis_empty2", &acis_empty2, NULL) &&
        acis_empty2 == sweptsurface->acis_empty2)
      pass ("SWEPTSURFACE.acis_empty2 [RC]");
    else
      {
        fail ("SWEPTSURFACE.acis_empty2 [RC] %c != %c", sweptsurface->acis_empty2, acis_empty2); error++;
      }
  }
  {
    BITCODE_RC acis_empty_bit;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "acis_empty_bit", &acis_empty_bit, NULL) &&
        acis_empty_bit == sweptsurface->acis_empty_bit)
      pass ("SWEPTSURFACE.acis_empty_bit [RC]");
    else
      {
        fail ("SWEPTSURFACE.acis_empty_bit [RC] %c != %c", sweptsurface->acis_empty_bit, acis_empty_bit); error++;
      }
  }
  {
    BITCODE_BD align_angle;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "align_angle", &align_angle, NULL) &&
        align_angle == sweptsurface->align_angle)
      pass ("SWEPTSURFACE.align_angle [BD]");
    else
      {
        fail ("SWEPTSURFACE.align_angle [BD] %g != %g", sweptsurface->align_angle, align_angle); error++;
      }
  }
  {
    BITCODE_B align_start;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "align_start", &align_start, NULL) &&
        align_start == sweptsurface->align_start)
      pass ("SWEPTSURFACE.align_start [B]");
    else
      {
        fail ("SWEPTSURFACE.align_start [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->align_start, align_start); error++;
      }
  }
  {
    BITCODE_B bank;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "bank", &bank, NULL) &&
        bank == sweptsurface->bank)
      pass ("SWEPTSURFACE.bank [B]");
    else
      {
        fail ("SWEPTSURFACE.bank [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->bank, bank); error++;
      }
  }
  {
    BITCODE_B base_point_set;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "base_point_set", &base_point_set, NULL) &&
        base_point_set == sweptsurface->base_point_set)
      pass ("SWEPTSURFACE.base_point_set [B]");
    else
      {
        fail ("SWEPTSURFACE.base_point_set [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->base_point_set, base_point_set); error++;
      }
  }
  {
    unsigned int* block_size;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "block_size", &block_size, NULL)
        && !memcmp(&block_size, &sweptsurface->block_size, sizeof(sweptsurface->block_size)))
      pass ("SWEPTSURFACE.block_size");
    else
      {
        fail ("SWEPTSURFACE.block_size"); error++;
      }
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "class_version", &class_version, NULL) &&
        class_version == sweptsurface->class_version)
      pass ("SWEPTSURFACE.class_version [BL]");
    else
      {
        fail ("SWEPTSURFACE.class_version [BL] %u != %u", sweptsurface->class_version, class_version); error++;
      }
  }
  {
    BITCODE_BD draft_angle;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "draft_angle", &draft_angle, NULL) &&
        draft_angle == sweptsurface->draft_angle)
      pass ("SWEPTSURFACE.draft_angle [BD]");
    else
      {
        fail ("SWEPTSURFACE.draft_angle [BD] %g != %g", sweptsurface->draft_angle, draft_angle); error++;
      }
  }
  {
    BITCODE_BD draft_end_distance;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "draft_end_distance", &draft_end_distance, NULL) &&
        draft_end_distance == sweptsurface->draft_end_distance)
      pass ("SWEPTSURFACE.draft_end_distance [BD]");
    else
      {
        fail ("SWEPTSURFACE.draft_end_distance [BD] %g != %g", sweptsurface->draft_end_distance, draft_end_distance); error++;
      }
  }
  {
    BITCODE_BD draft_start_distance;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "draft_start_distance", &draft_start_distance, NULL) &&
        draft_start_distance == sweptsurface->draft_start_distance)
      pass ("SWEPTSURFACE.draft_start_distance [BD]");
    else
      {
        fail ("SWEPTSURFACE.draft_start_distance [BD] %g != %g", sweptsurface->draft_start_distance, draft_start_distance); error++;
      }
  }
  {
    BITCODE_TV encr_sat_data;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "encr_sat_data", &encr_sat_data, NULL)
        && !strcmp((char*)&encr_sat_data, (char*)&sweptsurface->encr_sat_data))
      pass ("SWEPTSURFACE.encr_sat_data");
    else
      {
        fail ("SWEPTSURFACE.encr_sat_data"); error++;
      }
  }
  {
    struct _dwg_entity_3DSOLID* extra_acis_data;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "extra_acis_data", &extra_acis_data, NULL)
        && !memcmp(&extra_acis_data, &sweptsurface->extra_acis_data, sizeof(sweptsurface->extra_acis_data)))
      pass ("SWEPTSURFACE.extra_acis_data");
    else
      {
        fail ("SWEPTSURFACE.extra_acis_data"); error++;
      }
  }
  {
    Dwg_Object_Ref* history_id;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "history_id", &history_id, NULL)
        && !memcmp(&history_id, &sweptsurface->history_id, sizeof(sweptsurface->history_id)))
      pass ("SWEPTSURFACE.history_id");
    else
      {
        fail ("SWEPTSURFACE.history_id"); error++;
      }
  }
  {
    BITCODE_RC isoline_present;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "isoline_present", &isoline_present, NULL) &&
        isoline_present == sweptsurface->isoline_present)
      pass ("SWEPTSURFACE.isoline_present [RC]");
    else
      {
        fail ("SWEPTSURFACE.isoline_present [RC] %c != %c", sweptsurface->isoline_present, isoline_present); error++;
      }
  }
  {
    BITCODE_BS modeler_format_version;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "modeler_format_version", &modeler_format_version, NULL) &&
        modeler_format_version == sweptsurface->modeler_format_version)
      pass ("SWEPTSURFACE.modeler_format_version [BS]");
    else
      {
        fail ("SWEPTSURFACE.modeler_format_version [BS] %d != %d", sweptsurface->modeler_format_version, modeler_format_version); error++;
      }
  }
  {
    BITCODE_BL num_blocks;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "num_blocks", &num_blocks, NULL) &&
        num_blocks == sweptsurface->num_blocks)
      pass ("SWEPTSURFACE.num_blocks [BL]");
    else
      {
        fail ("SWEPTSURFACE.num_blocks [BL] %u != %u", sweptsurface->num_blocks, num_blocks); error++;
      }
  }
  {
    BITCODE_BL num_isolines;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "num_isolines", &num_isolines, NULL) &&
        num_isolines == sweptsurface->num_isolines)
      pass ("SWEPTSURFACE.num_isolines [BL]");
    else
      {
        fail ("SWEPTSURFACE.num_isolines [BL] %u != %u", sweptsurface->num_isolines, num_isolines); error++;
      }
  }
  {
    BITCODE_BL num_silhouettes;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "num_silhouettes", &num_silhouettes, NULL) &&
        num_silhouettes == sweptsurface->num_silhouettes)
      pass ("SWEPTSURFACE.num_silhouettes [BL]");
    else
      {
        fail ("SWEPTSURFACE.num_silhouettes [BL] %u != %u", sweptsurface->num_silhouettes, num_silhouettes); error++;
      }
  }
  {
    BITCODE_BL num_wires;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "num_wires", &num_wires, NULL) &&
        num_wires == sweptsurface->num_wires)
      pass ("SWEPTSURFACE.num_wires [BL]");
    else
      {
        fail ("SWEPTSURFACE.num_wires [BL] %u != %u", sweptsurface->num_wires, num_wires); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "parent", &parent, NULL)
        && !memcmp(&parent, &sweptsurface->parent, sizeof(sweptsurface->parent)))
      pass ("SWEPTSURFACE.parent");
    else
      {
        fail ("SWEPTSURFACE.parent"); error++;
      }
  }
  {
    BITCODE_BL path_entity_id;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "path_entity_id", &path_entity_id, NULL) &&
        path_entity_id == sweptsurface->path_entity_id)
      pass ("SWEPTSURFACE.path_entity_id [BL]");
    else
      {
        fail ("SWEPTSURFACE.path_entity_id [BL] %u != %u", sweptsurface->path_entity_id, path_entity_id); error++;
      }
  }
  {
    BITCODE_B path_entity_transform_computed;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "path_entity_transform_computed", &path_entity_transform_computed, NULL) &&
        path_entity_transform_computed == sweptsurface->path_entity_transform_computed)
      pass ("SWEPTSURFACE.path_entity_transform_computed [B]");
    else
      {
        fail ("SWEPTSURFACE.path_entity_transform_computed [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->path_entity_transform_computed, path_entity_transform_computed); error++;
      }
  }
  {
    BITCODE_BD* path_entity_transmatrix;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "path_entity_transmatrix", &path_entity_transmatrix, NULL)
        && !memcmp(&path_entity_transmatrix, &sweptsurface->path_entity_transmatrix, sizeof(sweptsurface->path_entity_transmatrix)))
      pass ("SWEPTSURFACE.path_entity_transmatrix");
    else
      {
        fail ("SWEPTSURFACE.path_entity_transmatrix"); error++;
      }
  }
  {
    BITCODE_BD* path_entity_transmatrix1;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "path_entity_transmatrix1", &path_entity_transmatrix1, NULL)
        && !memcmp(&path_entity_transmatrix1, &sweptsurface->path_entity_transmatrix1, sizeof(sweptsurface->path_entity_transmatrix1)))
      pass ("SWEPTSURFACE.path_entity_transmatrix1");
    else
      {
        fail ("SWEPTSURFACE.path_entity_transmatrix1"); error++;
      }
  }
  {
    BITCODE_TF pathdata;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "pathdata", &pathdata, NULL) &&
        pathdata == sweptsurface->pathdata)
      pass ("SWEPTSURFACE.pathdata [TF]");
    else
      {
        fail ("SWEPTSURFACE.pathdata [TF] " FORMAT_TF " != " FORMAT_TF "", sweptsurface->pathdata, pathdata); error++;
      }
  }
  {
    Dwg_Bitcode_3BD point;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "point", &point, NULL)
        && !memcmp(&point, &sweptsurface->point, sizeof(sweptsurface->point)))
      pass ("SWEPTSURFACE.point");
    else
      {
        fail ("SWEPTSURFACE.point"); error++;
      }
  }
  {
    BITCODE_RC point_present;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "point_present", &point_present, NULL) &&
        point_present == sweptsurface->point_present)
      pass ("SWEPTSURFACE.point_present [RC]");
    else
      {
        fail ("SWEPTSURFACE.point_present [RC] %c != %c", sweptsurface->point_present, point_present); error++;
      }
  }
  {
    BITCODE_3BD reference_vector_for_controlling_twist;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "reference_vector_for_controlling_twist", &reference_vector_for_controlling_twist, NULL)
        && !memcmp(&reference_vector_for_controlling_twist, &sweptsurface->reference_vector_for_controlling_twist, sizeof(sweptsurface->reference_vector_for_controlling_twist)))
      pass ("SWEPTSURFACE.reference_vector_for_controlling_twist");
    else
      {
        fail ("SWEPTSURFACE.reference_vector_for_controlling_twist"); error++;
      }
  }
  {
    BITCODE_BD scale_factor;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "scale_factor", &scale_factor, NULL) &&
        scale_factor == sweptsurface->scale_factor)
      pass ("SWEPTSURFACE.scale_factor [BD]");
    else
      {
        fail ("SWEPTSURFACE.scale_factor [BD] %g != %g", sweptsurface->scale_factor, scale_factor); error++;
      }
  }
  {
    Dwg_3DSOLID_silhouette* silhouettes;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "silhouettes", &silhouettes, NULL)
        && !memcmp(&silhouettes, &sweptsurface->silhouettes, sizeof(sweptsurface->silhouettes)))
      pass ("SWEPTSURFACE.silhouettes");
    else
      {
        fail ("SWEPTSURFACE.silhouettes"); error++;
      }
  }
  {
    BITCODE_BL size_pathdata;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "size_pathdata", &size_pathdata, NULL) &&
        size_pathdata == sweptsurface->size_pathdata)
      pass ("SWEPTSURFACE.size_pathdata [BL]");
    else
      {
        fail ("SWEPTSURFACE.size_pathdata [BL] %u != %u", sweptsurface->size_pathdata, size_pathdata); error++;
      }
  }
  {
    BITCODE_BL size_sweepdata;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "size_sweepdata", &size_sweepdata, NULL) &&
        size_sweepdata == sweptsurface->size_sweepdata)
      pass ("SWEPTSURFACE.size_sweepdata [BL]");
    else
      {
        fail ("SWEPTSURFACE.size_sweepdata [BL] %u != %u", sweptsurface->size_sweepdata, size_sweepdata); error++;
      }
  }
  {
    BITCODE_B solid;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "solid", &solid, NULL) &&
        solid == sweptsurface->solid)
      pass ("SWEPTSURFACE.solid [B]");
    else
      {
        fail ("SWEPTSURFACE.solid [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->solid, solid); error++;
      }
  }
  {
    BITCODE_RC sweep_alignment;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "sweep_alignment", &sweep_alignment, NULL) &&
        sweep_alignment == sweptsurface->sweep_alignment)
      pass ("SWEPTSURFACE.sweep_alignment [RC]");
    else
      {
        fail ("SWEPTSURFACE.sweep_alignment [RC] %c != %c", sweptsurface->sweep_alignment, sweep_alignment); error++;
      }
  }
  {
    BITCODE_BL sweep_entity_id;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "sweep_entity_id", &sweep_entity_id, NULL) &&
        sweep_entity_id == sweptsurface->sweep_entity_id)
      pass ("SWEPTSURFACE.sweep_entity_id [BL]");
    else
      {
        fail ("SWEPTSURFACE.sweep_entity_id [BL] %u != %u", sweptsurface->sweep_entity_id, sweep_entity_id); error++;
      }
  }
  {
    BITCODE_B sweep_entity_transform_computed;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "sweep_entity_transform_computed", &sweep_entity_transform_computed, NULL) &&
        sweep_entity_transform_computed == sweptsurface->sweep_entity_transform_computed)
      pass ("SWEPTSURFACE.sweep_entity_transform_computed [B]");
    else
      {
        fail ("SWEPTSURFACE.sweep_entity_transform_computed [B] " FORMAT_B " != " FORMAT_B "", sweptsurface->sweep_entity_transform_computed, sweep_entity_transform_computed); error++;
      }
  }
  {
    BITCODE_BD* sweep_entity_transmatrix;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "sweep_entity_transmatrix", &sweep_entity_transmatrix, NULL)
        && !memcmp(&sweep_entity_transmatrix, &sweptsurface->sweep_entity_transmatrix, sizeof(sweptsurface->sweep_entity_transmatrix)))
      pass ("SWEPTSURFACE.sweep_entity_transmatrix");
    else
      {
        fail ("SWEPTSURFACE.sweep_entity_transmatrix"); error++;
      }
  }
  {
    BITCODE_BD* sweep_entity_transmatrix1;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "sweep_entity_transmatrix1", &sweep_entity_transmatrix1, NULL)
        && !memcmp(&sweep_entity_transmatrix1, &sweptsurface->sweep_entity_transmatrix1, sizeof(sweptsurface->sweep_entity_transmatrix1)))
      pass ("SWEPTSURFACE.sweep_entity_transmatrix1");
    else
      {
        fail ("SWEPTSURFACE.sweep_entity_transmatrix1"); error++;
      }
  }
  {
    BITCODE_TF sweepdata;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "sweepdata", &sweepdata, NULL) &&
        sweepdata == sweptsurface->sweepdata)
      pass ("SWEPTSURFACE.sweepdata [TF]");
    else
      {
        fail ("SWEPTSURFACE.sweepdata [TF] " FORMAT_TF " != " FORMAT_TF "", sweptsurface->sweepdata, sweepdata); error++;
      }
  }
  {
    BITCODE_BD twist_angle;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "twist_angle", &twist_angle, NULL) &&
        twist_angle == sweptsurface->twist_angle)
      pass ("SWEPTSURFACE.twist_angle [BD]");
    else
      {
        fail ("SWEPTSURFACE.twist_angle [BD] %g != %g", sweptsurface->twist_angle, twist_angle); error++;
      }
  }
  {
    BITCODE_BS u_isolines;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "u_isolines", &u_isolines, NULL) &&
        u_isolines == sweptsurface->u_isolines)
      pass ("SWEPTSURFACE.u_isolines [BS]");
    else
      {
        fail ("SWEPTSURFACE.u_isolines [BS] %d != %d", sweptsurface->u_isolines, u_isolines); error++;
      }
  }
  {
    BITCODE_RC unknown;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "unknown", &unknown, NULL) &&
        unknown == sweptsurface->unknown)
      pass ("SWEPTSURFACE.unknown [RC]");
    else
      {
        fail ("SWEPTSURFACE.unknown [RC] %c != %c", sweptsurface->unknown, unknown); error++;
      }
  }
  {
    BITCODE_BL unknown_2007;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "unknown_2007", &unknown_2007, NULL) &&
        unknown_2007 == sweptsurface->unknown_2007)
      pass ("SWEPTSURFACE.unknown_2007 [BL]");
    else
      {
        fail ("SWEPTSURFACE.unknown_2007 [BL] %u != %u", sweptsurface->unknown_2007, unknown_2007); error++;
      }
  }
  {
    BITCODE_BS v_isolines;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "v_isolines", &v_isolines, NULL) &&
        v_isolines == sweptsurface->v_isolines)
      pass ("SWEPTSURFACE.v_isolines [BS]");
    else
      {
        fail ("SWEPTSURFACE.v_isolines [BS] %d != %d", sweptsurface->v_isolines, v_isolines); error++;
      }
  }
  {
    BITCODE_BS version;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "version", &version, NULL) &&
        version == sweptsurface->version)
      pass ("SWEPTSURFACE.version [BS]");
    else
      {
        fail ("SWEPTSURFACE.version [BS] %d != %d", sweptsurface->version, version); error++;
      }
  }
  {
    BITCODE_RC wireframe_data_present;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "wireframe_data_present", &wireframe_data_present, NULL) &&
        wireframe_data_present == sweptsurface->wireframe_data_present)
      pass ("SWEPTSURFACE.wireframe_data_present [RC]");
    else
      {
        fail ("SWEPTSURFACE.wireframe_data_present [RC] %c != %c", sweptsurface->wireframe_data_present, wireframe_data_present); error++;
      }
  }
  {
    Dwg_3DSOLID_wire* wires;
    if (dwg_dynapi_entity_value(sweptsurface, "SWEPTSURFACE", "wires", &wires, NULL)
        && !memcmp(&wires, &sweptsurface->wires, sizeof(sweptsurface->wires)))
      pass ("SWEPTSURFACE.wires");
    else
      {
        fail ("SWEPTSURFACE.wires"); error++;
      }
  }
  return error;
}
static int test_TABLE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_TABLE *table = obj->tio.entity->tio.TABLE;
  {
    BITCODE_H* attribs;
    if (dwg_dynapi_entity_value(table, "TABLE", "attribs", &attribs, NULL)
        && !memcmp(&attribs, &table->attribs, sizeof(table->attribs)))
      pass ("TABLE.attribs");
    else
      {
        fail ("TABLE.attribs"); error++;
      }
  }
  {
    BITCODE_H block_header;
    if (dwg_dynapi_entity_value(table, "TABLE", "block_header", &block_header, NULL) &&
        block_header == table->block_header)
      pass ("TABLE.block_header [H]");
    else
      {
        fail ("TABLE.block_header [H] %p != %p", table->block_header, block_header); error++;
      }
  }
  {
    BITCODE_BL border_color_overrides_flag;
    if (dwg_dynapi_entity_value(table, "TABLE", "border_color_overrides_flag", &border_color_overrides_flag, NULL) &&
        border_color_overrides_flag == table->border_color_overrides_flag)
      pass ("TABLE.border_color_overrides_flag [BL]");
    else
      {
        fail ("TABLE.border_color_overrides_flag [BL] %u != %u", table->border_color_overrides_flag, border_color_overrides_flag); error++;
      }
  }
  {
    BITCODE_BL border_lineweight_overrides_flag;
    if (dwg_dynapi_entity_value(table, "TABLE", "border_lineweight_overrides_flag", &border_lineweight_overrides_flag, NULL) &&
        border_lineweight_overrides_flag == table->border_lineweight_overrides_flag)
      pass ("TABLE.border_lineweight_overrides_flag [BL]");
    else
      {
        fail ("TABLE.border_lineweight_overrides_flag [BL] %u != %u", table->border_lineweight_overrides_flag, border_lineweight_overrides_flag); error++;
      }
  }
  {
    BITCODE_BL border_visibility_overrides_flag;
    if (dwg_dynapi_entity_value(table, "TABLE", "border_visibility_overrides_flag", &border_visibility_overrides_flag, NULL) &&
        border_visibility_overrides_flag == table->border_visibility_overrides_flag)
      pass ("TABLE.border_visibility_overrides_flag [BL]");
    else
      {
        fail ("TABLE.border_visibility_overrides_flag [BL] %u != %u", table->border_visibility_overrides_flag, border_visibility_overrides_flag); error++;
      }
  }
  {
    BITCODE_BL break_flag;
    if (dwg_dynapi_entity_value(table, "TABLE", "break_flag", &break_flag, NULL) &&
        break_flag == table->break_flag)
      pass ("TABLE.break_flag [BL]");
    else
      {
        fail ("TABLE.break_flag [BL] %u != %u", table->break_flag, break_flag); error++;
      }
  }
  {
    BITCODE_BL break_flow_direction;
    if (dwg_dynapi_entity_value(table, "TABLE", "break_flow_direction", &break_flow_direction, NULL) &&
        break_flow_direction == table->break_flow_direction)
      pass ("TABLE.break_flow_direction [BL]");
    else
      {
        fail ("TABLE.break_flow_direction [BL] %u != %u", table->break_flow_direction, break_flow_direction); error++;
      }
  }
  {
    Dwg_TABLE_BreakHeight* break_heights;
    if (dwg_dynapi_entity_value(table, "TABLE", "break_heights", &break_heights, NULL)
        && !memcmp(&break_heights, &table->break_heights, sizeof(table->break_heights)))
      pass ("TABLE.break_heights");
    else
      {
        fail ("TABLE.break_heights"); error++;
      }
  }
  {
    Dwg_TABLE_BreakRow* break_rows;
    if (dwg_dynapi_entity_value(table, "TABLE", "break_rows", &break_rows, NULL)
        && !memcmp(&break_rows, &table->break_rows, sizeof(table->break_rows)))
      pass ("TABLE.break_rows");
    else
      {
        fail ("TABLE.break_rows"); error++;
      }
  }
  {
    BITCODE_BD break_spacing;
    if (dwg_dynapi_entity_value(table, "TABLE", "break_spacing", &break_spacing, NULL) &&
        break_spacing == table->break_spacing)
      pass ("TABLE.break_spacing [BD]");
    else
      {
        fail ("TABLE.break_spacing [BD] %g != %g", table->break_spacing, break_spacing); error++;
      }
  }
  {
    BITCODE_BL break_unknown1;
    if (dwg_dynapi_entity_value(table, "TABLE", "break_unknown1", &break_unknown1, NULL) &&
        break_unknown1 == table->break_unknown1)
      pass ("TABLE.break_unknown1 [BL]");
    else
      {
        fail ("TABLE.break_unknown1 [BL] %u != %u", table->break_unknown1, break_unknown1); error++;
      }
  }
  {
    BITCODE_BL break_unknown2;
    if (dwg_dynapi_entity_value(table, "TABLE", "break_unknown2", &break_unknown2, NULL) &&
        break_unknown2 == table->break_unknown2)
      pass ("TABLE.break_unknown2 [BL]");
    else
      {
        fail ("TABLE.break_unknown2 [BL] %u != %u", table->break_unknown2, break_unknown2); error++;
      }
  }
  {
    Dwg_TABLE_Cell* cells;
    if (dwg_dynapi_entity_value(table, "TABLE", "cells", &cells, NULL)
        && !memcmp(&cells, &table->cells, sizeof(table->cells)))
      pass ("TABLE.cells");
    else
      {
        fail ("TABLE.cells"); error++;
      }
  }
  {
    BITCODE_BD* col_widths;
    if (dwg_dynapi_entity_value(table, "TABLE", "col_widths", &col_widths, NULL)
        && !memcmp(&col_widths, &table->col_widths, sizeof(table->col_widths)))
      pass ("TABLE.col_widths");
    else
      {
        fail ("TABLE.col_widths"); error++;
      }
  }
  {
    BITCODE_BB data_flags;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_flags", &data_flags, NULL) &&
        data_flags == table->data_flags)
      pass ("TABLE.data_flags [BB]");
    else
      {
        fail ("TABLE.data_flags [BB] " FORMAT_BB " != " FORMAT_BB "", table->data_flags, data_flags); error++;
      }
  }
  {
    BITCODE_CMC data_horiz_bottom_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_horiz_bottom_color", &data_horiz_bottom_color, NULL)
        && !memcmp(&data_horiz_bottom_color, &table->data_horiz_bottom_color, sizeof(table->data_horiz_bottom_color)))
      pass ("TABLE.data_horiz_bottom_color");
    else
      {
        fail ("TABLE.data_horiz_bottom_color"); error++;
      }
  }
  {
    BITCODE_BS data_horiz_bottom_linewt;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_horiz_bottom_linewt", &data_horiz_bottom_linewt, NULL) &&
        data_horiz_bottom_linewt == table->data_horiz_bottom_linewt)
      pass ("TABLE.data_horiz_bottom_linewt [BS]");
    else
      {
        fail ("TABLE.data_horiz_bottom_linewt [BS] %d != %d", table->data_horiz_bottom_linewt, data_horiz_bottom_linewt); error++;
      }
  }
  {
    BITCODE_BS data_horiz_bottom_visibility;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_horiz_bottom_visibility", &data_horiz_bottom_visibility, NULL) &&
        data_horiz_bottom_visibility == table->data_horiz_bottom_visibility)
      pass ("TABLE.data_horiz_bottom_visibility [BS]");
    else
      {
        fail ("TABLE.data_horiz_bottom_visibility [BS] %d != %d", table->data_horiz_bottom_visibility, data_horiz_bottom_visibility); error++;
      }
  }
  {
    BITCODE_CMC data_horiz_ins_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_horiz_ins_color", &data_horiz_ins_color, NULL)
        && !memcmp(&data_horiz_ins_color, &table->data_horiz_ins_color, sizeof(table->data_horiz_ins_color)))
      pass ("TABLE.data_horiz_ins_color");
    else
      {
        fail ("TABLE.data_horiz_ins_color"); error++;
      }
  }
  {
    BITCODE_BS data_horiz_ins_linewt;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_horiz_ins_linewt", &data_horiz_ins_linewt, NULL) &&
        data_horiz_ins_linewt == table->data_horiz_ins_linewt)
      pass ("TABLE.data_horiz_ins_linewt [BS]");
    else
      {
        fail ("TABLE.data_horiz_ins_linewt [BS] %d != %d", table->data_horiz_ins_linewt, data_horiz_ins_linewt); error++;
      }
  }
  {
    BITCODE_BS data_horiz_ins_visibility;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_horiz_ins_visibility", &data_horiz_ins_visibility, NULL) &&
        data_horiz_ins_visibility == table->data_horiz_ins_visibility)
      pass ("TABLE.data_horiz_ins_visibility [BS]");
    else
      {
        fail ("TABLE.data_horiz_ins_visibility [BS] %d != %d", table->data_horiz_ins_visibility, data_horiz_ins_visibility); error++;
      }
  }
  {
    BITCODE_CMC data_horiz_top_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_horiz_top_color", &data_horiz_top_color, NULL)
        && !memcmp(&data_horiz_top_color, &table->data_horiz_top_color, sizeof(table->data_horiz_top_color)))
      pass ("TABLE.data_horiz_top_color");
    else
      {
        fail ("TABLE.data_horiz_top_color"); error++;
      }
  }
  {
    BITCODE_BS data_horiz_top_linewt;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_horiz_top_linewt", &data_horiz_top_linewt, NULL) &&
        data_horiz_top_linewt == table->data_horiz_top_linewt)
      pass ("TABLE.data_horiz_top_linewt [BS]");
    else
      {
        fail ("TABLE.data_horiz_top_linewt [BS] %d != %d", table->data_horiz_top_linewt, data_horiz_top_linewt); error++;
      }
  }
  {
    BITCODE_BS data_horiz_top_visibility;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_horiz_top_visibility", &data_horiz_top_visibility, NULL) &&
        data_horiz_top_visibility == table->data_horiz_top_visibility)
      pass ("TABLE.data_horiz_top_visibility [BS]");
    else
      {
        fail ("TABLE.data_horiz_top_visibility [BS] %d != %d", table->data_horiz_top_visibility, data_horiz_top_visibility); error++;
      }
  }
  {
    BITCODE_BS data_row_alignment;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_row_alignment", &data_row_alignment, NULL) &&
        data_row_alignment == table->data_row_alignment)
      pass ("TABLE.data_row_alignment [BS]");
    else
      {
        fail ("TABLE.data_row_alignment [BS] %d != %d", table->data_row_alignment, data_row_alignment); error++;
      }
  }
  {
    BITCODE_CMC data_row_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_row_color", &data_row_color, NULL)
        && !memcmp(&data_row_color, &table->data_row_color, sizeof(table->data_row_color)))
      pass ("TABLE.data_row_color");
    else
      {
        fail ("TABLE.data_row_color"); error++;
      }
  }
  {
    BITCODE_CMC data_row_fill_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_row_fill_color", &data_row_fill_color, NULL)
        && !memcmp(&data_row_fill_color, &table->data_row_fill_color, sizeof(table->data_row_fill_color)))
      pass ("TABLE.data_row_fill_color");
    else
      {
        fail ("TABLE.data_row_fill_color"); error++;
      }
  }
  {
    BITCODE_B data_row_fill_none;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_row_fill_none", &data_row_fill_none, NULL) &&
        data_row_fill_none == table->data_row_fill_none)
      pass ("TABLE.data_row_fill_none [B]");
    else
      {
        fail ("TABLE.data_row_fill_none [B] " FORMAT_B " != " FORMAT_B "", table->data_row_fill_none, data_row_fill_none); error++;
      }
  }
  {
    BITCODE_BD data_row_height;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_row_height", &data_row_height, NULL) &&
        data_row_height == table->data_row_height)
      pass ("TABLE.data_row_height [BD]");
    else
      {
        fail ("TABLE.data_row_height [BD] %g != %g", table->data_row_height, data_row_height); error++;
      }
  }
  {
    BITCODE_H data_row_style_override;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_row_style_override", &data_row_style_override, NULL) &&
        data_row_style_override == table->data_row_style_override)
      pass ("TABLE.data_row_style_override [H]");
    else
      {
        fail ("TABLE.data_row_style_override [H] %p != %p", table->data_row_style_override, data_row_style_override); error++;
      }
  }
  {
    BITCODE_H data_text_style;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_text_style", &data_text_style, NULL) &&
        data_text_style == table->data_text_style)
      pass ("TABLE.data_text_style [H]");
    else
      {
        fail ("TABLE.data_text_style [H] %p != %p", table->data_text_style, data_text_style); error++;
      }
  }
  {
    BITCODE_CMC data_vert_ins_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_vert_ins_color", &data_vert_ins_color, NULL)
        && !memcmp(&data_vert_ins_color, &table->data_vert_ins_color, sizeof(table->data_vert_ins_color)))
      pass ("TABLE.data_vert_ins_color");
    else
      {
        fail ("TABLE.data_vert_ins_color"); error++;
      }
  }
  {
    BITCODE_BS data_vert_ins_linewt;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_vert_ins_linewt", &data_vert_ins_linewt, NULL) &&
        data_vert_ins_linewt == table->data_vert_ins_linewt)
      pass ("TABLE.data_vert_ins_linewt [BS]");
    else
      {
        fail ("TABLE.data_vert_ins_linewt [BS] %d != %d", table->data_vert_ins_linewt, data_vert_ins_linewt); error++;
      }
  }
  {
    BITCODE_BS data_vert_ins_visibility;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_vert_ins_visibility", &data_vert_ins_visibility, NULL) &&
        data_vert_ins_visibility == table->data_vert_ins_visibility)
      pass ("TABLE.data_vert_ins_visibility [BS]");
    else
      {
        fail ("TABLE.data_vert_ins_visibility [BS] %d != %d", table->data_vert_ins_visibility, data_vert_ins_visibility); error++;
      }
  }
  {
    BITCODE_CMC data_vert_left_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_vert_left_color", &data_vert_left_color, NULL)
        && !memcmp(&data_vert_left_color, &table->data_vert_left_color, sizeof(table->data_vert_left_color)))
      pass ("TABLE.data_vert_left_color");
    else
      {
        fail ("TABLE.data_vert_left_color"); error++;
      }
  }
  {
    BITCODE_BS data_vert_left_linewt;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_vert_left_linewt", &data_vert_left_linewt, NULL) &&
        data_vert_left_linewt == table->data_vert_left_linewt)
      pass ("TABLE.data_vert_left_linewt [BS]");
    else
      {
        fail ("TABLE.data_vert_left_linewt [BS] %d != %d", table->data_vert_left_linewt, data_vert_left_linewt); error++;
      }
  }
  {
    BITCODE_BS data_vert_left_visibility;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_vert_left_visibility", &data_vert_left_visibility, NULL) &&
        data_vert_left_visibility == table->data_vert_left_visibility)
      pass ("TABLE.data_vert_left_visibility [BS]");
    else
      {
        fail ("TABLE.data_vert_left_visibility [BS] %d != %d", table->data_vert_left_visibility, data_vert_left_visibility); error++;
      }
  }
  {
    BITCODE_CMC data_vert_right_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_vert_right_color", &data_vert_right_color, NULL)
        && !memcmp(&data_vert_right_color, &table->data_vert_right_color, sizeof(table->data_vert_right_color)))
      pass ("TABLE.data_vert_right_color");
    else
      {
        fail ("TABLE.data_vert_right_color"); error++;
      }
  }
  {
    BITCODE_BS data_vert_right_linewt;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_vert_right_linewt", &data_vert_right_linewt, NULL) &&
        data_vert_right_linewt == table->data_vert_right_linewt)
      pass ("TABLE.data_vert_right_linewt [BS]");
    else
      {
        fail ("TABLE.data_vert_right_linewt [BS] %d != %d", table->data_vert_right_linewt, data_vert_right_linewt); error++;
      }
  }
  {
    BITCODE_BS data_vert_right_visibility;
    if (dwg_dynapi_entity_value(table, "TABLE", "data_vert_right_visibility", &data_vert_right_visibility, NULL) &&
        data_vert_right_visibility == table->data_vert_right_visibility)
      pass ("TABLE.data_vert_right_visibility [BS]");
    else
      {
        fail ("TABLE.data_vert_right_visibility [BS] %d != %d", table->data_vert_right_visibility, data_vert_right_visibility); error++;
      }
  }
  {
    BITCODE_3BD extrusion;
    if (dwg_dynapi_entity_value(table, "TABLE", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &table->extrusion, sizeof(table->extrusion)))
      pass ("TABLE.extrusion");
    else
      {
        fail ("TABLE.extrusion"); error++;
      }
  }
  {
    BITCODE_H first_attrib;
    if (dwg_dynapi_entity_value(table, "TABLE", "first_attrib", &first_attrib, NULL) &&
        first_attrib == table->first_attrib)
      pass ("TABLE.first_attrib [H]");
    else
      {
        fail ("TABLE.first_attrib [H] %p != %p", table->first_attrib, first_attrib); error++;
      }
  }
  {
    BITCODE_BS flag_for_table_value;
    if (dwg_dynapi_entity_value(table, "TABLE", "flag_for_table_value", &flag_for_table_value, NULL) &&
        flag_for_table_value == table->flag_for_table_value)
      pass ("TABLE.flag_for_table_value [BS]");
    else
      {
        fail ("TABLE.flag_for_table_value [BS] %d != %d", table->flag_for_table_value, flag_for_table_value); error++;
      }
  }
  {
    BITCODE_BS flow_direction;
    if (dwg_dynapi_entity_value(table, "TABLE", "flow_direction", &flow_direction, NULL) &&
        flow_direction == table->flow_direction)
      pass ("TABLE.flow_direction [BS]");
    else
      {
        fail ("TABLE.flow_direction [BS] %d != %d", table->flow_direction, flow_direction); error++;
      }
  }
  {
    BITCODE_B has_attribs;
    if (dwg_dynapi_entity_value(table, "TABLE", "has_attribs", &has_attribs, NULL) &&
        has_attribs == table->has_attribs)
      pass ("TABLE.has_attribs [B]");
    else
      {
        fail ("TABLE.has_attribs [B] " FORMAT_B " != " FORMAT_B "", table->has_attribs, has_attribs); error++;
      }
  }
  {
    BITCODE_B has_border_color_overrides;
    if (dwg_dynapi_entity_value(table, "TABLE", "has_border_color_overrides", &has_border_color_overrides, NULL) &&
        has_border_color_overrides == table->has_border_color_overrides)
      pass ("TABLE.has_border_color_overrides [B]");
    else
      {
        fail ("TABLE.has_border_color_overrides [B] " FORMAT_B " != " FORMAT_B "", table->has_border_color_overrides, has_border_color_overrides); error++;
      }
  }
  {
    BITCODE_B has_border_lineweight_overrides;
    if (dwg_dynapi_entity_value(table, "TABLE", "has_border_lineweight_overrides", &has_border_lineweight_overrides, NULL) &&
        has_border_lineweight_overrides == table->has_border_lineweight_overrides)
      pass ("TABLE.has_border_lineweight_overrides [B]");
    else
      {
        fail ("TABLE.has_border_lineweight_overrides [B] " FORMAT_B " != " FORMAT_B "", table->has_border_lineweight_overrides, has_border_lineweight_overrides); error++;
      }
  }
  {
    BITCODE_B has_border_visibility_overrides;
    if (dwg_dynapi_entity_value(table, "TABLE", "has_border_visibility_overrides", &has_border_visibility_overrides, NULL) &&
        has_border_visibility_overrides == table->has_border_visibility_overrides)
      pass ("TABLE.has_border_visibility_overrides [B]");
    else
      {
        fail ("TABLE.has_border_visibility_overrides [B] " FORMAT_B " != " FORMAT_B "", table->has_border_visibility_overrides, has_border_visibility_overrides); error++;
      }
  }
  {
    BITCODE_BL has_break_data;
    if (dwg_dynapi_entity_value(table, "TABLE", "has_break_data", &has_break_data, NULL) &&
        has_break_data == table->has_break_data)
      pass ("TABLE.has_break_data [BL]");
    else
      {
        fail ("TABLE.has_break_data [BL] %u != %u", table->has_break_data, has_break_data); error++;
      }
  }
  {
    BITCODE_B has_table_overrides;
    if (dwg_dynapi_entity_value(table, "TABLE", "has_table_overrides", &has_table_overrides, NULL) &&
        has_table_overrides == table->has_table_overrides)
      pass ("TABLE.has_table_overrides [B]");
    else
      {
        fail ("TABLE.has_table_overrides [B] " FORMAT_B " != " FORMAT_B "", table->has_table_overrides, has_table_overrides); error++;
      }
  }
  {
    BITCODE_CMC header_horiz_bottom_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_horiz_bottom_color", &header_horiz_bottom_color, NULL)
        && !memcmp(&header_horiz_bottom_color, &table->header_horiz_bottom_color, sizeof(table->header_horiz_bottom_color)))
      pass ("TABLE.header_horiz_bottom_color");
    else
      {
        fail ("TABLE.header_horiz_bottom_color"); error++;
      }
  }
  {
    BITCODE_BS header_horiz_bottom_linewt;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_horiz_bottom_linewt", &header_horiz_bottom_linewt, NULL) &&
        header_horiz_bottom_linewt == table->header_horiz_bottom_linewt)
      pass ("TABLE.header_horiz_bottom_linewt [BS]");
    else
      {
        fail ("TABLE.header_horiz_bottom_linewt [BS] %d != %d", table->header_horiz_bottom_linewt, header_horiz_bottom_linewt); error++;
      }
  }
  {
    BITCODE_BS header_horiz_bottom_visibility;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_horiz_bottom_visibility", &header_horiz_bottom_visibility, NULL) &&
        header_horiz_bottom_visibility == table->header_horiz_bottom_visibility)
      pass ("TABLE.header_horiz_bottom_visibility [BS]");
    else
      {
        fail ("TABLE.header_horiz_bottom_visibility [BS] %d != %d", table->header_horiz_bottom_visibility, header_horiz_bottom_visibility); error++;
      }
  }
  {
    BITCODE_CMC header_horiz_ins_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_horiz_ins_color", &header_horiz_ins_color, NULL)
        && !memcmp(&header_horiz_ins_color, &table->header_horiz_ins_color, sizeof(table->header_horiz_ins_color)))
      pass ("TABLE.header_horiz_ins_color");
    else
      {
        fail ("TABLE.header_horiz_ins_color"); error++;
      }
  }
  {
    BITCODE_BS header_horiz_ins_linewt;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_horiz_ins_linewt", &header_horiz_ins_linewt, NULL) &&
        header_horiz_ins_linewt == table->header_horiz_ins_linewt)
      pass ("TABLE.header_horiz_ins_linewt [BS]");
    else
      {
        fail ("TABLE.header_horiz_ins_linewt [BS] %d != %d", table->header_horiz_ins_linewt, header_horiz_ins_linewt); error++;
      }
  }
  {
    BITCODE_BS header_horiz_ins_visibility;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_horiz_ins_visibility", &header_horiz_ins_visibility, NULL) &&
        header_horiz_ins_visibility == table->header_horiz_ins_visibility)
      pass ("TABLE.header_horiz_ins_visibility [BS]");
    else
      {
        fail ("TABLE.header_horiz_ins_visibility [BS] %d != %d", table->header_horiz_ins_visibility, header_horiz_ins_visibility); error++;
      }
  }
  {
    BITCODE_CMC header_horiz_top_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_horiz_top_color", &header_horiz_top_color, NULL)
        && !memcmp(&header_horiz_top_color, &table->header_horiz_top_color, sizeof(table->header_horiz_top_color)))
      pass ("TABLE.header_horiz_top_color");
    else
      {
        fail ("TABLE.header_horiz_top_color"); error++;
      }
  }
  {
    BITCODE_BS header_horiz_top_linewt;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_horiz_top_linewt", &header_horiz_top_linewt, NULL) &&
        header_horiz_top_linewt == table->header_horiz_top_linewt)
      pass ("TABLE.header_horiz_top_linewt [BS]");
    else
      {
        fail ("TABLE.header_horiz_top_linewt [BS] %d != %d", table->header_horiz_top_linewt, header_horiz_top_linewt); error++;
      }
  }
  {
    BITCODE_BS header_horiz_top_visibility;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_horiz_top_visibility", &header_horiz_top_visibility, NULL) &&
        header_horiz_top_visibility == table->header_horiz_top_visibility)
      pass ("TABLE.header_horiz_top_visibility [BS]");
    else
      {
        fail ("TABLE.header_horiz_top_visibility [BS] %d != %d", table->header_horiz_top_visibility, header_horiz_top_visibility); error++;
      }
  }
  {
    BITCODE_BS header_row_alignment;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_row_alignment", &header_row_alignment, NULL) &&
        header_row_alignment == table->header_row_alignment)
      pass ("TABLE.header_row_alignment [BS]");
    else
      {
        fail ("TABLE.header_row_alignment [BS] %d != %d", table->header_row_alignment, header_row_alignment); error++;
      }
  }
  {
    BITCODE_CMC header_row_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_row_color", &header_row_color, NULL)
        && !memcmp(&header_row_color, &table->header_row_color, sizeof(table->header_row_color)))
      pass ("TABLE.header_row_color");
    else
      {
        fail ("TABLE.header_row_color"); error++;
      }
  }
  {
    BITCODE_CMC header_row_fill_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_row_fill_color", &header_row_fill_color, NULL)
        && !memcmp(&header_row_fill_color, &table->header_row_fill_color, sizeof(table->header_row_fill_color)))
      pass ("TABLE.header_row_fill_color");
    else
      {
        fail ("TABLE.header_row_fill_color"); error++;
      }
  }
  {
    BITCODE_B header_row_fill_none;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_row_fill_none", &header_row_fill_none, NULL) &&
        header_row_fill_none == table->header_row_fill_none)
      pass ("TABLE.header_row_fill_none [B]");
    else
      {
        fail ("TABLE.header_row_fill_none [B] " FORMAT_B " != " FORMAT_B "", table->header_row_fill_none, header_row_fill_none); error++;
      }
  }
  {
    BITCODE_BD header_row_height;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_row_height", &header_row_height, NULL) &&
        header_row_height == table->header_row_height)
      pass ("TABLE.header_row_height [BD]");
    else
      {
        fail ("TABLE.header_row_height [BD] %g != %g", table->header_row_height, header_row_height); error++;
      }
  }
  {
    BITCODE_H header_row_style_override;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_row_style_override", &header_row_style_override, NULL) &&
        header_row_style_override == table->header_row_style_override)
      pass ("TABLE.header_row_style_override [H]");
    else
      {
        fail ("TABLE.header_row_style_override [H] %p != %p", table->header_row_style_override, header_row_style_override); error++;
      }
  }
  {
    BITCODE_B header_suppressed;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_suppressed", &header_suppressed, NULL) &&
        header_suppressed == table->header_suppressed)
      pass ("TABLE.header_suppressed [B]");
    else
      {
        fail ("TABLE.header_suppressed [B] " FORMAT_B " != " FORMAT_B "", table->header_suppressed, header_suppressed); error++;
      }
  }
  {
    BITCODE_H header_text_style;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_text_style", &header_text_style, NULL) &&
        header_text_style == table->header_text_style)
      pass ("TABLE.header_text_style [H]");
    else
      {
        fail ("TABLE.header_text_style [H] %p != %p", table->header_text_style, header_text_style); error++;
      }
  }
  {
    BITCODE_CMC header_vert_ins_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_vert_ins_color", &header_vert_ins_color, NULL)
        && !memcmp(&header_vert_ins_color, &table->header_vert_ins_color, sizeof(table->header_vert_ins_color)))
      pass ("TABLE.header_vert_ins_color");
    else
      {
        fail ("TABLE.header_vert_ins_color"); error++;
      }
  }
  {
    BITCODE_BS header_vert_ins_linewt;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_vert_ins_linewt", &header_vert_ins_linewt, NULL) &&
        header_vert_ins_linewt == table->header_vert_ins_linewt)
      pass ("TABLE.header_vert_ins_linewt [BS]");
    else
      {
        fail ("TABLE.header_vert_ins_linewt [BS] %d != %d", table->header_vert_ins_linewt, header_vert_ins_linewt); error++;
      }
  }
  {
    BITCODE_BS header_vert_ins_visibility;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_vert_ins_visibility", &header_vert_ins_visibility, NULL) &&
        header_vert_ins_visibility == table->header_vert_ins_visibility)
      pass ("TABLE.header_vert_ins_visibility [BS]");
    else
      {
        fail ("TABLE.header_vert_ins_visibility [BS] %d != %d", table->header_vert_ins_visibility, header_vert_ins_visibility); error++;
      }
  }
  {
    BITCODE_CMC header_vert_left_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_vert_left_color", &header_vert_left_color, NULL)
        && !memcmp(&header_vert_left_color, &table->header_vert_left_color, sizeof(table->header_vert_left_color)))
      pass ("TABLE.header_vert_left_color");
    else
      {
        fail ("TABLE.header_vert_left_color"); error++;
      }
  }
  {
    BITCODE_BS header_vert_left_linewt;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_vert_left_linewt", &header_vert_left_linewt, NULL) &&
        header_vert_left_linewt == table->header_vert_left_linewt)
      pass ("TABLE.header_vert_left_linewt [BS]");
    else
      {
        fail ("TABLE.header_vert_left_linewt [BS] %d != %d", table->header_vert_left_linewt, header_vert_left_linewt); error++;
      }
  }
  {
    BITCODE_BS header_vert_left_visibility;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_vert_left_visibility", &header_vert_left_visibility, NULL) &&
        header_vert_left_visibility == table->header_vert_left_visibility)
      pass ("TABLE.header_vert_left_visibility [BS]");
    else
      {
        fail ("TABLE.header_vert_left_visibility [BS] %d != %d", table->header_vert_left_visibility, header_vert_left_visibility); error++;
      }
  }
  {
    BITCODE_CMC header_vert_right_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_vert_right_color", &header_vert_right_color, NULL)
        && !memcmp(&header_vert_right_color, &table->header_vert_right_color, sizeof(table->header_vert_right_color)))
      pass ("TABLE.header_vert_right_color");
    else
      {
        fail ("TABLE.header_vert_right_color"); error++;
      }
  }
  {
    BITCODE_BS header_vert_right_linewt;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_vert_right_linewt", &header_vert_right_linewt, NULL) &&
        header_vert_right_linewt == table->header_vert_right_linewt)
      pass ("TABLE.header_vert_right_linewt [BS]");
    else
      {
        fail ("TABLE.header_vert_right_linewt [BS] %d != %d", table->header_vert_right_linewt, header_vert_right_linewt); error++;
      }
  }
  {
    BITCODE_BS header_vert_right_visibility;
    if (dwg_dynapi_entity_value(table, "TABLE", "header_vert_right_visibility", &header_vert_right_visibility, NULL) &&
        header_vert_right_visibility == table->header_vert_right_visibility)
      pass ("TABLE.header_vert_right_visibility [BS]");
    else
      {
        fail ("TABLE.header_vert_right_visibility [BS] %d != %d", table->header_vert_right_visibility, header_vert_right_visibility); error++;
      }
  }
  {
    BITCODE_3BD hor_dir;
    if (dwg_dynapi_entity_value(table, "TABLE", "hor_dir", &hor_dir, NULL)
        && !memcmp(&hor_dir, &table->hor_dir, sizeof(table->hor_dir)))
      pass ("TABLE.hor_dir");
    else
      {
        fail ("TABLE.hor_dir"); error++;
      }
  }
  {
    BITCODE_BD horiz_cell_margin;
    if (dwg_dynapi_entity_value(table, "TABLE", "horiz_cell_margin", &horiz_cell_margin, NULL) &&
        horiz_cell_margin == table->horiz_cell_margin)
      pass ("TABLE.horiz_cell_margin [BD]");
    else
      {
        fail ("TABLE.horiz_cell_margin [BD] %g != %g", table->horiz_cell_margin, horiz_cell_margin); error++;
      }
  }
  {
    BITCODE_3BD horiz_direction;
    if (dwg_dynapi_entity_value(table, "TABLE", "horiz_direction", &horiz_direction, NULL)
        && !memcmp(&horiz_direction, &table->horiz_direction, sizeof(table->horiz_direction)))
      pass ("TABLE.horiz_direction");
    else
      {
        fail ("TABLE.horiz_direction"); error++;
      }
  }
  {
    BITCODE_3BD insertion_point;
    if (dwg_dynapi_entity_value(table, "TABLE", "insertion_point", &insertion_point, NULL)
        && !memcmp(&insertion_point, &table->insertion_point, sizeof(table->insertion_point)))
      pass ("TABLE.insertion_point");
    else
      {
        fail ("TABLE.insertion_point"); error++;
      }
  }
  {
    BITCODE_H last_attrib;
    if (dwg_dynapi_entity_value(table, "TABLE", "last_attrib", &last_attrib, NULL) &&
        last_attrib == table->last_attrib)
      pass ("TABLE.last_attrib [H]");
    else
      {
        fail ("TABLE.last_attrib [H] %p != %p", table->last_attrib, last_attrib); error++;
      }
  }
  {
    BITCODE_BL num_break_heights;
    if (dwg_dynapi_entity_value(table, "TABLE", "num_break_heights", &num_break_heights, NULL) &&
        num_break_heights == table->num_break_heights)
      pass ("TABLE.num_break_heights [BL]");
    else
      {
        fail ("TABLE.num_break_heights [BL] %u != %u", table->num_break_heights, num_break_heights); error++;
      }
  }
  {
    BITCODE_BL num_break_rows;
    if (dwg_dynapi_entity_value(table, "TABLE", "num_break_rows", &num_break_rows, NULL) &&
        num_break_rows == table->num_break_rows)
      pass ("TABLE.num_break_rows [BL]");
    else
      {
        fail ("TABLE.num_break_rows [BL] %u != %u", table->num_break_rows, num_break_rows); error++;
      }
  }
  {
    unsigned long num_cells;
    if (dwg_dynapi_entity_value(table, "TABLE", "num_cells", &num_cells, NULL) &&
        num_cells == table->num_cells)
      pass ("TABLE.num_cells [unsigned long]");
    else
      {
        fail ("TABLE.num_cells [unsigned long] %p != %p", table->num_cells, num_cells); error++;
      }
  }
  {
    BITCODE_BL num_cols;
    if (dwg_dynapi_entity_value(table, "TABLE", "num_cols", &num_cols, NULL) &&
        num_cols == table->num_cols)
      pass ("TABLE.num_cols [BL]");
    else
      {
        fail ("TABLE.num_cols [BL] %u != %u", table->num_cols, num_cols); error++;
      }
  }
  {
    BITCODE_BL num_owned;
    if (dwg_dynapi_entity_value(table, "TABLE", "num_owned", &num_owned, NULL) &&
        num_owned == table->num_owned)
      pass ("TABLE.num_owned [BL]");
    else
      {
        fail ("TABLE.num_owned [BL] %u != %u", table->num_owned, num_owned); error++;
      }
  }
  {
    BITCODE_BL num_rows;
    if (dwg_dynapi_entity_value(table, "TABLE", "num_rows", &num_rows, NULL) &&
        num_rows == table->num_rows)
      pass ("TABLE.num_rows [BL]");
    else
      {
        fail ("TABLE.num_rows [BL] %u != %u", table->num_rows, num_rows); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(table, "TABLE", "parent", &parent, NULL)
        && !memcmp(&parent, &table->parent, sizeof(table->parent)))
      pass ("TABLE.parent");
    else
      {
        fail ("TABLE.parent"); error++;
      }
  }
  {
    BITCODE_BD rotation;
    if (dwg_dynapi_entity_value(table, "TABLE", "rotation", &rotation, NULL) &&
        rotation == table->rotation)
      pass ("TABLE.rotation [BD]");
    else
      {
        fail ("TABLE.rotation [BD] %g != %g", table->rotation, rotation); error++;
      }
  }
  {
    BITCODE_BD* row_heights;
    if (dwg_dynapi_entity_value(table, "TABLE", "row_heights", &row_heights, NULL)
        && !memcmp(&row_heights, &table->row_heights, sizeof(table->row_heights)))
      pass ("TABLE.row_heights");
    else
      {
        fail ("TABLE.row_heights"); error++;
      }
  }
  {
    BITCODE_3BD scale;
    if (dwg_dynapi_entity_value(table, "TABLE", "scale", &scale, NULL)
        && !memcmp(&scale, &table->scale, sizeof(table->scale)))
      pass ("TABLE.scale");
    else
      {
        fail ("TABLE.scale"); error++;
      }
  }
  {
    BITCODE_H seqend;
    if (dwg_dynapi_entity_value(table, "TABLE", "seqend", &seqend, NULL) &&
        seqend == table->seqend)
      pass ("TABLE.seqend [H]");
    else
      {
        fail ("TABLE.seqend [H] %p != %p", table->seqend, seqend); error++;
      }
  }
  {
    BITCODE_BL table_flag_override;
    if (dwg_dynapi_entity_value(table, "TABLE", "table_flag_override", &table_flag_override, NULL) &&
        table_flag_override == table->table_flag_override)
      pass ("TABLE.table_flag_override [BL]");
    else
      {
        fail ("TABLE.table_flag_override [BL] %u != %u", table->table_flag_override, table_flag_override); error++;
      }
  }
  {
    BITCODE_H table_style_id;
    if (dwg_dynapi_entity_value(table, "TABLE", "table_style_id", &table_style_id, NULL) &&
        table_style_id == table->table_style_id)
      pass ("TABLE.table_style_id [H]");
    else
      {
        fail ("TABLE.table_style_id [H] %p != %p", table->table_style_id, table_style_id); error++;
      }
  }
  {
    BITCODE_CMC title_horiz_bottom_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_horiz_bottom_color", &title_horiz_bottom_color, NULL)
        && !memcmp(&title_horiz_bottom_color, &table->title_horiz_bottom_color, sizeof(table->title_horiz_bottom_color)))
      pass ("TABLE.title_horiz_bottom_color");
    else
      {
        fail ("TABLE.title_horiz_bottom_color"); error++;
      }
  }
  {
    BITCODE_BS title_horiz_bottom_linewt;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_horiz_bottom_linewt", &title_horiz_bottom_linewt, NULL) &&
        title_horiz_bottom_linewt == table->title_horiz_bottom_linewt)
      pass ("TABLE.title_horiz_bottom_linewt [BS]");
    else
      {
        fail ("TABLE.title_horiz_bottom_linewt [BS] %d != %d", table->title_horiz_bottom_linewt, title_horiz_bottom_linewt); error++;
      }
  }
  {
    BITCODE_BS title_horiz_bottom_visibility;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_horiz_bottom_visibility", &title_horiz_bottom_visibility, NULL) &&
        title_horiz_bottom_visibility == table->title_horiz_bottom_visibility)
      pass ("TABLE.title_horiz_bottom_visibility [BS]");
    else
      {
        fail ("TABLE.title_horiz_bottom_visibility [BS] %d != %d", table->title_horiz_bottom_visibility, title_horiz_bottom_visibility); error++;
      }
  }
  {
    BITCODE_CMC title_horiz_ins_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_horiz_ins_color", &title_horiz_ins_color, NULL)
        && !memcmp(&title_horiz_ins_color, &table->title_horiz_ins_color, sizeof(table->title_horiz_ins_color)))
      pass ("TABLE.title_horiz_ins_color");
    else
      {
        fail ("TABLE.title_horiz_ins_color"); error++;
      }
  }
  {
    BITCODE_BS title_horiz_ins_linewt;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_horiz_ins_linewt", &title_horiz_ins_linewt, NULL) &&
        title_horiz_ins_linewt == table->title_horiz_ins_linewt)
      pass ("TABLE.title_horiz_ins_linewt [BS]");
    else
      {
        fail ("TABLE.title_horiz_ins_linewt [BS] %d != %d", table->title_horiz_ins_linewt, title_horiz_ins_linewt); error++;
      }
  }
  {
    BITCODE_BS title_horiz_ins_visibility;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_horiz_ins_visibility", &title_horiz_ins_visibility, NULL) &&
        title_horiz_ins_visibility == table->title_horiz_ins_visibility)
      pass ("TABLE.title_horiz_ins_visibility [BS]");
    else
      {
        fail ("TABLE.title_horiz_ins_visibility [BS] %d != %d", table->title_horiz_ins_visibility, title_horiz_ins_visibility); error++;
      }
  }
  {
    BITCODE_CMC title_horiz_top_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_horiz_top_color", &title_horiz_top_color, NULL)
        && !memcmp(&title_horiz_top_color, &table->title_horiz_top_color, sizeof(table->title_horiz_top_color)))
      pass ("TABLE.title_horiz_top_color");
    else
      {
        fail ("TABLE.title_horiz_top_color"); error++;
      }
  }
  {
    BITCODE_BS title_horiz_top_linewt;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_horiz_top_linewt", &title_horiz_top_linewt, NULL) &&
        title_horiz_top_linewt == table->title_horiz_top_linewt)
      pass ("TABLE.title_horiz_top_linewt [BS]");
    else
      {
        fail ("TABLE.title_horiz_top_linewt [BS] %d != %d", table->title_horiz_top_linewt, title_horiz_top_linewt); error++;
      }
  }
  {
    BITCODE_BS title_horiz_top_visibility;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_horiz_top_visibility", &title_horiz_top_visibility, NULL) &&
        title_horiz_top_visibility == table->title_horiz_top_visibility)
      pass ("TABLE.title_horiz_top_visibility [BS]");
    else
      {
        fail ("TABLE.title_horiz_top_visibility [BS] %d != %d", table->title_horiz_top_visibility, title_horiz_top_visibility); error++;
      }
  }
  {
    BITCODE_BS title_row_alignment;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_row_alignment", &title_row_alignment, NULL) &&
        title_row_alignment == table->title_row_alignment)
      pass ("TABLE.title_row_alignment [BS]");
    else
      {
        fail ("TABLE.title_row_alignment [BS] %d != %d", table->title_row_alignment, title_row_alignment); error++;
      }
  }
  {
    BITCODE_CMC title_row_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_row_color", &title_row_color, NULL)
        && !memcmp(&title_row_color, &table->title_row_color, sizeof(table->title_row_color)))
      pass ("TABLE.title_row_color");
    else
      {
        fail ("TABLE.title_row_color"); error++;
      }
  }
  {
    BITCODE_CMC title_row_fill_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_row_fill_color", &title_row_fill_color, NULL)
        && !memcmp(&title_row_fill_color, &table->title_row_fill_color, sizeof(table->title_row_fill_color)))
      pass ("TABLE.title_row_fill_color");
    else
      {
        fail ("TABLE.title_row_fill_color"); error++;
      }
  }
  {
    BITCODE_B title_row_fill_none;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_row_fill_none", &title_row_fill_none, NULL) &&
        title_row_fill_none == table->title_row_fill_none)
      pass ("TABLE.title_row_fill_none [B]");
    else
      {
        fail ("TABLE.title_row_fill_none [B] " FORMAT_B " != " FORMAT_B "", table->title_row_fill_none, title_row_fill_none); error++;
      }
  }
  {
    BITCODE_BD title_row_height;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_row_height", &title_row_height, NULL) &&
        title_row_height == table->title_row_height)
      pass ("TABLE.title_row_height [BD]");
    else
      {
        fail ("TABLE.title_row_height [BD] %g != %g", table->title_row_height, title_row_height); error++;
      }
  }
  {
    BITCODE_H title_row_style_override;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_row_style_override", &title_row_style_override, NULL) &&
        title_row_style_override == table->title_row_style_override)
      pass ("TABLE.title_row_style_override [H]");
    else
      {
        fail ("TABLE.title_row_style_override [H] %p != %p", table->title_row_style_override, title_row_style_override); error++;
      }
  }
  {
    BITCODE_B title_suppressed;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_suppressed", &title_suppressed, NULL) &&
        title_suppressed == table->title_suppressed)
      pass ("TABLE.title_suppressed [B]");
    else
      {
        fail ("TABLE.title_suppressed [B] " FORMAT_B " != " FORMAT_B "", table->title_suppressed, title_suppressed); error++;
      }
  }
  {
    BITCODE_H title_text_style;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_text_style", &title_text_style, NULL) &&
        title_text_style == table->title_text_style)
      pass ("TABLE.title_text_style [H]");
    else
      {
        fail ("TABLE.title_text_style [H] %p != %p", table->title_text_style, title_text_style); error++;
      }
  }
  {
    BITCODE_CMC title_vert_ins_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_vert_ins_color", &title_vert_ins_color, NULL)
        && !memcmp(&title_vert_ins_color, &table->title_vert_ins_color, sizeof(table->title_vert_ins_color)))
      pass ("TABLE.title_vert_ins_color");
    else
      {
        fail ("TABLE.title_vert_ins_color"); error++;
      }
  }
  {
    BITCODE_BS title_vert_ins_linewt;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_vert_ins_linewt", &title_vert_ins_linewt, NULL) &&
        title_vert_ins_linewt == table->title_vert_ins_linewt)
      pass ("TABLE.title_vert_ins_linewt [BS]");
    else
      {
        fail ("TABLE.title_vert_ins_linewt [BS] %d != %d", table->title_vert_ins_linewt, title_vert_ins_linewt); error++;
      }
  }
  {
    BITCODE_BS title_vert_ins_visibility;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_vert_ins_visibility", &title_vert_ins_visibility, NULL) &&
        title_vert_ins_visibility == table->title_vert_ins_visibility)
      pass ("TABLE.title_vert_ins_visibility [BS]");
    else
      {
        fail ("TABLE.title_vert_ins_visibility [BS] %d != %d", table->title_vert_ins_visibility, title_vert_ins_visibility); error++;
      }
  }
  {
    BITCODE_CMC title_vert_left_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_vert_left_color", &title_vert_left_color, NULL)
        && !memcmp(&title_vert_left_color, &table->title_vert_left_color, sizeof(table->title_vert_left_color)))
      pass ("TABLE.title_vert_left_color");
    else
      {
        fail ("TABLE.title_vert_left_color"); error++;
      }
  }
  {
    BITCODE_BS title_vert_left_linewt;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_vert_left_linewt", &title_vert_left_linewt, NULL) &&
        title_vert_left_linewt == table->title_vert_left_linewt)
      pass ("TABLE.title_vert_left_linewt [BS]");
    else
      {
        fail ("TABLE.title_vert_left_linewt [BS] %d != %d", table->title_vert_left_linewt, title_vert_left_linewt); error++;
      }
  }
  {
    BITCODE_BS title_vert_left_visibility;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_vert_left_visibility", &title_vert_left_visibility, NULL) &&
        title_vert_left_visibility == table->title_vert_left_visibility)
      pass ("TABLE.title_vert_left_visibility [BS]");
    else
      {
        fail ("TABLE.title_vert_left_visibility [BS] %d != %d", table->title_vert_left_visibility, title_vert_left_visibility); error++;
      }
  }
  {
    BITCODE_CMC title_vert_right_color;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_vert_right_color", &title_vert_right_color, NULL)
        && !memcmp(&title_vert_right_color, &table->title_vert_right_color, sizeof(table->title_vert_right_color)))
      pass ("TABLE.title_vert_right_color");
    else
      {
        fail ("TABLE.title_vert_right_color"); error++;
      }
  }
  {
    BITCODE_BS title_vert_right_linewt;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_vert_right_linewt", &title_vert_right_linewt, NULL) &&
        title_vert_right_linewt == table->title_vert_right_linewt)
      pass ("TABLE.title_vert_right_linewt [BS]");
    else
      {
        fail ("TABLE.title_vert_right_linewt [BS] %d != %d", table->title_vert_right_linewt, title_vert_right_linewt); error++;
      }
  }
  {
    BITCODE_BS title_vert_right_visibility;
    if (dwg_dynapi_entity_value(table, "TABLE", "title_vert_right_visibility", &title_vert_right_visibility, NULL) &&
        title_vert_right_visibility == table->title_vert_right_visibility)
      pass ("TABLE.title_vert_right_visibility [BS]");
    else
      {
        fail ("TABLE.title_vert_right_visibility [BS] %d != %d", table->title_vert_right_visibility, title_vert_right_visibility); error++;
      }
  }
  {
    BITCODE_B unknown_b;
    if (dwg_dynapi_entity_value(table, "TABLE", "unknown_b", &unknown_b, NULL) &&
        unknown_b == table->unknown_b)
      pass ("TABLE.unknown_b [B]");
    else
      {
        fail ("TABLE.unknown_b [B] " FORMAT_B " != " FORMAT_B "", table->unknown_b, unknown_b); error++;
      }
  }
  {
    BITCODE_BL unknown_bl;
    if (dwg_dynapi_entity_value(table, "TABLE", "unknown_bl", &unknown_bl, NULL) &&
        unknown_bl == table->unknown_bl)
      pass ("TABLE.unknown_bl [BL]");
    else
      {
        fail ("TABLE.unknown_bl [BL] %u != %u", table->unknown_bl, unknown_bl); error++;
      }
  }
  {
    BITCODE_BL unknown_bl1;
    if (dwg_dynapi_entity_value(table, "TABLE", "unknown_bl1", &unknown_bl1, NULL) &&
        unknown_bl1 == table->unknown_bl1)
      pass ("TABLE.unknown_bl1 [BL]");
    else
      {
        fail ("TABLE.unknown_bl1 [BL] %u != %u", table->unknown_bl1, unknown_bl1); error++;
      }
  }
  {
    BITCODE_BS unknown_bs;
    if (dwg_dynapi_entity_value(table, "TABLE", "unknown_bs", &unknown_bs, NULL) &&
        unknown_bs == table->unknown_bs)
      pass ("TABLE.unknown_bs [BS]");
    else
      {
        fail ("TABLE.unknown_bs [BS] %d != %d", table->unknown_bs, unknown_bs); error++;
      }
  }
  {
    BITCODE_H unknown_h;
    if (dwg_dynapi_entity_value(table, "TABLE", "unknown_h", &unknown_h, NULL) &&
        unknown_h == table->unknown_h)
      pass ("TABLE.unknown_h [H]");
    else
      {
        fail ("TABLE.unknown_h [H] %p != %p", table->unknown_h, unknown_h); error++;
      }
  }
  {
    BITCODE_RC unknown_rc;
    if (dwg_dynapi_entity_value(table, "TABLE", "unknown_rc", &unknown_rc, NULL) &&
        unknown_rc == table->unknown_rc)
      pass ("TABLE.unknown_rc [RC]");
    else
      {
        fail ("TABLE.unknown_rc [RC] %c != %c", table->unknown_rc, unknown_rc); error++;
      }
  }
  {
    BITCODE_BD vert_cell_margin;
    if (dwg_dynapi_entity_value(table, "TABLE", "vert_cell_margin", &vert_cell_margin, NULL) &&
        vert_cell_margin == table->vert_cell_margin)
      pass ("TABLE.vert_cell_margin [BD]");
    else
      {
        fail ("TABLE.vert_cell_margin [BD] %g != %g", table->vert_cell_margin, vert_cell_margin); error++;
      }
  }
  return error;
}
static int test_TEXT (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_TEXT *text = obj->tio.entity->tio.TEXT;
  {
    BITCODE_2DPOINT alignment_pt;
    if (dwg_dynapi_entity_value(text, "TEXT", "alignment_pt", &alignment_pt, NULL)
        && !memcmp(&alignment_pt, &text->alignment_pt, sizeof(text->alignment_pt)))
      pass ("TEXT.alignment_pt");
    else
      {
        fail ("TEXT.alignment_pt"); error++;
      }
  }
  {
    BITCODE_RC dataflags;
    if (dwg_dynapi_entity_value(text, "TEXT", "dataflags", &dataflags, NULL) &&
        dataflags == text->dataflags)
      pass ("TEXT.dataflags [RC]");
    else
      {
        fail ("TEXT.dataflags [RC] %c != %c", text->dataflags, dataflags); error++;
      }
  }
  {
    BITCODE_RD elevation;
    if (dwg_dynapi_entity_value(text, "TEXT", "elevation", &elevation, NULL) &&
        elevation == text->elevation)
      pass ("TEXT.elevation [RD]");
    else
      {
        fail ("TEXT.elevation [RD] " FORMAT_RD " != " FORMAT_RD "", text->elevation, elevation); error++;
      }
  }
  {
    BITCODE_3DPOINT extrusion;
    if (dwg_dynapi_entity_value(text, "TEXT", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &text->extrusion, sizeof(text->extrusion)))
      pass ("TEXT.extrusion");
    else
      {
        fail ("TEXT.extrusion"); error++;
      }
  }
  {
    BITCODE_BS generation;
    if (dwg_dynapi_entity_value(text, "TEXT", "generation", &generation, NULL) &&
        generation == text->generation)
      pass ("TEXT.generation [BS]");
    else
      {
        fail ("TEXT.generation [BS] %d != %d", text->generation, generation); error++;
      }
  }
  {
    BITCODE_RD height;
    if (dwg_dynapi_entity_value(text, "TEXT", "height", &height, NULL) &&
        height == text->height)
      pass ("TEXT.height [RD]");
    else
      {
        fail ("TEXT.height [RD] " FORMAT_RD " != " FORMAT_RD "", text->height, height); error++;
      }
  }
  {
    BITCODE_BS horiz_alignment;
    if (dwg_dynapi_entity_value(text, "TEXT", "horiz_alignment", &horiz_alignment, NULL) &&
        horiz_alignment == text->horiz_alignment)
      pass ("TEXT.horiz_alignment [BS]");
    else
      {
        fail ("TEXT.horiz_alignment [BS] %d != %d", text->horiz_alignment, horiz_alignment); error++;
      }
  }
  {
    BITCODE_2DPOINT insertion_pt;
    if (dwg_dynapi_entity_value(text, "TEXT", "insertion_pt", &insertion_pt, NULL)
        && !memcmp(&insertion_pt, &text->insertion_pt, sizeof(text->insertion_pt)))
      pass ("TEXT.insertion_pt");
    else
      {
        fail ("TEXT.insertion_pt"); error++;
      }
  }
  {
    BITCODE_RD oblique_ang;
    if (dwg_dynapi_entity_value(text, "TEXT", "oblique_ang", &oblique_ang, NULL) &&
        oblique_ang == text->oblique_ang)
      pass ("TEXT.oblique_ang [RD]");
    else
      {
        fail ("TEXT.oblique_ang [RD] " FORMAT_RD " != " FORMAT_RD "", text->oblique_ang, oblique_ang); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(text, "TEXT", "parent", &parent, NULL)
        && !memcmp(&parent, &text->parent, sizeof(text->parent)))
      pass ("TEXT.parent");
    else
      {
        fail ("TEXT.parent"); error++;
      }
  }
  {
    BITCODE_RD rotation;
    if (dwg_dynapi_entity_value(text, "TEXT", "rotation", &rotation, NULL) &&
        rotation == text->rotation)
      pass ("TEXT.rotation [RD]");
    else
      {
        fail ("TEXT.rotation [RD] " FORMAT_RD " != " FORMAT_RD "", text->rotation, rotation); error++;
      }
  }
  {
    BITCODE_H style;
    if (dwg_dynapi_entity_value(text, "TEXT", "style", &style, NULL) &&
        style == text->style)
      pass ("TEXT.style [H]");
    else
      {
        fail ("TEXT.style [H] %p != %p", text->style, style); error++;
      }
  }
  {
    BITCODE_TV text_value;
    if (dwg_dynapi_entity_value(text, "TEXT", "text_value", &text_value, NULL)
        && !strcmp((char*)&text_value, (char*)&text->text_value))
      pass ("TEXT.text_value");
    else
      {
        fail ("TEXT.text_value"); error++;
      }
  }
  {
    BITCODE_RD thickness;
    if (dwg_dynapi_entity_value(text, "TEXT", "thickness", &thickness, NULL) &&
        thickness == text->thickness)
      pass ("TEXT.thickness [RD]");
    else
      {
        fail ("TEXT.thickness [RD] " FORMAT_RD " != " FORMAT_RD "", text->thickness, thickness); error++;
      }
  }
  {
    BITCODE_BS vert_alignment;
    if (dwg_dynapi_entity_value(text, "TEXT", "vert_alignment", &vert_alignment, NULL) &&
        vert_alignment == text->vert_alignment)
      pass ("TEXT.vert_alignment [BS]");
    else
      {
        fail ("TEXT.vert_alignment [BS] %d != %d", text->vert_alignment, vert_alignment); error++;
      }
  }
  {
    BITCODE_RD width_factor;
    if (dwg_dynapi_entity_value(text, "TEXT", "width_factor", &width_factor, NULL) &&
        width_factor == text->width_factor)
      pass ("TEXT.width_factor [RD]");
    else
      {
        fail ("TEXT.width_factor [RD] " FORMAT_RD " != " FORMAT_RD "", text->width_factor, width_factor); error++;
      }
  }
  return error;
}
static int test_TOLERANCE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_TOLERANCE *tolerance = obj->tio.entity->tio.TOLERANCE;
  {
    BITCODE_BD dimgap;
    if (dwg_dynapi_entity_value(tolerance, "TOLERANCE", "dimgap", &dimgap, NULL) &&
        dimgap == tolerance->dimgap)
      pass ("TOLERANCE.dimgap [BD]");
    else
      {
        fail ("TOLERANCE.dimgap [BD] %g != %g", tolerance->dimgap, dimgap); error++;
      }
  }
  {
    BITCODE_H dimstyle;
    if (dwg_dynapi_entity_value(tolerance, "TOLERANCE", "dimstyle", &dimstyle, NULL) &&
        dimstyle == tolerance->dimstyle)
      pass ("TOLERANCE.dimstyle [H]");
    else
      {
        fail ("TOLERANCE.dimstyle [H] %p != %p", tolerance->dimstyle, dimstyle); error++;
      }
  }
  {
    BITCODE_3BD extrusion;
    if (dwg_dynapi_entity_value(tolerance, "TOLERANCE", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &tolerance->extrusion, sizeof(tolerance->extrusion)))
      pass ("TOLERANCE.extrusion");
    else
      {
        fail ("TOLERANCE.extrusion"); error++;
      }
  }
  {
    BITCODE_BD height;
    if (dwg_dynapi_entity_value(tolerance, "TOLERANCE", "height", &height, NULL) &&
        height == tolerance->height)
      pass ("TOLERANCE.height [BD]");
    else
      {
        fail ("TOLERANCE.height [BD] %g != %g", tolerance->height, height); error++;
      }
  }
  {
    BITCODE_3BD ins_pt;
    if (dwg_dynapi_entity_value(tolerance, "TOLERANCE", "ins_pt", &ins_pt, NULL)
        && !memcmp(&ins_pt, &tolerance->ins_pt, sizeof(tolerance->ins_pt)))
      pass ("TOLERANCE.ins_pt");
    else
      {
        fail ("TOLERANCE.ins_pt"); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(tolerance, "TOLERANCE", "parent", &parent, NULL)
        && !memcmp(&parent, &tolerance->parent, sizeof(tolerance->parent)))
      pass ("TOLERANCE.parent");
    else
      {
        fail ("TOLERANCE.parent"); error++;
      }
  }
  {
    BITCODE_TV text_string;
    if (dwg_dynapi_entity_value(tolerance, "TOLERANCE", "text_string", &text_string, NULL)
        && !strcmp((char*)&text_string, (char*)&tolerance->text_string))
      pass ("TOLERANCE.text_string");
    else
      {
        fail ("TOLERANCE.text_string"); error++;
      }
  }
  {
    BITCODE_BS unknown_short;
    if (dwg_dynapi_entity_value(tolerance, "TOLERANCE", "unknown_short", &unknown_short, NULL) &&
        unknown_short == tolerance->unknown_short)
      pass ("TOLERANCE.unknown_short [BS]");
    else
      {
        fail ("TOLERANCE.unknown_short [BS] %d != %d", tolerance->unknown_short, unknown_short); error++;
      }
  }
  {
    BITCODE_3BD x_direction;
    if (dwg_dynapi_entity_value(tolerance, "TOLERANCE", "x_direction", &x_direction, NULL)
        && !memcmp(&x_direction, &tolerance->x_direction, sizeof(tolerance->x_direction)))
      pass ("TOLERANCE.x_direction");
    else
      {
        fail ("TOLERANCE.x_direction"); error++;
      }
  }
  return error;
}
static int test_TRACE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_TRACE *trace = obj->tio.entity->tio.TRACE;
  {
    BITCODE_2RD corner1;
    if (dwg_dynapi_entity_value(trace, "TRACE", "corner1", &corner1, NULL)
        && !memcmp(&corner1, &trace->corner1, sizeof(trace->corner1)))
      pass ("TRACE.corner1");
    else
      {
        fail ("TRACE.corner1"); error++;
      }
  }
  {
    BITCODE_2RD corner2;
    if (dwg_dynapi_entity_value(trace, "TRACE", "corner2", &corner2, NULL)
        && !memcmp(&corner2, &trace->corner2, sizeof(trace->corner2)))
      pass ("TRACE.corner2");
    else
      {
        fail ("TRACE.corner2"); error++;
      }
  }
  {
    BITCODE_2RD corner3;
    if (dwg_dynapi_entity_value(trace, "TRACE", "corner3", &corner3, NULL)
        && !memcmp(&corner3, &trace->corner3, sizeof(trace->corner3)))
      pass ("TRACE.corner3");
    else
      {
        fail ("TRACE.corner3"); error++;
      }
  }
  {
    BITCODE_2RD corner4;
    if (dwg_dynapi_entity_value(trace, "TRACE", "corner4", &corner4, NULL)
        && !memcmp(&corner4, &trace->corner4, sizeof(trace->corner4)))
      pass ("TRACE.corner4");
    else
      {
        fail ("TRACE.corner4"); error++;
      }
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value(trace, "TRACE", "elevation", &elevation, NULL) &&
        elevation == trace->elevation)
      pass ("TRACE.elevation [BD]");
    else
      {
        fail ("TRACE.elevation [BD] %g != %g", trace->elevation, elevation); error++;
      }
  }
  {
    BITCODE_BE extrusion;
    if (dwg_dynapi_entity_value(trace, "TRACE", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &trace->extrusion, sizeof(trace->extrusion)))
      pass ("TRACE.extrusion");
    else
      {
        fail ("TRACE.extrusion"); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(trace, "TRACE", "parent", &parent, NULL)
        && !memcmp(&parent, &trace->parent, sizeof(trace->parent)))
      pass ("TRACE.parent");
    else
      {
        fail ("TRACE.parent"); error++;
      }
  }
  {
    BITCODE_BT thickness;
    if (dwg_dynapi_entity_value(trace, "TRACE", "thickness", &thickness, NULL) &&
        thickness == trace->thickness)
      pass ("TRACE.thickness [BT]");
    else
      {
        fail ("TRACE.thickness [BT] " FORMAT_BT " != " FORMAT_BT "", trace->thickness, thickness); error++;
      }
  }
  return error;
}
static int test_UNDERLAY (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_UNDERLAY *underlay = obj->tio.entity->tio.UNDERLAY;
  {
    BITCODE_BD angle;
    if (dwg_dynapi_entity_value(underlay, "UNDERLAY", "angle", &angle, NULL) &&
        angle == underlay->angle)
      pass ("UNDERLAY.angle [BD]");
    else
      {
        fail ("UNDERLAY.angle [BD] %g != %g", underlay->angle, angle); error++;
      }
  }
  {
    Dwg_Bitcode_2RD* clip_verts;
    if (dwg_dynapi_entity_value(underlay, "UNDERLAY", "clip_verts", &clip_verts, NULL)
        && !memcmp(&clip_verts, &underlay->clip_verts, sizeof(underlay->clip_verts)))
      pass ("UNDERLAY.clip_verts");
    else
      {
        fail ("UNDERLAY.clip_verts"); error++;
      }
  }
  {
    BITCODE_RC contrast;
    if (dwg_dynapi_entity_value(underlay, "UNDERLAY", "contrast", &contrast, NULL) &&
        contrast == underlay->contrast)
      pass ("UNDERLAY.contrast [RC]");
    else
      {
        fail ("UNDERLAY.contrast [RC] %c != %c", underlay->contrast, contrast); error++;
      }
  }
  {
    BITCODE_H definition_id;
    if (dwg_dynapi_entity_value(underlay, "UNDERLAY", "definition_id", &definition_id, NULL) &&
        definition_id == underlay->definition_id)
      pass ("UNDERLAY.definition_id [H]");
    else
      {
        fail ("UNDERLAY.definition_id [H] %p != %p", underlay->definition_id, definition_id); error++;
      }
  }
  {
    BITCODE_3BD extrusion;
    if (dwg_dynapi_entity_value(underlay, "UNDERLAY", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &underlay->extrusion, sizeof(underlay->extrusion)))
      pass ("UNDERLAY.extrusion");
    else
      {
        fail ("UNDERLAY.extrusion"); error++;
      }
  }
  {
    BITCODE_RC fade;
    if (dwg_dynapi_entity_value(underlay, "UNDERLAY", "fade", &fade, NULL) &&
        fade == underlay->fade)
      pass ("UNDERLAY.fade [RC]");
    else
      {
        fail ("UNDERLAY.fade [RC] %c != %c", underlay->fade, fade); error++;
      }
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value(underlay, "UNDERLAY", "flag", &flag, NULL) &&
        flag == underlay->flag)
      pass ("UNDERLAY.flag [RC]");
    else
      {
        fail ("UNDERLAY.flag [RC] %c != %c", underlay->flag, flag); error++;
      }
  }
  {
    BITCODE_3BD insertion_pt;
    if (dwg_dynapi_entity_value(underlay, "UNDERLAY", "insertion_pt", &insertion_pt, NULL)
        && !memcmp(&insertion_pt, &underlay->insertion_pt, sizeof(underlay->insertion_pt)))
      pass ("UNDERLAY.insertion_pt");
    else
      {
        fail ("UNDERLAY.insertion_pt"); error++;
      }
  }
  {
    BITCODE_BL num_clip_verts;
    if (dwg_dynapi_entity_value(underlay, "UNDERLAY", "num_clip_verts", &num_clip_verts, NULL) &&
        num_clip_verts == underlay->num_clip_verts)
      pass ("UNDERLAY.num_clip_verts [BL]");
    else
      {
        fail ("UNDERLAY.num_clip_verts [BL] %u != %u", underlay->num_clip_verts, num_clip_verts); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(underlay, "UNDERLAY", "parent", &parent, NULL)
        && !memcmp(&parent, &underlay->parent, sizeof(underlay->parent)))
      pass ("UNDERLAY.parent");
    else
      {
        fail ("UNDERLAY.parent"); error++;
      }
  }
  {
    BITCODE_3BD scale;
    if (dwg_dynapi_entity_value(underlay, "UNDERLAY", "scale", &scale, NULL)
        && !memcmp(&scale, &underlay->scale, sizeof(underlay->scale)))
      pass ("UNDERLAY.scale");
    else
      {
        fail ("UNDERLAY.scale"); error++;
      }
  }
  {
    BITCODE_H underlay_layer;
    if (dwg_dynapi_entity_value(underlay, "UNDERLAY", "underlay_layer", &underlay_layer, NULL) &&
        underlay_layer == underlay->underlay_layer)
      pass ("UNDERLAY.underlay_layer [H]");
    else
      {
        fail ("UNDERLAY.underlay_layer [H] %p != %p", underlay->underlay_layer, underlay_layer); error++;
      }
  }
  return error;
}
static int test_UNKNOWN_ENT (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_UNKNOWN_ENT *unknown_ent = obj->tio.entity->tio.UNKNOWN_ENT;
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(unknown_ent, "UNKNOWN_ENT", "parent", &parent, NULL)
        && !memcmp(&parent, &unknown_ent->parent, sizeof(unknown_ent->parent)))
      pass ("UNKNOWN_ENT.parent");
    else
      {
        fail ("UNKNOWN_ENT.parent"); error++;
      }
  }
  return error;
}
static int test_VERTEX_2D (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_VERTEX_2D *vertex_2d = obj->tio.entity->tio.VERTEX_2D;
  {
    BITCODE_BD bulge;
    if (dwg_dynapi_entity_value(vertex_2d, "VERTEX_2D", "bulge", &bulge, NULL) &&
        bulge == vertex_2d->bulge)
      pass ("VERTEX_2D.bulge [BD]");
    else
      {
        fail ("VERTEX_2D.bulge [BD] %g != %g", vertex_2d->bulge, bulge); error++;
      }
  }
  {
    BITCODE_BD end_width;
    if (dwg_dynapi_entity_value(vertex_2d, "VERTEX_2D", "end_width", &end_width, NULL) &&
        end_width == vertex_2d->end_width)
      pass ("VERTEX_2D.end_width [BD]");
    else
      {
        fail ("VERTEX_2D.end_width [BD] %g != %g", vertex_2d->end_width, end_width); error++;
      }
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value(vertex_2d, "VERTEX_2D", "flag", &flag, NULL) &&
        flag == vertex_2d->flag)
      pass ("VERTEX_2D.flag [RC]");
    else
      {
        fail ("VERTEX_2D.flag [RC] %c != %c", vertex_2d->flag, flag); error++;
      }
  }
  {
    BITCODE_BL id;
    if (dwg_dynapi_entity_value(vertex_2d, "VERTEX_2D", "id", &id, NULL) &&
        id == vertex_2d->id)
      pass ("VERTEX_2D.id [BL]");
    else
      {
        fail ("VERTEX_2D.id [BL] %u != %u", vertex_2d->id, id); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(vertex_2d, "VERTEX_2D", "parent", &parent, NULL)
        && !memcmp(&parent, &vertex_2d->parent, sizeof(vertex_2d->parent)))
      pass ("VERTEX_2D.parent");
    else
      {
        fail ("VERTEX_2D.parent"); error++;
      }
  }
  {
    BITCODE_3BD point;
    if (dwg_dynapi_entity_value(vertex_2d, "VERTEX_2D", "point", &point, NULL)
        && !memcmp(&point, &vertex_2d->point, sizeof(vertex_2d->point)))
      pass ("VERTEX_2D.point");
    else
      {
        fail ("VERTEX_2D.point"); error++;
      }
  }
  {
    BITCODE_BD start_width;
    if (dwg_dynapi_entity_value(vertex_2d, "VERTEX_2D", "start_width", &start_width, NULL) &&
        start_width == vertex_2d->start_width)
      pass ("VERTEX_2D.start_width [BD]");
    else
      {
        fail ("VERTEX_2D.start_width [BD] %g != %g", vertex_2d->start_width, start_width); error++;
      }
  }
  {
    BITCODE_BD tangent_dir;
    if (dwg_dynapi_entity_value(vertex_2d, "VERTEX_2D", "tangent_dir", &tangent_dir, NULL) &&
        tangent_dir == vertex_2d->tangent_dir)
      pass ("VERTEX_2D.tangent_dir [BD]");
    else
      {
        fail ("VERTEX_2D.tangent_dir [BD] %g != %g", vertex_2d->tangent_dir, tangent_dir); error++;
      }
  }
  return error;
}
static int test_VERTEX_3D (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_VERTEX_3D *vertex_3d = obj->tio.entity->tio.VERTEX_3D;
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value(vertex_3d, "VERTEX_3D", "flag", &flag, NULL) &&
        flag == vertex_3d->flag)
      pass ("VERTEX_3D.flag [RC]");
    else
      {
        fail ("VERTEX_3D.flag [RC] %c != %c", vertex_3d->flag, flag); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(vertex_3d, "VERTEX_3D", "parent", &parent, NULL)
        && !memcmp(&parent, &vertex_3d->parent, sizeof(vertex_3d->parent)))
      pass ("VERTEX_3D.parent");
    else
      {
        fail ("VERTEX_3D.parent"); error++;
      }
  }
  {
    BITCODE_3BD point;
    if (dwg_dynapi_entity_value(vertex_3d, "VERTEX_3D", "point", &point, NULL)
        && !memcmp(&point, &vertex_3d->point, sizeof(vertex_3d->point)))
      pass ("VERTEX_3D.point");
    else
      {
        fail ("VERTEX_3D.point"); error++;
      }
  }
  return error;
}
static int test_VERTEX_PFACE_FACE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_VERTEX_PFACE_FACE *vertex_pface_face = obj->tio.entity->tio.VERTEX_PFACE_FACE;
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(vertex_pface_face, "VERTEX_PFACE_FACE", "parent", &parent, NULL)
        && !memcmp(&parent, &vertex_pface_face->parent, sizeof(vertex_pface_face->parent)))
      pass ("VERTEX_PFACE_FACE.parent");
    else
      {
        fail ("VERTEX_PFACE_FACE.parent"); error++;
      }
  }
  {
    BITCODE_BS vertind[4];
    if (dwg_dynapi_entity_value(vertex_pface_face, "VERTEX_PFACE_FACE", "vertind[4]", &vertind, NULL)
        && !memcmp(&vertind, &vertex_pface_face->vertind, sizeof(vertex_pface_face->vertind)))
      pass ("VERTEX_PFACE_FACE.vertind[4]");
    else
      {
        fail ("VERTEX_PFACE_FACE.vertind[4]"); error++;
      }
  }
  return error;
}
static int test_VIEWPORT (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_VIEWPORT *viewport = obj->tio.entity->tio.VIEWPORT;
  {
    BITCODE_CMC ambient_color;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "ambient_color", &ambient_color, NULL)
        && !memcmp(&ambient_color, &viewport->ambient_color, sizeof(viewport->ambient_color)))
      pass ("VIEWPORT.ambient_color");
    else
      {
        fail ("VIEWPORT.ambient_color"); error++;
      }
  }
  {
    BITCODE_BD back_clip_z;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "back_clip_z", &back_clip_z, NULL) &&
        back_clip_z == viewport->back_clip_z)
      pass ("VIEWPORT.back_clip_z [BD]");
    else
      {
        fail ("VIEWPORT.back_clip_z [BD] %g != %g", viewport->back_clip_z, back_clip_z); error++;
      }
  }
  {
    BITCODE_BD brightness;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "brightness", &brightness, NULL) &&
        brightness == viewport->brightness)
      pass ("VIEWPORT.brightness [BD]");
    else
      {
        fail ("VIEWPORT.brightness [BD] %g != %g", viewport->brightness, brightness); error++;
      }
  }
  {
    BITCODE_3BD center;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "center", &center, NULL)
        && !memcmp(&center, &viewport->center, sizeof(viewport->center)))
      pass ("VIEWPORT.center");
    else
      {
        fail ("VIEWPORT.center"); error++;
      }
  }
  {
    BITCODE_BS circle_zoom;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "circle_zoom", &circle_zoom, NULL) &&
        circle_zoom == viewport->circle_zoom)
      pass ("VIEWPORT.circle_zoom [BS]");
    else
      {
        fail ("VIEWPORT.circle_zoom [BS] %d != %d", viewport->circle_zoom, circle_zoom); error++;
      }
  }
  {
    BITCODE_BD contrast;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "contrast", &contrast, NULL) &&
        contrast == viewport->contrast)
      pass ("VIEWPORT.contrast [BD]");
    else
      {
        fail ("VIEWPORT.contrast [BD] %g != %g", viewport->contrast, contrast); error++;
      }
  }
  {
    BITCODE_RC default_lighting_type;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "default_lighting_type", &default_lighting_type, NULL) &&
        default_lighting_type == viewport->default_lighting_type)
      pass ("VIEWPORT.default_lighting_type [RC]");
    else
      {
        fail ("VIEWPORT.default_lighting_type [RC] %c != %c", viewport->default_lighting_type, default_lighting_type); error++;
      }
  }
  {
    BITCODE_BD front_clip_z;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "front_clip_z", &front_clip_z, NULL) &&
        front_clip_z == viewport->front_clip_z)
      pass ("VIEWPORT.front_clip_z [BD]");
    else
      {
        fail ("VIEWPORT.front_clip_z [BD] %g != %g", viewport->front_clip_z, front_clip_z); error++;
      }
  }
  {
    BITCODE_BS grid_major;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "grid_major", &grid_major, NULL) &&
        grid_major == viewport->grid_major)
      pass ("VIEWPORT.grid_major [BS]");
    else
      {
        fail ("VIEWPORT.grid_major [BS] %d != %d", viewport->grid_major, grid_major); error++;
      }
  }
  {
    BITCODE_2RD grid_spacing;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "grid_spacing", &grid_spacing, NULL)
        && !memcmp(&grid_spacing, &viewport->grid_spacing, sizeof(viewport->grid_spacing)))
      pass ("VIEWPORT.grid_spacing");
    else
      {
        fail ("VIEWPORT.grid_spacing"); error++;
      }
  }
  {
    BITCODE_BD height;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "height", &height, NULL) &&
        height == viewport->height)
      pass ("VIEWPORT.height [BD]");
    else
      {
        fail ("VIEWPORT.height [BD] %g != %g", viewport->height, height); error++;
      }
  }
  {
    BITCODE_RS id;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "id", &id, NULL) &&
        id == viewport->id)
      pass ("VIEWPORT.id [RS]");
    else
      {
        fail ("VIEWPORT.id [RS] " FORMAT_RS " != " FORMAT_RS "", viewport->id, id); error++;
      }
  }
  {
    BITCODE_BD lens_length;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "lens_length", &lens_length, NULL) &&
        lens_length == viewport->lens_length)
      pass ("VIEWPORT.lens_length [BD]");
    else
      {
        fail ("VIEWPORT.lens_length [BD] %g != %g", viewport->lens_length, lens_length); error++;
      }
  }
  {
    BITCODE_BL num_frozen_layers;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "num_frozen_layers", &num_frozen_layers, NULL) &&
        num_frozen_layers == viewport->num_frozen_layers)
      pass ("VIEWPORT.num_frozen_layers [BL]");
    else
      {
        fail ("VIEWPORT.num_frozen_layers [BL] %u != %u", viewport->num_frozen_layers, num_frozen_layers); error++;
      }
  }
  {
    BITCODE_RS on_off;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "on_off", &on_off, NULL) &&
        on_off == viewport->on_off)
      pass ("VIEWPORT.on_off [RS]");
    else
      {
        fail ("VIEWPORT.on_off [RS] " FORMAT_RS " != " FORMAT_RS "", viewport->on_off, on_off); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "parent", &parent, NULL)
        && !memcmp(&parent, &viewport->parent, sizeof(viewport->parent)))
      pass ("VIEWPORT.parent");
    else
      {
        fail ("VIEWPORT.parent"); error++;
      }
  }
  {
    BITCODE_RC render_mode;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "render_mode", &render_mode, NULL) &&
        render_mode == viewport->render_mode)
      pass ("VIEWPORT.render_mode [RC]");
    else
      {
        fail ("VIEWPORT.render_mode [RC] %c != %c", viewport->render_mode, render_mode); error++;
      }
  }
  {
    BITCODE_BS shadeplot_mode;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "shadeplot_mode", &shadeplot_mode, NULL) &&
        shadeplot_mode == viewport->shadeplot_mode)
      pass ("VIEWPORT.shadeplot_mode [BS]");
    else
      {
        fail ("VIEWPORT.shadeplot_mode [BS] %d != %d", viewport->shadeplot_mode, shadeplot_mode); error++;
      }
  }
  {
    BITCODE_BD snap_angle;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "snap_angle", &snap_angle, NULL) &&
        snap_angle == viewport->snap_angle)
      pass ("VIEWPORT.snap_angle [BD]");
    else
      {
        fail ("VIEWPORT.snap_angle [BD] %g != %g", viewport->snap_angle, snap_angle); error++;
      }
  }
  {
    BITCODE_2RD snap_base;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "snap_base", &snap_base, NULL)
        && !memcmp(&snap_base, &viewport->snap_base, sizeof(viewport->snap_base)))
      pass ("VIEWPORT.snap_base");
    else
      {
        fail ("VIEWPORT.snap_base"); error++;
      }
  }
  {
    BITCODE_2RD snap_spacing;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "snap_spacing", &snap_spacing, NULL)
        && !memcmp(&snap_spacing, &viewport->snap_spacing, sizeof(viewport->snap_spacing)))
      pass ("VIEWPORT.snap_spacing");
    else
      {
        fail ("VIEWPORT.snap_spacing"); error++;
      }
  }
  {
    BITCODE_BL status_flag;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "status_flag", &status_flag, NULL) &&
        status_flag == viewport->status_flag)
      pass ("VIEWPORT.status_flag [BL]");
    else
      {
        fail ("VIEWPORT.status_flag [BL] %u != %u", viewport->status_flag, status_flag); error++;
      }
  }
  {
    BITCODE_TV style_sheet;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "style_sheet", &style_sheet, NULL)
        && !strcmp((char*)&style_sheet, (char*)&viewport->style_sheet))
      pass ("VIEWPORT.style_sheet");
    else
      {
        fail ("VIEWPORT.style_sheet"); error++;
      }
  }
  {
    BITCODE_B ucs_at_origin;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "ucs_at_origin", &ucs_at_origin, NULL) &&
        ucs_at_origin == viewport->ucs_at_origin)
      pass ("VIEWPORT.ucs_at_origin [B]");
    else
      {
        fail ("VIEWPORT.ucs_at_origin [B] " FORMAT_B " != " FORMAT_B "", viewport->ucs_at_origin, ucs_at_origin); error++;
      }
  }
  {
    BITCODE_BD ucs_elevation;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "ucs_elevation", &ucs_elevation, NULL) &&
        ucs_elevation == viewport->ucs_elevation)
      pass ("VIEWPORT.ucs_elevation [BD]");
    else
      {
        fail ("VIEWPORT.ucs_elevation [BD] %g != %g", viewport->ucs_elevation, ucs_elevation); error++;
      }
  }
  {
    BITCODE_3BD ucs_origin;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "ucs_origin", &ucs_origin, NULL)
        && !memcmp(&ucs_origin, &viewport->ucs_origin, sizeof(viewport->ucs_origin)))
      pass ("VIEWPORT.ucs_origin");
    else
      {
        fail ("VIEWPORT.ucs_origin"); error++;
      }
  }
  {
    BITCODE_BS ucs_ortho_view_type;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "ucs_ortho_view_type", &ucs_ortho_view_type, NULL) &&
        ucs_ortho_view_type == viewport->ucs_ortho_view_type)
      pass ("VIEWPORT.ucs_ortho_view_type [BS]");
    else
      {
        fail ("VIEWPORT.ucs_ortho_view_type [BS] %d != %d", viewport->ucs_ortho_view_type, ucs_ortho_view_type); error++;
      }
  }
  {
    BITCODE_B ucs_per_viewport;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "ucs_per_viewport", &ucs_per_viewport, NULL) &&
        ucs_per_viewport == viewport->ucs_per_viewport)
      pass ("VIEWPORT.ucs_per_viewport [B]");
    else
      {
        fail ("VIEWPORT.ucs_per_viewport [B] " FORMAT_B " != " FORMAT_B "", viewport->ucs_per_viewport, ucs_per_viewport); error++;
      }
  }
  {
    BITCODE_3BD ucs_x_axis;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "ucs_x_axis", &ucs_x_axis, NULL)
        && !memcmp(&ucs_x_axis, &viewport->ucs_x_axis, sizeof(viewport->ucs_x_axis)))
      pass ("VIEWPORT.ucs_x_axis");
    else
      {
        fail ("VIEWPORT.ucs_x_axis"); error++;
      }
  }
  {
    BITCODE_3BD ucs_y_axis;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "ucs_y_axis", &ucs_y_axis, NULL)
        && !memcmp(&ucs_y_axis, &viewport->ucs_y_axis, sizeof(viewport->ucs_y_axis)))
      pass ("VIEWPORT.ucs_y_axis");
    else
      {
        fail ("VIEWPORT.ucs_y_axis"); error++;
      }
  }
  {
    BITCODE_B use_default_lights;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "use_default_lights", &use_default_lights, NULL) &&
        use_default_lights == viewport->use_default_lights)
      pass ("VIEWPORT.use_default_lights [B]");
    else
      {
        fail ("VIEWPORT.use_default_lights [B] " FORMAT_B " != " FORMAT_B "", viewport->use_default_lights, use_default_lights); error++;
      }
  }
  {
    BITCODE_2RD view_center;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "view_center", &view_center, NULL)
        && !memcmp(&view_center, &viewport->view_center, sizeof(viewport->view_center)))
      pass ("VIEWPORT.view_center");
    else
      {
        fail ("VIEWPORT.view_center"); error++;
      }
  }
  {
    BITCODE_3BD view_direction;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "view_direction", &view_direction, NULL)
        && !memcmp(&view_direction, &viewport->view_direction, sizeof(viewport->view_direction)))
      pass ("VIEWPORT.view_direction");
    else
      {
        fail ("VIEWPORT.view_direction"); error++;
      }
  }
  {
    BITCODE_BD view_height;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "view_height", &view_height, NULL) &&
        view_height == viewport->view_height)
      pass ("VIEWPORT.view_height [BD]");
    else
      {
        fail ("VIEWPORT.view_height [BD] %g != %g", viewport->view_height, view_height); error++;
      }
  }
  {
    BITCODE_3BD view_target;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "view_target", &view_target, NULL)
        && !memcmp(&view_target, &viewport->view_target, sizeof(viewport->view_target)))
      pass ("VIEWPORT.view_target");
    else
      {
        fail ("VIEWPORT.view_target"); error++;
      }
  }
  {
    BITCODE_BD view_twist;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "view_twist", &view_twist, NULL) &&
        view_twist == viewport->view_twist)
      pass ("VIEWPORT.view_twist [BD]");
    else
      {
        fail ("VIEWPORT.view_twist [BD] %g != %g", viewport->view_twist, view_twist); error++;
      }
  }
  {
    BITCODE_BD width;
    if (dwg_dynapi_entity_value(viewport, "VIEWPORT", "width", &width, NULL) &&
        width == viewport->width)
      pass ("VIEWPORT.width [BD]");
    else
      {
        fail ("VIEWPORT.width [BD] %g != %g", viewport->width, width); error++;
      }
  }
  return error;
}
static int test_WIPEOUT (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Entity_WIPEOUT *wipeout = obj->tio.entity->tio.WIPEOUT;
  {
    BITCODE_2RD boundary_pt0;
    if (dwg_dynapi_entity_value(wipeout, "WIPEOUT", "boundary_pt0", &boundary_pt0, NULL)
        && !memcmp(&boundary_pt0, &wipeout->boundary_pt0, sizeof(wipeout->boundary_pt0)))
      pass ("WIPEOUT.boundary_pt0");
    else
      {
        fail ("WIPEOUT.boundary_pt0"); error++;
      }
  }
  {
    BITCODE_2RD boundary_pt1;
    if (dwg_dynapi_entity_value(wipeout, "WIPEOUT", "boundary_pt1", &boundary_pt1, NULL)
        && !memcmp(&boundary_pt1, &wipeout->boundary_pt1, sizeof(wipeout->boundary_pt1)))
      pass ("WIPEOUT.boundary_pt1");
    else
      {
        fail ("WIPEOUT.boundary_pt1"); error++;
      }
  }
  {
    BITCODE_RC brightness;
    if (dwg_dynapi_entity_value(wipeout, "WIPEOUT", "brightness", &brightness, NULL) &&
        brightness == wipeout->brightness)
      pass ("WIPEOUT.brightness [RC]");
    else
      {
        fail ("WIPEOUT.brightness [RC] %c != %c", wipeout->brightness, brightness); error++;
      }
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value(wipeout, "WIPEOUT", "class_version", &class_version, NULL) &&
        class_version == wipeout->class_version)
      pass ("WIPEOUT.class_version [BL]");
    else
      {
        fail ("WIPEOUT.class_version [BL] %u != %u", wipeout->class_version, class_version); error++;
      }
  }
  {
    BITCODE_BS clip_boundary_type;
    if (dwg_dynapi_entity_value(wipeout, "WIPEOUT", "clip_boundary_type", &clip_boundary_type, NULL) &&
        clip_boundary_type == wipeout->clip_boundary_type)
      pass ("WIPEOUT.clip_boundary_type [BS]");
    else
      {
        fail ("WIPEOUT.clip_boundary_type [BS] %d != %d", wipeout->clip_boundary_type, clip_boundary_type); error++;
      }
  }
  {
    BITCODE_B clip_mode;
    if (dwg_dynapi_entity_value(wipeout, "WIPEOUT", "clip_mode", &clip_mode, NULL) &&
        clip_mode == wipeout->clip_mode)
      pass ("WIPEOUT.clip_mode [B]");
    else
      {
        fail ("WIPEOUT.clip_mode [B] " FORMAT_B " != " FORMAT_B "", wipeout->clip_mode, clip_mode); error++;
      }
  }
  {
    BITCODE_2RD* clip_verts;
    if (dwg_dynapi_entity_value(wipeout, "WIPEOUT", "clip_verts", &clip_verts, NULL)
        && !memcmp(&clip_verts, &wipeout->clip_verts, sizeof(wipeout->clip_verts)))
      pass ("WIPEOUT.clip_verts");
    else
      {
        fail ("WIPEOUT.clip_verts"); error++;
      }
  }
  {
    BITCODE_B clipping;
    if (dwg_dynapi_entity_value(wipeout, "WIPEOUT", "clipping", &clipping, NULL) &&
        clipping == wipeout->clipping)
      pass ("WIPEOUT.clipping [B]");
    else
      {
        fail ("WIPEOUT.clipping [B] " FORMAT_B " != " FORMAT_B "", wipeout->clipping, clipping); error++;
      }
  }
  {
    BITCODE_RC contrast;
    if (dwg_dynapi_entity_value(wipeout, "WIPEOUT", "contrast", &contrast, NULL) &&
        contrast == wipeout->contrast)
      pass ("WIPEOUT.contrast [RC]");
    else
      {
        fail ("WIPEOUT.contrast [RC] %c != %c", wipeout->contrast, contrast); error++;
      }
  }
  {
    BITCODE_BS display_props;
    if (dwg_dynapi_entity_value(wipeout, "WIPEOUT", "display_props", &display_props, NULL) &&
        display_props == wipeout->display_props)
      pass ("WIPEOUT.display_props [BS]");
    else
      {
        fail ("WIPEOUT.display_props [BS] %d != %d", wipeout->display_props, display_props); error++;
      }
  }
  {
    BITCODE_RC fade;
    if (dwg_dynapi_entity_value(wipeout, "WIPEOUT", "fade", &fade, NULL) &&
        fade == wipeout->fade)
      pass ("WIPEOUT.fade [RC]");
    else
      {
        fail ("WIPEOUT.fade [RC] %c != %c", wipeout->fade, fade); error++;
      }
  }
  {
    BITCODE_H imagedef;
    if (dwg_dynapi_entity_value(wipeout, "WIPEOUT", "imagedef", &imagedef, NULL) &&
        imagedef == wipeout->imagedef)
      pass ("WIPEOUT.imagedef [H]");
    else
      {
        fail ("WIPEOUT.imagedef [H] %p != %p", wipeout->imagedef, imagedef); error++;
      }
  }
  {
    BITCODE_H imagedefreactor;
    if (dwg_dynapi_entity_value(wipeout, "WIPEOUT", "imagedefreactor", &imagedefreactor, NULL) &&
        imagedefreactor == wipeout->imagedefreactor)
      pass ("WIPEOUT.imagedefreactor [H]");
    else
      {
        fail ("WIPEOUT.imagedefreactor [H] %p != %p", wipeout->imagedefreactor, imagedefreactor); error++;
      }
  }
  {
    BITCODE_BL num_clip_verts;
    if (dwg_dynapi_entity_value(wipeout, "WIPEOUT", "num_clip_verts", &num_clip_verts, NULL) &&
        num_clip_verts == wipeout->num_clip_verts)
      pass ("WIPEOUT.num_clip_verts [BL]");
    else
      {
        fail ("WIPEOUT.num_clip_verts [BL] %u != %u", wipeout->num_clip_verts, num_clip_verts); error++;
      }
  }
  {
    struct _dwg_object_entity* parent;
    if (dwg_dynapi_entity_value(wipeout, "WIPEOUT", "parent", &parent, NULL)
        && !memcmp(&parent, &wipeout->parent, sizeof(wipeout->parent)))
      pass ("WIPEOUT.parent");
    else
      {
        fail ("WIPEOUT.parent"); error++;
      }
  }
  {
    BITCODE_3BD pt0;
    if (dwg_dynapi_entity_value(wipeout, "WIPEOUT", "pt0", &pt0, NULL)
        && !memcmp(&pt0, &wipeout->pt0, sizeof(wipeout->pt0)))
      pass ("WIPEOUT.pt0");
    else
      {
        fail ("WIPEOUT.pt0"); error++;
      }
  }
  {
    BITCODE_2RD size;
    if (dwg_dynapi_entity_value(wipeout, "WIPEOUT", "size", &size, NULL)
        && !memcmp(&size, &wipeout->size, sizeof(wipeout->size)))
      pass ("WIPEOUT.size");
    else
      {
        fail ("WIPEOUT.size"); error++;
      }
  }
  {
    BITCODE_3BD uvec;
    if (dwg_dynapi_entity_value(wipeout, "WIPEOUT", "uvec", &uvec, NULL)
        && !memcmp(&uvec, &wipeout->uvec, sizeof(wipeout->uvec)))
      pass ("WIPEOUT.uvec");
    else
      {
        fail ("WIPEOUT.uvec"); error++;
      }
  }
  {
    BITCODE_3BD vvec;
    if (dwg_dynapi_entity_value(wipeout, "WIPEOUT", "vvec", &vvec, NULL)
        && !memcmp(&vvec, &wipeout->vvec, sizeof(wipeout->vvec)))
      pass ("WIPEOUT.vvec");
    else
      {
        fail ("WIPEOUT.vvec"); error++;
      }
  }
  return error;
}
static int test_ACDBNAVISWORKSMODELDEF (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_ACDBNAVISWORKSMODELDEF *acdbnavisworksmodeldef = obj->tio.object->tio.ACDBNAVISWORKSMODELDEF;
  {
    BITCODE_B host_drawing_visibility;
    if (dwg_dynapi_entity_value(acdbnavisworksmodeldef, "ACDBNAVISWORKSMODELDEF", "host_drawing_visibility", &host_drawing_visibility, NULL) &&
        host_drawing_visibility == acdbnavisworksmodeldef->host_drawing_visibility)
      pass ("ACDBNAVISWORKSMODELDEF.host_drawing_visibility [B]");
    else
      {
        fail ("ACDBNAVISWORKSMODELDEF.host_drawing_visibility [B] " FORMAT_B " != " FORMAT_B "", acdbnavisworksmodeldef->host_drawing_visibility, host_drawing_visibility); error++;
      }
  }
  {
    BITCODE_3BD max_extent;
    if (dwg_dynapi_entity_value(acdbnavisworksmodeldef, "ACDBNAVISWORKSMODELDEF", "max_extent", &max_extent, NULL)
        && !memcmp(&max_extent, &acdbnavisworksmodeldef->max_extent, sizeof(acdbnavisworksmodeldef->max_extent)))
      pass ("ACDBNAVISWORKSMODELDEF.max_extent");
    else
      {
        fail ("ACDBNAVISWORKSMODELDEF.max_extent"); error++;
      }
  }
  {
    BITCODE_3BD min_extent;
    if (dwg_dynapi_entity_value(acdbnavisworksmodeldef, "ACDBNAVISWORKSMODELDEF", "min_extent", &min_extent, NULL)
        && !memcmp(&min_extent, &acdbnavisworksmodeldef->min_extent, sizeof(acdbnavisworksmodeldef->min_extent)))
      pass ("ACDBNAVISWORKSMODELDEF.min_extent");
    else
      {
        fail ("ACDBNAVISWORKSMODELDEF.min_extent"); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(acdbnavisworksmodeldef, "ACDBNAVISWORKSMODELDEF", "ownerhandle", &ownerhandle, NULL) &&
        ownerhandle == acdbnavisworksmodeldef->ownerhandle)
      pass ("ACDBNAVISWORKSMODELDEF.ownerhandle [H]");
    else
      {
        fail ("ACDBNAVISWORKSMODELDEF.ownerhandle [H] %p != %p", acdbnavisworksmodeldef->ownerhandle, ownerhandle); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(acdbnavisworksmodeldef, "ACDBNAVISWORKSMODELDEF", "parent", &parent, NULL)
        && !memcmp(&parent, &acdbnavisworksmodeldef->parent, sizeof(acdbnavisworksmodeldef->parent)))
      pass ("ACDBNAVISWORKSMODELDEF.parent");
    else
      {
        fail ("ACDBNAVISWORKSMODELDEF.parent"); error++;
      }
  }
  {
    BITCODE_T path;
    if (dwg_dynapi_entity_value(acdbnavisworksmodeldef, "ACDBNAVISWORKSMODELDEF", "path", &path, NULL)
        && !memcmp(&path, &acdbnavisworksmodeldef->path, sizeof(acdbnavisworksmodeldef->path)))
      pass ("ACDBNAVISWORKSMODELDEF.path");
    else
      {
        fail ("ACDBNAVISWORKSMODELDEF.path"); error++;
      }
  }
  {
    BITCODE_B status;
    if (dwg_dynapi_entity_value(acdbnavisworksmodeldef, "ACDBNAVISWORKSMODELDEF", "status", &status, NULL) &&
        status == acdbnavisworksmodeldef->status)
      pass ("ACDBNAVISWORKSMODELDEF.status [B]");
    else
      {
        fail ("ACDBNAVISWORKSMODELDEF.status [B] " FORMAT_B " != " FORMAT_B "", acdbnavisworksmodeldef->status, status); error++;
      }
  }
  return error;
}
static int test_ACSH_SWEEP_CLASS (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_ACSH_SWEEP_CLASS *acsh_sweep_class = obj->tio.object->tio.ACSH_SWEEP_CLASS;
  {
    BITCODE_BD align_angle;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "align_angle", &align_angle, NULL) &&
        align_angle == acsh_sweep_class->align_angle)
      pass ("ACSH_SWEEP_CLASS.align_angle [BD]");
    else
      {
        fail ("ACSH_SWEEP_CLASS.align_angle [BD] %g != %g", acsh_sweep_class->align_angle, align_angle); error++;
      }
  }
  {
    BITCODE_RC align_option;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "align_option", &align_option, NULL) &&
        align_option == acsh_sweep_class->align_option)
      pass ("ACSH_SWEEP_CLASS.align_option [RC]");
    else
      {
        fail ("ACSH_SWEEP_CLASS.align_option [RC] %c != %c", acsh_sweep_class->align_option, align_option); error++;
      }
  }
  {
    BITCODE_B bank;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "bank", &bank, NULL) &&
        bank == acsh_sweep_class->bank)
      pass ("ACSH_SWEEP_CLASS.bank [B]");
    else
      {
        fail ("ACSH_SWEEP_CLASS.bank [B] " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->bank, bank); error++;
      }
  }
  {
    BITCODE_3BD basept;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "basept", &basept, NULL)
        && !memcmp(&basept, &acsh_sweep_class->basept, sizeof(acsh_sweep_class->basept)))
      pass ("ACSH_SWEEP_CLASS.basept");
    else
      {
        fail ("ACSH_SWEEP_CLASS.basept"); error++;
      }
  }
  {
    BITCODE_B check_intersections;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "check_intersections", &check_intersections, NULL) &&
        check_intersections == acsh_sweep_class->check_intersections)
      pass ("ACSH_SWEEP_CLASS.check_intersections [B]");
    else
      {
        fail ("ACSH_SWEEP_CLASS.check_intersections [B] " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->check_intersections, check_intersections); error++;
      }
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "class_version", &class_version, NULL) &&
        class_version == acsh_sweep_class->class_version)
      pass ("ACSH_SWEEP_CLASS.class_version [BL]");
    else
      {
        fail ("ACSH_SWEEP_CLASS.class_version [BL] %u != %u", acsh_sweep_class->class_version, class_version); error++;
      }
  }
  {
    BITCODE_CMC color;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "color", &color, NULL)
        && !memcmp(&color, &acsh_sweep_class->color, sizeof(acsh_sweep_class->color)))
      pass ("ACSH_SWEEP_CLASS.color");
    else
      {
        fail ("ACSH_SWEEP_CLASS.color"); error++;
      }
  }
  {
    BITCODE_BD draft_angle;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "draft_angle", &draft_angle, NULL) &&
        draft_angle == acsh_sweep_class->draft_angle)
      pass ("ACSH_SWEEP_CLASS.draft_angle [BD]");
    else
      {
        fail ("ACSH_SWEEP_CLASS.draft_angle [BD] %g != %g", acsh_sweep_class->draft_angle, draft_angle); error++;
      }
  }
  {
    BITCODE_BL ee_bl98;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "ee_bl98", &ee_bl98, NULL) &&
        ee_bl98 == acsh_sweep_class->ee_bl98)
      pass ("ACSH_SWEEP_CLASS.ee_bl98 [BL]");
    else
      {
        fail ("ACSH_SWEEP_CLASS.ee_bl98 [BL] %u != %u", acsh_sweep_class->ee_bl98, ee_bl98); error++;
      }
  }
  {
    BITCODE_BL ee_bl99;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "ee_bl99", &ee_bl99, NULL) &&
        ee_bl99 == acsh_sweep_class->ee_bl99)
      pass ("ACSH_SWEEP_CLASS.ee_bl99 [BL]");
    else
      {
        fail ("ACSH_SWEEP_CLASS.ee_bl99 [BL] %u != %u", acsh_sweep_class->ee_bl99, ee_bl99); error++;
      }
  }
  {
    BITCODE_BD end_draft_dist;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "end_draft_dist", &end_draft_dist, NULL) &&
        end_draft_dist == acsh_sweep_class->end_draft_dist)
      pass ("ACSH_SWEEP_CLASS.end_draft_dist [BD]");
    else
      {
        fail ("ACSH_SWEEP_CLASS.end_draft_dist [BD] %g != %g", acsh_sweep_class->end_draft_dist, end_draft_dist); error++;
      }
  }
  {
    BITCODE_B has_align_start;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "has_align_start", &has_align_start, NULL) &&
        has_align_start == acsh_sweep_class->has_align_start)
      pass ("ACSH_SWEEP_CLASS.has_align_start [B]");
    else
      {
        fail ("ACSH_SWEEP_CLASS.has_align_start [B] " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->has_align_start, has_align_start); error++;
      }
  }
  {
    BITCODE_RC miter_option;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "miter_option", &miter_option, NULL) &&
        miter_option == acsh_sweep_class->miter_option)
      pass ("ACSH_SWEEP_CLASS.miter_option [RC]");
    else
      {
        fail ("ACSH_SWEEP_CLASS.miter_option [RC] %c != %c", acsh_sweep_class->miter_option, miter_option); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "parent", &parent, NULL)
        && !memcmp(&parent, &acsh_sweep_class->parent, sizeof(acsh_sweep_class->parent)))
      pass ("ACSH_SWEEP_CLASS.parent");
    else
      {
        fail ("ACSH_SWEEP_CLASS.parent"); error++;
      }
  }
  {
    BITCODE_BD* pathentity_transform;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "pathentity_transform", &pathentity_transform, NULL)
        && !memcmp(&pathentity_transform, &acsh_sweep_class->pathentity_transform, sizeof(acsh_sweep_class->pathentity_transform)))
      pass ("ACSH_SWEEP_CLASS.pathentity_transform");
    else
      {
        fail ("ACSH_SWEEP_CLASS.pathentity_transform"); error++;
      }
  }
  {
    BITCODE_3BD pt2;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "pt2", &pt2, NULL)
        && !memcmp(&pt2, &acsh_sweep_class->pt2, sizeof(acsh_sweep_class->pt2)))
      pass ("ACSH_SWEEP_CLASS.pt2");
    else
      {
        fail ("ACSH_SWEEP_CLASS.pt2"); error++;
      }
  }
  {
    BITCODE_BD scale_factor;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "scale_factor", &scale_factor, NULL) &&
        scale_factor == acsh_sweep_class->scale_factor)
      pass ("ACSH_SWEEP_CLASS.scale_factor [BD]");
    else
      {
        fail ("ACSH_SWEEP_CLASS.scale_factor [BD] %g != %g", acsh_sweep_class->scale_factor, scale_factor); error++;
      }
  }
  {
    BITCODE_B shhn_b92;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "shhn_b92", &shhn_b92, NULL) &&
        shhn_b92 == acsh_sweep_class->shhn_b92)
      pass ("ACSH_SWEEP_CLASS.shhn_b92 [B]");
    else
      {
        fail ("ACSH_SWEEP_CLASS.shhn_b92 [B] " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->shhn_b92, shhn_b92); error++;
      }
  }
  {
    BITCODE_BL shhn_bl347;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "shhn_bl347", &shhn_bl347, NULL) &&
        shhn_bl347 == acsh_sweep_class->shhn_bl347)
      pass ("ACSH_SWEEP_CLASS.shhn_bl347 [BL]");
    else
      {
        fail ("ACSH_SWEEP_CLASS.shhn_bl347 [BL] %u != %u", acsh_sweep_class->shhn_bl347, shhn_bl347); error++;
      }
  }
  {
    BITCODE_BL shhn_bl98;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "shhn_bl98", &shhn_bl98, NULL) &&
        shhn_bl98 == acsh_sweep_class->shhn_bl98)
      pass ("ACSH_SWEEP_CLASS.shhn_bl98 [BL]");
    else
      {
        fail ("ACSH_SWEEP_CLASS.shhn_bl98 [BL] %u != %u", acsh_sweep_class->shhn_bl98, shhn_bl98); error++;
      }
  }
  {
    BITCODE_BL shhn_bl99;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "shhn_bl99", &shhn_bl99, NULL) &&
        shhn_bl99 == acsh_sweep_class->shhn_bl99)
      pass ("ACSH_SWEEP_CLASS.shhn_bl99 [BL]");
    else
      {
        fail ("ACSH_SWEEP_CLASS.shhn_bl99 [BL] %u != %u", acsh_sweep_class->shhn_bl99, shhn_bl99); error++;
      }
  }
  {
    BITCODE_BD* shhn_pts;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "shhn_pts", &shhn_pts, NULL)
        && !memcmp(&shhn_pts, &acsh_sweep_class->shhn_pts, sizeof(acsh_sweep_class->shhn_pts)))
      pass ("ACSH_SWEEP_CLASS.shhn_pts");
    else
      {
        fail ("ACSH_SWEEP_CLASS.shhn_pts"); error++;
      }
  }
  {
    BITCODE_B shsw_b294;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_b294", &shsw_b294, NULL) &&
        shsw_b294 == acsh_sweep_class->shsw_b294)
      pass ("ACSH_SWEEP_CLASS.shsw_b294 [B]");
    else
      {
        fail ("ACSH_SWEEP_CLASS.shsw_b294 [B] " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->shsw_b294, shsw_b294); error++;
      }
  }
  {
    BITCODE_B shsw_b295;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_b295", &shsw_b295, NULL) &&
        shsw_b295 == acsh_sweep_class->shsw_b295)
      pass ("ACSH_SWEEP_CLASS.shsw_b295 [B]");
    else
      {
        fail ("ACSH_SWEEP_CLASS.shsw_b295 [B] " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->shsw_b295, shsw_b295); error++;
      }
  }
  {
    BITCODE_B shsw_b296;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_b296", &shsw_b296, NULL) &&
        shsw_b296 == acsh_sweep_class->shsw_b296)
      pass ("ACSH_SWEEP_CLASS.shsw_b296 [B]");
    else
      {
        fail ("ACSH_SWEEP_CLASS.shsw_b296 [B] " FORMAT_B " != " FORMAT_B "", acsh_sweep_class->shsw_b296, shsw_b296); error++;
      }
  }
  {
    BITCODE_BL shsw_bl90;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_bl90", &shsw_bl90, NULL) &&
        shsw_bl90 == acsh_sweep_class->shsw_bl90)
      pass ("ACSH_SWEEP_CLASS.shsw_bl90 [BL]");
    else
      {
        fail ("ACSH_SWEEP_CLASS.shsw_bl90 [BL] %u != %u", acsh_sweep_class->shsw_bl90, shsw_bl90); error++;
      }
  }
  {
    BITCODE_BL shsw_bl91;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_bl91", &shsw_bl91, NULL) &&
        shsw_bl91 == acsh_sweep_class->shsw_bl91)
      pass ("ACSH_SWEEP_CLASS.shsw_bl91 [BL]");
    else
      {
        fail ("ACSH_SWEEP_CLASS.shsw_bl91 [BL] %u != %u", acsh_sweep_class->shsw_bl91, shsw_bl91); error++;
      }
  }
  {
    BITCODE_BL shsw_bl92;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_bl92", &shsw_bl92, NULL) &&
        shsw_bl92 == acsh_sweep_class->shsw_bl92)
      pass ("ACSH_SWEEP_CLASS.shsw_bl92 [BL]");
    else
      {
        fail ("ACSH_SWEEP_CLASS.shsw_bl92 [BL] %u != %u", acsh_sweep_class->shsw_bl92, shsw_bl92); error++;
      }
  }
  {
    BITCODE_BL shsw_bl93;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_bl93", &shsw_bl93, NULL) &&
        shsw_bl93 == acsh_sweep_class->shsw_bl93)
      pass ("ACSH_SWEEP_CLASS.shsw_bl93 [BL]");
    else
      {
        fail ("ACSH_SWEEP_CLASS.shsw_bl93 [BL] %u != %u", acsh_sweep_class->shsw_bl93, shsw_bl93); error++;
      }
  }
  {
    BITCODE_BL shsw_size_text;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_size_text", &shsw_size_text, NULL) &&
        shsw_size_text == acsh_sweep_class->shsw_size_text)
      pass ("ACSH_SWEEP_CLASS.shsw_size_text [BL]");
    else
      {
        fail ("ACSH_SWEEP_CLASS.shsw_size_text [BL] %u != %u", acsh_sweep_class->shsw_size_text, shsw_size_text); error++;
      }
  }
  {
    BITCODE_BL shsw_size_text2;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_size_text2", &shsw_size_text2, NULL) &&
        shsw_size_text2 == acsh_sweep_class->shsw_size_text2)
      pass ("ACSH_SWEEP_CLASS.shsw_size_text2 [BL]");
    else
      {
        fail ("ACSH_SWEEP_CLASS.shsw_size_text2 [BL] %u != %u", acsh_sweep_class->shsw_size_text2, shsw_size_text2); error++;
      }
  }
  {
    BITCODE_TF shsw_text;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_text", &shsw_text, NULL) &&
        shsw_text == acsh_sweep_class->shsw_text)
      pass ("ACSH_SWEEP_CLASS.shsw_text [TF]");
    else
      {
        fail ("ACSH_SWEEP_CLASS.shsw_text [TF] " FORMAT_TF " != " FORMAT_TF "", acsh_sweep_class->shsw_text, shsw_text); error++;
      }
  }
  {
    BITCODE_TF shsw_text2;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "shsw_text2", &shsw_text2, NULL) &&
        shsw_text2 == acsh_sweep_class->shsw_text2)
      pass ("ACSH_SWEEP_CLASS.shsw_text2 [TF]");
    else
      {
        fail ("ACSH_SWEEP_CLASS.shsw_text2 [TF] " FORMAT_TF " != " FORMAT_TF "", acsh_sweep_class->shsw_text2, shsw_text2); error++;
      }
  }
  {
    BITCODE_BD start_draft_dist;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "start_draft_dist", &start_draft_dist, NULL) &&
        start_draft_dist == acsh_sweep_class->start_draft_dist)
      pass ("ACSH_SWEEP_CLASS.start_draft_dist [BD]");
    else
      {
        fail ("ACSH_SWEEP_CLASS.start_draft_dist [BD] %g != %g", acsh_sweep_class->start_draft_dist, start_draft_dist); error++;
      }
  }
  {
    BITCODE_BD* sweepentity_transform;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "sweepentity_transform", &sweepentity_transform, NULL)
        && !memcmp(&sweepentity_transform, &acsh_sweep_class->sweepentity_transform, sizeof(acsh_sweep_class->sweepentity_transform)))
      pass ("ACSH_SWEEP_CLASS.sweepentity_transform");
    else
      {
        fail ("ACSH_SWEEP_CLASS.sweepentity_transform"); error++;
      }
  }
  {
    BITCODE_BD twist_angle;
    if (dwg_dynapi_entity_value(acsh_sweep_class, "ACSH_SWEEP_CLASS", "twist_angle", &twist_angle, NULL) &&
        twist_angle == acsh_sweep_class->twist_angle)
      pass ("ACSH_SWEEP_CLASS.twist_angle [BD]");
    else
      {
        fail ("ACSH_SWEEP_CLASS.twist_angle [BD] %g != %g", acsh_sweep_class->twist_angle, twist_angle); error++;
      }
  }
  return error;
}
static int test_APPID (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_APPID *appid = obj->tio.object->tio.APPID;
  {
    BITCODE_H app_control;
    if (dwg_dynapi_entity_value(appid, "APPID", "app_control", &app_control, NULL) &&
        app_control == appid->app_control)
      pass ("APPID.app_control [H]");
    else
      {
        fail ("APPID.app_control [H] %p != %p", appid->app_control, app_control); error++;
      }
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value(appid, "APPID", "flag", &flag, NULL) &&
        flag == appid->flag)
      pass ("APPID.flag [RC]");
    else
      {
        fail ("APPID.flag [RC] %c != %c", appid->flag, flag); error++;
      }
  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value(appid, "APPID", "name", &name, NULL)
        && !strcmp((char*)&name, (char*)&appid->name))
      pass ("APPID.name");
    else
      {
        fail ("APPID.name"); error++;
      }
  }
  {
    BITCODE_H null_handle;
    if (dwg_dynapi_entity_value(appid, "APPID", "null_handle", &null_handle, NULL) &&
        null_handle == appid->null_handle)
      pass ("APPID.null_handle [H]");
    else
      {
        fail ("APPID.null_handle [H] %p != %p", appid->null_handle, null_handle); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(appid, "APPID", "parent", &parent, NULL)
        && !memcmp(&parent, &appid->parent, sizeof(appid->parent)))
      pass ("APPID.parent");
    else
      {
        fail ("APPID.parent"); error++;
      }
  }
  {
    BITCODE_RC unknown;
    if (dwg_dynapi_entity_value(appid, "APPID", "unknown", &unknown, NULL) &&
        unknown == appid->unknown)
      pass ("APPID.unknown [RC]");
    else
      {
        fail ("APPID.unknown [RC] %c != %c", appid->unknown, unknown); error++;
      }
  }
  {
    BITCODE_RS used;
    if (dwg_dynapi_entity_value(appid, "APPID", "used", &used, NULL) &&
        used == appid->used)
      pass ("APPID.used [RS]");
    else
      {
        fail ("APPID.used [RS] " FORMAT_RS " != " FORMAT_RS "", appid->used, used); error++;
      }
  }
  {
    BITCODE_B xrefdep;
    if (dwg_dynapi_entity_value(appid, "APPID", "xrefdep", &xrefdep, NULL) &&
        xrefdep == appid->xrefdep)
      pass ("APPID.xrefdep [B]");
    else
      {
        fail ("APPID.xrefdep [B] " FORMAT_B " != " FORMAT_B "", appid->xrefdep, xrefdep); error++;
      }
  }
  {
    BITCODE_BS xrefindex_plus1;
    if (dwg_dynapi_entity_value(appid, "APPID", "xrefindex_plus1", &xrefindex_plus1, NULL) &&
        xrefindex_plus1 == appid->xrefindex_plus1)
      pass ("APPID.xrefindex_plus1 [BS]");
    else
      {
        fail ("APPID.xrefindex_plus1 [BS] %d != %d", appid->xrefindex_plus1, xrefindex_plus1); error++;
      }
  }
  {
    BITCODE_B xrefref;
    if (dwg_dynapi_entity_value(appid, "APPID", "xrefref", &xrefref, NULL) &&
        xrefref == appid->xrefref)
      pass ("APPID.xrefref [B]");
    else
      {
        fail ("APPID.xrefref [B] " FORMAT_B " != " FORMAT_B "", appid->xrefref, xrefref); error++;
      }
  }
  return error;
}
static int test_APPID_CONTROL (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_APPID_CONTROL *appid_control = obj->tio.object->tio.APPID_CONTROL;
  {
    Dwg_Object_Ref* apps;
    if (dwg_dynapi_entity_value(appid_control, "APPID_CONTROL", "apps", &apps, NULL)
        && !memcmp(&apps, &appid_control->apps, sizeof(appid_control->apps)))
      pass ("APPID_CONTROL.apps");
    else
      {
        fail ("APPID_CONTROL.apps"); error++;
      }
  }
  {
    Dwg_Object_Ref* null_handle;
    if (dwg_dynapi_entity_value(appid_control, "APPID_CONTROL", "null_handle", &null_handle, NULL)
        && !memcmp(&null_handle, &appid_control->null_handle, sizeof(appid_control->null_handle)))
      pass ("APPID_CONTROL.null_handle");
    else
      {
        fail ("APPID_CONTROL.null_handle"); error++;
      }
  }
  {
    BITCODE_BS num_entries;
    if (dwg_dynapi_entity_value(appid_control, "APPID_CONTROL", "num_entries", &num_entries, NULL) &&
        num_entries == appid_control->num_entries)
      pass ("APPID_CONTROL.num_entries [BS]");
    else
      {
        fail ("APPID_CONTROL.num_entries [BS] %d != %d", appid_control->num_entries, num_entries); error++;
      }
  }
  {
    BITCODE_BL objid;
    if (dwg_dynapi_entity_value(appid_control, "APPID_CONTROL", "objid", &objid, NULL) &&
        objid == appid_control->objid)
      pass ("APPID_CONTROL.objid [BL]");
    else
      {
        fail ("APPID_CONTROL.objid [BL] %u != %u", appid_control->objid, objid); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(appid_control, "APPID_CONTROL", "parent", &parent, NULL)
        && !memcmp(&parent, &appid_control->parent, sizeof(appid_control->parent)))
      pass ("APPID_CONTROL.parent");
    else
      {
        fail ("APPID_CONTROL.parent"); error++;
      }
  }
  {
    Dwg_Object_Ref* reactors;
    if (dwg_dynapi_entity_value(appid_control, "APPID_CONTROL", "reactors", &reactors, NULL)
        && !memcmp(&reactors, &appid_control->reactors, sizeof(appid_control->reactors)))
      pass ("APPID_CONTROL.reactors");
    else
      {
        fail ("APPID_CONTROL.reactors"); error++;
      }
  }
  {
    Dwg_Object_Ref* xdicobjhandle;
    if (dwg_dynapi_entity_value(appid_control, "APPID_CONTROL", "xdicobjhandle", &xdicobjhandle, NULL)
        && !memcmp(&xdicobjhandle, &appid_control->xdicobjhandle, sizeof(appid_control->xdicobjhandle)))
      pass ("APPID_CONTROL.xdicobjhandle");
    else
      {
        fail ("APPID_CONTROL.xdicobjhandle"); error++;
      }
  }
  return error;
}
static int test_ASSOC2DCONSTRAINTGROUP (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_ASSOC2DCONSTRAINTGROUP *assoc2dconstraintgroup = obj->tio.object->tio.ASSOC2DCONSTRAINTGROUP;
  {
    BITCODE_B b1;
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "b1", &b1, NULL) &&
        b1 == assoc2dconstraintgroup->b1)
      pass ("ASSOC2DCONSTRAINTGROUP.b1 [B]");
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.b1 [B] " FORMAT_B " != " FORMAT_B "", assoc2dconstraintgroup->b1, b1); error++;
      }
  }
  {
    BITCODE_3BD c1;
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "c1", &c1, NULL)
        && !memcmp(&c1, &assoc2dconstraintgroup->c1, sizeof(assoc2dconstraintgroup->c1)))
      pass ("ASSOC2DCONSTRAINTGROUP.c1");
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.c1"); error++;
      }
  }
  {
    BITCODE_3BD c2;
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "c2", &c2, NULL)
        && !memcmp(&c2, &assoc2dconstraintgroup->c2, sizeof(assoc2dconstraintgroup->c2)))
      pass ("ASSOC2DCONSTRAINTGROUP.c2");
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.c2"); error++;
      }
  }
  {
    BITCODE_3BD c3;
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "c3", &c3, NULL)
        && !memcmp(&c3, &assoc2dconstraintgroup->c3, sizeof(assoc2dconstraintgroup->c3)))
      pass ("ASSOC2DCONSTRAINTGROUP.c3");
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.c3"); error++;
      }
  }
  {
    BITCODE_BL cl1;
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "cl1", &cl1, NULL) &&
        cl1 == assoc2dconstraintgroup->cl1)
      pass ("ASSOC2DCONSTRAINTGROUP.cl1 [BL]");
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.cl1 [BL] %u != %u", assoc2dconstraintgroup->cl1, cl1); error++;
      }
  }
  {
    BITCODE_BL cl2;
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "cl2", &cl2, NULL) &&
        cl2 == assoc2dconstraintgroup->cl2)
      pass ("ASSOC2DCONSTRAINTGROUP.cl2 [BL]");
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.cl2 [BL] %u != %u", assoc2dconstraintgroup->cl2, cl2); error++;
      }
  }
  {
    BITCODE_BL cl3;
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "cl3", &cl3, NULL) &&
        cl3 == assoc2dconstraintgroup->cl3)
      pass ("ASSOC2DCONSTRAINTGROUP.cl3 [BL]");
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.cl3 [BL] %u != %u", assoc2dconstraintgroup->cl3, cl3); error++;
      }
  }
  {
    BITCODE_BL cl4;
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "cl4", &cl4, NULL) &&
        cl4 == assoc2dconstraintgroup->cl4)
      pass ("ASSOC2DCONSTRAINTGROUP.cl4 [BL]");
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.cl4 [BL] %u != %u", assoc2dconstraintgroup->cl4, cl4); error++;
      }
  }
  {
    BITCODE_BL constraint_status;
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "constraint_status", &constraint_status, NULL) &&
        constraint_status == assoc2dconstraintgroup->constraint_status)
      pass ("ASSOC2DCONSTRAINTGROUP.constraint_status [BL]");
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.constraint_status [BL] %u != %u", assoc2dconstraintgroup->constraint_status, constraint_status); error++;
      }
  }
  {
    BITCODE_RC cs1;
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "cs1", &cs1, NULL) &&
        cs1 == assoc2dconstraintgroup->cs1)
      pass ("ASSOC2DCONSTRAINTGROUP.cs1 [RC]");
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.cs1 [RC] %c != %c", assoc2dconstraintgroup->cs1, cs1); error++;
      }
  }
  {
    BITCODE_BL dof;
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "dof", &dof, NULL) &&
        dof == assoc2dconstraintgroup->dof)
      pass ("ASSOC2DCONSTRAINTGROUP.dof [BL]");
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.dof [BL] %u != %u", assoc2dconstraintgroup->dof, dof); error++;
      }
  }
  {
    BITCODE_BL geometry_status;
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "geometry_status", &geometry_status, NULL) &&
        geometry_status == assoc2dconstraintgroup->geometry_status)
      pass ("ASSOC2DCONSTRAINTGROUP.geometry_status [BL]");
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.geometry_status [BL] %u != %u", assoc2dconstraintgroup->geometry_status, geometry_status); error++;
      }
  }
  {
    BITCODE_BL l4;
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "l4", &l4, NULL) &&
        l4 == assoc2dconstraintgroup->l4)
      pass ("ASSOC2DCONSTRAINTGROUP.l4 [BL]");
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.l4 [BL] %u != %u", assoc2dconstraintgroup->l4, l4); error++;
      }
  }
  {
    BITCODE_BL l5;
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "l5", &l5, NULL) &&
        l5 == assoc2dconstraintgroup->l5)
      pass ("ASSOC2DCONSTRAINTGROUP.l5 [BL]");
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.l5 [BL] %u != %u", assoc2dconstraintgroup->l5, l5); error++;
      }
  }
  {
    BITCODE_BL l6;
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "l6", &l6, NULL) &&
        l6 == assoc2dconstraintgroup->l6)
      pass ("ASSOC2DCONSTRAINTGROUP.l6 [BL]");
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.l6 [BL] %u != %u", assoc2dconstraintgroup->l6, l6); error++;
      }
  }
  {
    BITCODE_BL l7;
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "l7", &l7, NULL) &&
        l7 == assoc2dconstraintgroup->l7)
      pass ("ASSOC2DCONSTRAINTGROUP.l7 [BL]");
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.l7 [BL] %u != %u", assoc2dconstraintgroup->l7, l7); error++;
      }
  }
  {
    BITCODE_BL l8;
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "l8", &l8, NULL) &&
        l8 == assoc2dconstraintgroup->l8)
      pass ("ASSOC2DCONSTRAINTGROUP.l8 [BL]");
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.l8 [BL] %u != %u", assoc2dconstraintgroup->l8, l8); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "parent", &parent, NULL)
        && !memcmp(&parent, &assoc2dconstraintgroup->parent, sizeof(assoc2dconstraintgroup->parent)))
      pass ("ASSOC2DCONSTRAINTGROUP.parent");
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.parent"); error++;
      }
  }
  {
    BITCODE_BL solution_status;
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "solution_status", &solution_status, NULL) &&
        solution_status == assoc2dconstraintgroup->solution_status)
      pass ("ASSOC2DCONSTRAINTGROUP.solution_status [BL]");
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.solution_status [BL] %u != %u", assoc2dconstraintgroup->solution_status, solution_status); error++;
      }
  }
  {
    BITCODE_BD w1;
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "w1", &w1, NULL) &&
        w1 == assoc2dconstraintgroup->w1)
      pass ("ASSOC2DCONSTRAINTGROUP.w1 [BD]");
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.w1 [BD] %g != %g", assoc2dconstraintgroup->w1, w1); error++;
      }
  }
  {
    BITCODE_BD w2;
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "w2", &w2, NULL) &&
        w2 == assoc2dconstraintgroup->w2)
      pass ("ASSOC2DCONSTRAINTGROUP.w2 [BD]");
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.w2 [BD] %g != %g", assoc2dconstraintgroup->w2, w2); error++;
      }
  }
  {
    BITCODE_BD w3;
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "w3", &w3, NULL) &&
        w3 == assoc2dconstraintgroup->w3)
      pass ("ASSOC2DCONSTRAINTGROUP.w3 [BD]");
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.w3 [BD] %g != %g", assoc2dconstraintgroup->w3, w3); error++;
      }
  }
  {
    BITCODE_3BD workplane[3];
    if (dwg_dynapi_entity_value(assoc2dconstraintgroup, "ASSOC2DCONSTRAINTGROUP", "workplane[3]", &workplane, NULL)
        && !memcmp(&workplane, &assoc2dconstraintgroup->workplane, sizeof(assoc2dconstraintgroup->workplane)))
      pass ("ASSOC2DCONSTRAINTGROUP.workplane[3]");
    else
      {
        fail ("ASSOC2DCONSTRAINTGROUP.workplane[3]"); error++;
      }
  }
  return error;
}
static int test_ASSOCACTION (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_ASSOCACTION *assocaction = obj->tio.object->tio.ASSOCACTION;
  {
    BITCODE_H actionbody;
    if (dwg_dynapi_entity_value(assocaction, "ASSOCACTION", "actionbody", &actionbody, NULL) &&
        actionbody == assocaction->actionbody)
      pass ("ASSOCACTION.actionbody [H]");
    else
      {
        fail ("ASSOCACTION.actionbody [H] %p != %p", assocaction->actionbody, actionbody); error++;
      }
  }
  {
    Dwg_ACTIONBODY body;
    if (dwg_dynapi_entity_value(assocaction, "ASSOCACTION", "body", &body, NULL)
        && !memcmp(&body, &assocaction->body, sizeof(assocaction->body)))
      pass ("ASSOCACTION.body");
    else
      {
        fail ("ASSOCACTION.body"); error++;
      }
  }
  {
    BITCODE_H callback;
    if (dwg_dynapi_entity_value(assocaction, "ASSOCACTION", "callback", &callback, NULL) &&
        callback == assocaction->callback)
      pass ("ASSOCACTION.callback [H]");
    else
      {
        fail ("ASSOCACTION.callback [H] %p != %p", assocaction->callback, callback); error++;
      }
  }
  {
    BITCODE_B is_body_a_proxy;
    if (dwg_dynapi_entity_value(assocaction, "ASSOCACTION", "is_body_a_proxy", &is_body_a_proxy, NULL) &&
        is_body_a_proxy == assocaction->is_body_a_proxy)
      pass ("ASSOCACTION.is_body_a_proxy [B]");
    else
      {
        fail ("ASSOCACTION.is_body_a_proxy [B] " FORMAT_B " != " FORMAT_B "", assocaction->is_body_a_proxy, is_body_a_proxy); error++;
      }
  }
  {
    BITCODE_BL num_deps;
    if (dwg_dynapi_entity_value(assocaction, "ASSOCACTION", "num_deps", &num_deps, NULL) &&
        num_deps == assocaction->num_deps)
      pass ("ASSOCACTION.num_deps [BL]");
    else
      {
        fail ("ASSOCACTION.num_deps [BL] %u != %u", assocaction->num_deps, num_deps); error++;
      }
  }
  {
    BITCODE_H owningnetwork;
    if (dwg_dynapi_entity_value(assocaction, "ASSOCACTION", "owningnetwork", &owningnetwork, NULL) &&
        owningnetwork == assocaction->owningnetwork)
      pass ("ASSOCACTION.owningnetwork [H]");
    else
      {
        fail ("ASSOCACTION.owningnetwork [H] %p != %p", assocaction->owningnetwork, owningnetwork); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(assocaction, "ASSOCACTION", "parent", &parent, NULL)
        && !memcmp(&parent, &assocaction->parent, sizeof(assocaction->parent)))
      pass ("ASSOCACTION.parent");
    else
      {
        fail ("ASSOCACTION.parent"); error++;
      }
  }
  {
    BITCODE_H* readdeps;
    if (dwg_dynapi_entity_value(assocaction, "ASSOCACTION", "readdeps", &readdeps, NULL)
        && !memcmp(&readdeps, &assocaction->readdeps, sizeof(assocaction->readdeps)))
      pass ("ASSOCACTION.readdeps");
    else
      {
        fail ("ASSOCACTION.readdeps"); error++;
      }
  }
  {
    BITCODE_BL status;
    if (dwg_dynapi_entity_value(assocaction, "ASSOCACTION", "status", &status, NULL) &&
        status == assocaction->status)
      pass ("ASSOCACTION.status [BL]");
    else
      {
        fail ("ASSOCACTION.status [BL] %u != %u", assocaction->status, status); error++;
      }
  }
  {
    BITCODE_BL unknown_assoc;
    if (dwg_dynapi_entity_value(assocaction, "ASSOCACTION", "unknown_assoc", &unknown_assoc, NULL) &&
        unknown_assoc == assocaction->unknown_assoc)
      pass ("ASSOCACTION.unknown_assoc [BL]");
    else
      {
        fail ("ASSOCACTION.unknown_assoc [BL] %u != %u", assocaction->unknown_assoc, unknown_assoc); error++;
      }
  }
  {
    BITCODE_H* writedeps;
    if (dwg_dynapi_entity_value(assocaction, "ASSOCACTION", "writedeps", &writedeps, NULL)
        && !memcmp(&writedeps, &assocaction->writedeps, sizeof(assocaction->writedeps)))
      pass ("ASSOCACTION.writedeps");
    else
      {
        fail ("ASSOCACTION.writedeps"); error++;
      }
  }
  return error;
}
static int test_ASSOCALIGNEDDIMACTIONBODY (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_ASSOCALIGNEDDIMACTIONBODY *assocaligneddimactionbody = obj->tio.object->tio.ASSOCALIGNEDDIMACTIONBODY;
  {
    BITCODE_BL aab_status;
    if (dwg_dynapi_entity_value(assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "aab_status", &aab_status, NULL) &&
        aab_status == assocaligneddimactionbody->aab_status)
      pass ("ASSOCALIGNEDDIMACTIONBODY.aab_status [BL]");
    else
      {
        fail ("ASSOCALIGNEDDIMACTIONBODY.aab_status [BL] %u != %u", assocaligneddimactionbody->aab_status, aab_status); error++;
      }
  }
  {
    BITCODE_H d_node;
    if (dwg_dynapi_entity_value(assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "d_node", &d_node, NULL) &&
        d_node == assocaligneddimactionbody->d_node)
      pass ("ASSOCALIGNEDDIMACTIONBODY.d_node [H]");
    else
      {
        fail ("ASSOCALIGNEDDIMACTIONBODY.d_node [H] %p != %p", assocaligneddimactionbody->d_node, d_node); error++;
      }
  }
  {
    BITCODE_BL dcm_status;
    if (dwg_dynapi_entity_value(assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "dcm_status", &dcm_status, NULL) &&
        dcm_status == assocaligneddimactionbody->dcm_status)
      pass ("ASSOCALIGNEDDIMACTIONBODY.dcm_status [BL]");
    else
      {
        fail ("ASSOCALIGNEDDIMACTIONBODY.dcm_status [BL] %u != %u", assocaligneddimactionbody->dcm_status, dcm_status); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "ownerhandle", &ownerhandle, NULL) &&
        ownerhandle == assocaligneddimactionbody->ownerhandle)
      pass ("ASSOCALIGNEDDIMACTIONBODY.ownerhandle [H]");
    else
      {
        fail ("ASSOCALIGNEDDIMACTIONBODY.ownerhandle [H] %p != %p", assocaligneddimactionbody->ownerhandle, ownerhandle); error++;
      }
  }
  {
    BITCODE_BL pab_l2;
    if (dwg_dynapi_entity_value(assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "pab_l2", &pab_l2, NULL) &&
        pab_l2 == assocaligneddimactionbody->pab_l2)
      pass ("ASSOCALIGNEDDIMACTIONBODY.pab_l2 [BL]");
    else
      {
        fail ("ASSOCALIGNEDDIMACTIONBODY.pab_l2 [BL] %u != %u", assocaligneddimactionbody->pab_l2, pab_l2); error++;
      }
  }
  {
    BITCODE_BL pab_l3;
    if (dwg_dynapi_entity_value(assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "pab_l3", &pab_l3, NULL) &&
        pab_l3 == assocaligneddimactionbody->pab_l3)
      pass ("ASSOCALIGNEDDIMACTIONBODY.pab_l3 [BL]");
    else
      {
        fail ("ASSOCALIGNEDDIMACTIONBODY.pab_l3 [BL] %u != %u", assocaligneddimactionbody->pab_l3, pab_l3); error++;
      }
  }
  {
    BITCODE_BL pab_l4;
    if (dwg_dynapi_entity_value(assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "pab_l4", &pab_l4, NULL) &&
        pab_l4 == assocaligneddimactionbody->pab_l4)
      pass ("ASSOCALIGNEDDIMACTIONBODY.pab_l4 [BL]");
    else
      {
        fail ("ASSOCALIGNEDDIMACTIONBODY.pab_l4 [BL] %u != %u", assocaligneddimactionbody->pab_l4, pab_l4); error++;
      }
  }
  {
    BITCODE_BL pab_l5;
    if (dwg_dynapi_entity_value(assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "pab_l5", &pab_l5, NULL) &&
        pab_l5 == assocaligneddimactionbody->pab_l5)
      pass ("ASSOCALIGNEDDIMACTIONBODY.pab_l5 [BL]");
    else
      {
        fail ("ASSOCALIGNEDDIMACTIONBODY.pab_l5 [BL] %u != %u", assocaligneddimactionbody->pab_l5, pab_l5); error++;
      }
  }
  {
    BITCODE_BL pab_l6;
    if (dwg_dynapi_entity_value(assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "pab_l6", &pab_l6, NULL) &&
        pab_l6 == assocaligneddimactionbody->pab_l6)
      pass ("ASSOCALIGNEDDIMACTIONBODY.pab_l6 [BL]");
    else
      {
        fail ("ASSOCALIGNEDDIMACTIONBODY.pab_l6 [BL] %u != %u", assocaligneddimactionbody->pab_l6, pab_l6); error++;
      }
  }
  {
    BITCODE_BL pab_status;
    if (dwg_dynapi_entity_value(assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "pab_status", &pab_status, NULL) &&
        pab_status == assocaligneddimactionbody->pab_status)
      pass ("ASSOCALIGNEDDIMACTIONBODY.pab_status [BL]");
    else
      {
        fail ("ASSOCALIGNEDDIMACTIONBODY.pab_status [BL] %u != %u", assocaligneddimactionbody->pab_status, pab_status); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "parent", &parent, NULL)
        && !memcmp(&parent, &assocaligneddimactionbody->parent, sizeof(assocaligneddimactionbody->parent)))
      pass ("ASSOCALIGNEDDIMACTIONBODY.parent");
    else
      {
        fail ("ASSOCALIGNEDDIMACTIONBODY.parent"); error++;
      }
  }
  {
    BITCODE_H r_node;
    if (dwg_dynapi_entity_value(assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "r_node", &r_node, NULL) &&
        r_node == assocaligneddimactionbody->r_node)
      pass ("ASSOCALIGNEDDIMACTIONBODY.r_node [H]");
    else
      {
        fail ("ASSOCALIGNEDDIMACTIONBODY.r_node [H] %p != %p", assocaligneddimactionbody->r_node, r_node); error++;
      }
  }
  {
    BITCODE_H readdep;
    if (dwg_dynapi_entity_value(assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "readdep", &readdep, NULL) &&
        readdep == assocaligneddimactionbody->readdep)
      pass ("ASSOCALIGNEDDIMACTIONBODY.readdep [H]");
    else
      {
        fail ("ASSOCALIGNEDDIMACTIONBODY.readdep [H] %p != %p", assocaligneddimactionbody->readdep, readdep); error++;
      }
  }
  {
    BITCODE_H writedep;
    if (dwg_dynapi_entity_value(assocaligneddimactionbody, "ASSOCALIGNEDDIMACTIONBODY", "writedep", &writedep, NULL) &&
        writedep == assocaligneddimactionbody->writedep)
      pass ("ASSOCALIGNEDDIMACTIONBODY.writedep [H]");
    else
      {
        fail ("ASSOCALIGNEDDIMACTIONBODY.writedep [H] %p != %p", assocaligneddimactionbody->writedep, writedep); error++;
      }
  }
  return error;
}
static int test_ASSOCDEPENDENCY (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_ASSOCDEPENDENCY *assocdependency = obj->tio.object->tio.ASSOCDEPENDENCY;
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value(assocdependency, "ASSOCDEPENDENCY", "class_version", &class_version, NULL) &&
        class_version == assocdependency->class_version)
      pass ("ASSOCDEPENDENCY.class_version [BL]");
    else
      {
        fail ("ASSOCDEPENDENCY.class_version [BL] %u != %u", assocdependency->class_version, class_version); error++;
      }
  }
  {
    BITCODE_BL depbodyid;
    if (dwg_dynapi_entity_value(assocdependency, "ASSOCDEPENDENCY", "depbodyid", &depbodyid, NULL) &&
        depbodyid == assocdependency->depbodyid)
      pass ("ASSOCDEPENDENCY.depbodyid [BL]");
    else
      {
        fail ("ASSOCDEPENDENCY.depbodyid [BL] %u != %u", assocdependency->depbodyid, depbodyid); error++;
      }
  }
  {
    BITCODE_B isobjectstate_dep;
    if (dwg_dynapi_entity_value(assocdependency, "ASSOCDEPENDENCY", "isobjectstate_dep", &isobjectstate_dep, NULL) &&
        isobjectstate_dep == assocdependency->isobjectstate_dep)
      pass ("ASSOCDEPENDENCY.isobjectstate_dep [B]");
    else
      {
        fail ("ASSOCDEPENDENCY.isobjectstate_dep [B] " FORMAT_B " != " FORMAT_B "", assocdependency->isobjectstate_dep, isobjectstate_dep); error++;
      }
  }
  {
    BITCODE_B isread_dep;
    if (dwg_dynapi_entity_value(assocdependency, "ASSOCDEPENDENCY", "isread_dep", &isread_dep, NULL) &&
        isread_dep == assocdependency->isread_dep)
      pass ("ASSOCDEPENDENCY.isread_dep [B]");
    else
      {
        fail ("ASSOCDEPENDENCY.isread_dep [B] " FORMAT_B " != " FORMAT_B "", assocdependency->isread_dep, isread_dep); error++;
      }
  }
  {
    BITCODE_B iswrite_dep;
    if (dwg_dynapi_entity_value(assocdependency, "ASSOCDEPENDENCY", "iswrite_dep", &iswrite_dep, NULL) &&
        iswrite_dep == assocdependency->iswrite_dep)
      pass ("ASSOCDEPENDENCY.iswrite_dep [B]");
    else
      {
        fail ("ASSOCDEPENDENCY.iswrite_dep [B] " FORMAT_B " != " FORMAT_B "", assocdependency->iswrite_dep, iswrite_dep); error++;
      }
  }
  {
    BITCODE_H node;
    if (dwg_dynapi_entity_value(assocdependency, "ASSOCDEPENDENCY", "node", &node, NULL) &&
        node == assocdependency->node)
      pass ("ASSOCDEPENDENCY.node [H]");
    else
      {
        fail ("ASSOCDEPENDENCY.node [H] %p != %p", assocdependency->node, node); error++;
      }
  }
  {
    BITCODE_BL order;
    if (dwg_dynapi_entity_value(assocdependency, "ASSOCDEPENDENCY", "order", &order, NULL) &&
        order == assocdependency->order)
      pass ("ASSOCDEPENDENCY.order [BL]");
    else
      {
        fail ("ASSOCDEPENDENCY.order [BL] %u != %u", assocdependency->order, order); error++;
      }
  }
  {
    BITCODE_H owner;
    if (dwg_dynapi_entity_value(assocdependency, "ASSOCDEPENDENCY", "owner", &owner, NULL) &&
        owner == assocdependency->owner)
      pass ("ASSOCDEPENDENCY.owner [H]");
    else
      {
        fail ("ASSOCDEPENDENCY.owner [H] %p != %p", assocdependency->owner, owner); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(assocdependency, "ASSOCDEPENDENCY", "ownerhandle", &ownerhandle, NULL) &&
        ownerhandle == assocdependency->ownerhandle)
      pass ("ASSOCDEPENDENCY.ownerhandle [H]");
    else
      {
        fail ("ASSOCDEPENDENCY.ownerhandle [H] %p != %p", assocdependency->ownerhandle, ownerhandle); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(assocdependency, "ASSOCDEPENDENCY", "parent", &parent, NULL)
        && !memcmp(&parent, &assocdependency->parent, sizeof(assocdependency->parent)))
      pass ("ASSOCDEPENDENCY.parent");
    else
      {
        fail ("ASSOCDEPENDENCY.parent"); error++;
      }
  }
  {
    BITCODE_H readdep;
    if (dwg_dynapi_entity_value(assocdependency, "ASSOCDEPENDENCY", "readdep", &readdep, NULL) &&
        readdep == assocdependency->readdep)
      pass ("ASSOCDEPENDENCY.readdep [H]");
    else
      {
        fail ("ASSOCDEPENDENCY.readdep [H] %p != %p", assocdependency->readdep, readdep); error++;
      }
  }
  {
    BITCODE_BL status;
    if (dwg_dynapi_entity_value(assocdependency, "ASSOCDEPENDENCY", "status", &status, NULL) &&
        status == assocdependency->status)
      pass ("ASSOCDEPENDENCY.status [BL]");
    else
      {
        fail ("ASSOCDEPENDENCY.status [BL] %u != %u", assocdependency->status, status); error++;
      }
  }
  {
    BITCODE_B unknown_b4;
    if (dwg_dynapi_entity_value(assocdependency, "ASSOCDEPENDENCY", "unknown_b4", &unknown_b4, NULL) &&
        unknown_b4 == assocdependency->unknown_b4)
      pass ("ASSOCDEPENDENCY.unknown_b4 [B]");
    else
      {
        fail ("ASSOCDEPENDENCY.unknown_b4 [B] " FORMAT_B " != " FORMAT_B "", assocdependency->unknown_b4, unknown_b4); error++;
      }
  }
  {
    BITCODE_B unknown_b5;
    if (dwg_dynapi_entity_value(assocdependency, "ASSOCDEPENDENCY", "unknown_b5", &unknown_b5, NULL) &&
        unknown_b5 == assocdependency->unknown_b5)
      pass ("ASSOCDEPENDENCY.unknown_b5 [B]");
    else
      {
        fail ("ASSOCDEPENDENCY.unknown_b5 [B] " FORMAT_B " != " FORMAT_B "", assocdependency->unknown_b5, unknown_b5); error++;
      }
  }
  {
    BITCODE_H writedep;
    if (dwg_dynapi_entity_value(assocdependency, "ASSOCDEPENDENCY", "writedep", &writedep, NULL) &&
        writedep == assocdependency->writedep)
      pass ("ASSOCDEPENDENCY.writedep [H]");
    else
      {
        fail ("ASSOCDEPENDENCY.writedep [H] %p != %p", assocdependency->writedep, writedep); error++;
      }
  }
  return error;
}
static int test_ASSOCNETWORK (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_ASSOCNETWORK *assocnetwork = obj->tio.object->tio.ASSOCNETWORK;
  {
    BITCODE_H* actions;
    if (dwg_dynapi_entity_value(assocnetwork, "ASSOCNETWORK", "actions", &actions, NULL)
        && !memcmp(&actions, &assocnetwork->actions, sizeof(assocnetwork->actions)))
      pass ("ASSOCNETWORK.actions");
    else
      {
        fail ("ASSOCNETWORK.actions"); error++;
      }
  }
  {
    BITCODE_BL num_actions;
    if (dwg_dynapi_entity_value(assocnetwork, "ASSOCNETWORK", "num_actions", &num_actions, NULL) &&
        num_actions == assocnetwork->num_actions)
      pass ("ASSOCNETWORK.num_actions [BL]");
    else
      {
        fail ("ASSOCNETWORK.num_actions [BL] %u != %u", assocnetwork->num_actions, num_actions); error++;
      }
  }
  {
    BITCODE_BL num_deps;
    if (dwg_dynapi_entity_value(assocnetwork, "ASSOCNETWORK", "num_deps", &num_deps, NULL) &&
        num_deps == assocnetwork->num_deps)
      pass ("ASSOCNETWORK.num_deps [BL]");
    else
      {
        fail ("ASSOCNETWORK.num_deps [BL] %u != %u", assocnetwork->num_deps, num_deps); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(assocnetwork, "ASSOCNETWORK", "parent", &parent, NULL)
        && !memcmp(&parent, &assocnetwork->parent, sizeof(assocnetwork->parent)))
      pass ("ASSOCNETWORK.parent");
    else
      {
        fail ("ASSOCNETWORK.parent"); error++;
      }
  }
  {
    BITCODE_H readdep;
    if (dwg_dynapi_entity_value(assocnetwork, "ASSOCNETWORK", "readdep", &readdep, NULL) &&
        readdep == assocnetwork->readdep)
      pass ("ASSOCNETWORK.readdep [H]");
    else
      {
        fail ("ASSOCNETWORK.readdep [H] %p != %p", assocnetwork->readdep, readdep); error++;
      }
  }
  {
    BITCODE_BL status;
    if (dwg_dynapi_entity_value(assocnetwork, "ASSOCNETWORK", "status", &status, NULL) &&
        status == assocnetwork->status)
      pass ("ASSOCNETWORK.status [BL]");
    else
      {
        fail ("ASSOCNETWORK.status [BL] %u != %u", assocnetwork->status, status); error++;
      }
  }
  {
    BITCODE_BL unknown_assoc;
    if (dwg_dynapi_entity_value(assocnetwork, "ASSOCNETWORK", "unknown_assoc", &unknown_assoc, NULL) &&
        unknown_assoc == assocnetwork->unknown_assoc)
      pass ("ASSOCNETWORK.unknown_assoc [BL]");
    else
      {
        fail ("ASSOCNETWORK.unknown_assoc [BL] %u != %u", assocnetwork->unknown_assoc, unknown_assoc); error++;
      }
  }
  {
    BITCODE_BL unknown_n1;
    if (dwg_dynapi_entity_value(assocnetwork, "ASSOCNETWORK", "unknown_n1", &unknown_n1, NULL) &&
        unknown_n1 == assocnetwork->unknown_n1)
      pass ("ASSOCNETWORK.unknown_n1 [BL]");
    else
      {
        fail ("ASSOCNETWORK.unknown_n1 [BL] %u != %u", assocnetwork->unknown_n1, unknown_n1); error++;
      }
  }
  {
    BITCODE_BL unknown_n2;
    if (dwg_dynapi_entity_value(assocnetwork, "ASSOCNETWORK", "unknown_n2", &unknown_n2, NULL) &&
        unknown_n2 == assocnetwork->unknown_n2)
      pass ("ASSOCNETWORK.unknown_n2 [BL]");
    else
      {
        fail ("ASSOCNETWORK.unknown_n2 [BL] %u != %u", assocnetwork->unknown_n2, unknown_n2); error++;
      }
  }
  {
    BITCODE_H writedep;
    if (dwg_dynapi_entity_value(assocnetwork, "ASSOCNETWORK", "writedep", &writedep, NULL) &&
        writedep == assocnetwork->writedep)
      pass ("ASSOCNETWORK.writedep [H]");
    else
      {
        fail ("ASSOCNETWORK.writedep [H] %p != %p", assocnetwork->writedep, writedep); error++;
      }
  }
  return error;
}
static int test_ASSOCOSNAPPOINTREFACTIONPARAM (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_ASSOCOSNAPPOINTREFACTIONPARAM *assocosnappointrefactionparam = obj->tio.object->tio.ASSOCOSNAPPOINTREFACTIONPARAM;
  {
    BITCODE_H actionparam;
    if (dwg_dynapi_entity_value(assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "actionparam", &actionparam, NULL) &&
        actionparam == assocosnappointrefactionparam->actionparam)
      pass ("ASSOCOSNAPPOINTREFACTIONPARAM.actionparam [H]");
    else
      {
        fail ("ASSOCOSNAPPOINTREFACTIONPARAM.actionparam [H] %p != %p", assocosnappointrefactionparam->actionparam, actionparam); error++;
      }
  }
  {
    BITCODE_RS flags;
    if (dwg_dynapi_entity_value(assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "flags", &flags, NULL) &&
        flags == assocosnappointrefactionparam->flags)
      pass ("ASSOCOSNAPPOINTREFACTIONPARAM.flags [RS]");
    else
      {
        fail ("ASSOCOSNAPPOINTREFACTIONPARAM.flags [RS] " FORMAT_RS " != " FORMAT_RS "", assocosnappointrefactionparam->flags, flags); error++;
      }
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value(assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "name", &name, NULL)
        && !memcmp(&name, &assocosnappointrefactionparam->name, sizeof(assocosnappointrefactionparam->name)))
      pass ("ASSOCOSNAPPOINTREFACTIONPARAM.name");
    else
      {
        fail ("ASSOCOSNAPPOINTREFACTIONPARAM.name"); error++;
      }
  }
  {
    BITCODE_BS num_params;
    if (dwg_dynapi_entity_value(assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "num_params", &num_params, NULL) &&
        num_params == assocosnappointrefactionparam->num_params)
      pass ("ASSOCOSNAPPOINTREFACTIONPARAM.num_params [BS]");
    else
      {
        fail ("ASSOCOSNAPPOINTREFACTIONPARAM.num_params [BS] %d != %d", assocosnappointrefactionparam->num_params, num_params); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "parent", &parent, NULL)
        && !memcmp(&parent, &assocosnappointrefactionparam->parent, sizeof(assocosnappointrefactionparam->parent)))
      pass ("ASSOCOSNAPPOINTREFACTIONPARAM.parent");
    else
      {
        fail ("ASSOCOSNAPPOINTREFACTIONPARAM.parent"); error++;
      }
  }
  {
    BITCODE_BS status;
    if (dwg_dynapi_entity_value(assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "status", &status, NULL) &&
        status == assocosnappointrefactionparam->status)
      pass ("ASSOCOSNAPPOINTREFACTIONPARAM.status [BS]");
    else
      {
        fail ("ASSOCOSNAPPOINTREFACTIONPARAM.status [BS] %d != %d", assocosnappointrefactionparam->status, status); error++;
      }
  }
  {
    BITCODE_RC unknown;
    if (dwg_dynapi_entity_value(assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "unknown", &unknown, NULL) &&
        unknown == assocosnappointrefactionparam->unknown)
      pass ("ASSOCOSNAPPOINTREFACTIONPARAM.unknown [RC]");
    else
      {
        fail ("ASSOCOSNAPPOINTREFACTIONPARAM.unknown [RC] %c != %c", assocosnappointrefactionparam->unknown, unknown); error++;
      }
  }
  {
    BITCODE_B unknown1;
    if (dwg_dynapi_entity_value(assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "unknown1", &unknown1, NULL) &&
        unknown1 == assocosnappointrefactionparam->unknown1)
      pass ("ASSOCOSNAPPOINTREFACTIONPARAM.unknown1 [B]");
    else
      {
        fail ("ASSOCOSNAPPOINTREFACTIONPARAM.unknown1 [B] " FORMAT_B " != " FORMAT_B "", assocosnappointrefactionparam->unknown1, unknown1); error++;
      }
  }
  {
    BITCODE_BD unknown3;
    if (dwg_dynapi_entity_value(assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "unknown3", &unknown3, NULL) &&
        unknown3 == assocosnappointrefactionparam->unknown3)
      pass ("ASSOCOSNAPPOINTREFACTIONPARAM.unknown3 [BD]");
    else
      {
        fail ("ASSOCOSNAPPOINTREFACTIONPARAM.unknown3 [BD] %g != %g", assocosnappointrefactionparam->unknown3, unknown3); error++;
      }
  }
  {
    BITCODE_H writedep;
    if (dwg_dynapi_entity_value(assocosnappointrefactionparam, "ASSOCOSNAPPOINTREFACTIONPARAM", "writedep", &writedep, NULL) &&
        writedep == assocosnappointrefactionparam->writedep)
      pass ("ASSOCOSNAPPOINTREFACTIONPARAM.writedep [H]");
    else
      {
        fail ("ASSOCOSNAPPOINTREFACTIONPARAM.writedep [H] %p != %p", assocosnappointrefactionparam->writedep, writedep); error++;
      }
  }
  return error;
}
static int test_ASSOCPERSSUBENTMANAGER (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_ASSOCPERSSUBENTMANAGER *assocperssubentmanager = obj->tio.object->tio.ASSOCPERSSUBENTMANAGER;
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "class_version", &class_version, NULL) &&
        class_version == assocperssubentmanager->class_version)
      pass ("ASSOCPERSSUBENTMANAGER.class_version [BL]");
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.class_version [BL] %u != %u", assocperssubentmanager->class_version, class_version); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "ownerhandle", &ownerhandle, NULL) &&
        ownerhandle == assocperssubentmanager->ownerhandle)
      pass ("ASSOCPERSSUBENTMANAGER.ownerhandle [H]");
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.ownerhandle [H] %p != %p", assocperssubentmanager->ownerhandle, ownerhandle); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "parent", &parent, NULL)
        && !memcmp(&parent, &assocperssubentmanager->parent, sizeof(assocperssubentmanager->parent)))
      pass ("ASSOCPERSSUBENTMANAGER.parent");
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.parent"); error++;
      }
  }
  {
    BITCODE_B unknown_b37;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_b37", &unknown_b37, NULL) &&
        unknown_b37 == assocperssubentmanager->unknown_b37)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_b37 [B]");
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_b37 [B] " FORMAT_B " != " FORMAT_B "", assocperssubentmanager->unknown_b37, unknown_b37); error++;
      }
  }
  {
    BITCODE_BL unknown_bl1;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl1", &unknown_bl1, NULL) &&
        unknown_bl1 == assocperssubentmanager->unknown_bl1)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl1 [BL]");
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl1 [BL] %u != %u", assocperssubentmanager->unknown_bl1, unknown_bl1); error++;
      }
  }
  {
    BITCODE_BL unknown_bl10;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl10", &unknown_bl10, NULL) &&
        unknown_bl10 == assocperssubentmanager->unknown_bl10)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl10 [BL]");
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl10 [BL] %u != %u", assocperssubentmanager->unknown_bl10, unknown_bl10); error++;
      }
  }
  {
    BITCODE_BL unknown_bl11;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl11", &unknown_bl11, NULL) &&
        unknown_bl11 == assocperssubentmanager->unknown_bl11)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl11 [BL]");
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl11 [BL] %u != %u", assocperssubentmanager->unknown_bl11, unknown_bl11); error++;
      }
  }
  {
    BITCODE_BL unknown_bl12;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl12", &unknown_bl12, NULL) &&
        unknown_bl12 == assocperssubentmanager->unknown_bl12)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl12 [BL]");
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl12 [BL] %u != %u", assocperssubentmanager->unknown_bl12, unknown_bl12); error++;
      }
  }
  {
    BITCODE_BL unknown_bl13;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl13", &unknown_bl13, NULL) &&
        unknown_bl13 == assocperssubentmanager->unknown_bl13)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl13 [BL]");
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl13 [BL] %u != %u", assocperssubentmanager->unknown_bl13, unknown_bl13); error++;
      }
  }
  {
    BITCODE_BL unknown_bl14;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl14", &unknown_bl14, NULL) &&
        unknown_bl14 == assocperssubentmanager->unknown_bl14)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl14 [BL]");
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl14 [BL] %u != %u", assocperssubentmanager->unknown_bl14, unknown_bl14); error++;
      }
  }
  {
    BITCODE_BL unknown_bl15;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl15", &unknown_bl15, NULL) &&
        unknown_bl15 == assocperssubentmanager->unknown_bl15)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl15 [BL]");
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl15 [BL] %u != %u", assocperssubentmanager->unknown_bl15, unknown_bl15); error++;
      }
  }
  {
    BITCODE_BL unknown_bl16;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl16", &unknown_bl16, NULL) &&
        unknown_bl16 == assocperssubentmanager->unknown_bl16)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl16 [BL]");
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl16 [BL] %u != %u", assocperssubentmanager->unknown_bl16, unknown_bl16); error++;
      }
  }
  {
    BITCODE_BL unknown_bl17;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl17", &unknown_bl17, NULL) &&
        unknown_bl17 == assocperssubentmanager->unknown_bl17)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl17 [BL]");
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl17 [BL] %u != %u", assocperssubentmanager->unknown_bl17, unknown_bl17); error++;
      }
  }
  {
    BITCODE_BL unknown_bl18;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl18", &unknown_bl18, NULL) &&
        unknown_bl18 == assocperssubentmanager->unknown_bl18)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl18 [BL]");
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl18 [BL] %u != %u", assocperssubentmanager->unknown_bl18, unknown_bl18); error++;
      }
  }
  {
    BITCODE_BL unknown_bl19;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl19", &unknown_bl19, NULL) &&
        unknown_bl19 == assocperssubentmanager->unknown_bl19)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl19 [BL]");
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl19 [BL] %u != %u", assocperssubentmanager->unknown_bl19, unknown_bl19); error++;
      }
  }
  {
    BITCODE_BL unknown_bl2;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl2", &unknown_bl2, NULL) &&
        unknown_bl2 == assocperssubentmanager->unknown_bl2)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl2 [BL]");
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl2 [BL] %u != %u", assocperssubentmanager->unknown_bl2, unknown_bl2); error++;
      }
  }
  {
    BITCODE_BL unknown_bl20;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl20", &unknown_bl20, NULL) &&
        unknown_bl20 == assocperssubentmanager->unknown_bl20)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl20 [BL]");
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl20 [BL] %u != %u", assocperssubentmanager->unknown_bl20, unknown_bl20); error++;
      }
  }
  {
    BITCODE_BL unknown_bl21;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl21", &unknown_bl21, NULL) &&
        unknown_bl21 == assocperssubentmanager->unknown_bl21)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl21 [BL]");
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl21 [BL] %u != %u", assocperssubentmanager->unknown_bl21, unknown_bl21); error++;
      }
  }
  {
    BITCODE_BL unknown_bl22;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl22", &unknown_bl22, NULL) &&
        unknown_bl22 == assocperssubentmanager->unknown_bl22)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl22 [BL]");
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl22 [BL] %u != %u", assocperssubentmanager->unknown_bl22, unknown_bl22); error++;
      }
  }
  {
    BITCODE_BL unknown_bl23;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl23", &unknown_bl23, NULL) &&
        unknown_bl23 == assocperssubentmanager->unknown_bl23)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl23 [BL]");
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl23 [BL] %u != %u", assocperssubentmanager->unknown_bl23, unknown_bl23); error++;
      }
  }
  {
    BITCODE_BL unknown_bl24;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl24", &unknown_bl24, NULL) &&
        unknown_bl24 == assocperssubentmanager->unknown_bl24)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl24 [BL]");
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl24 [BL] %u != %u", assocperssubentmanager->unknown_bl24, unknown_bl24); error++;
      }
  }
  {
    BITCODE_BL unknown_bl25;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl25", &unknown_bl25, NULL) &&
        unknown_bl25 == assocperssubentmanager->unknown_bl25)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl25 [BL]");
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl25 [BL] %u != %u", assocperssubentmanager->unknown_bl25, unknown_bl25); error++;
      }
  }
  {
    BITCODE_BL unknown_bl26;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl26", &unknown_bl26, NULL) &&
        unknown_bl26 == assocperssubentmanager->unknown_bl26)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl26 [BL]");
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl26 [BL] %u != %u", assocperssubentmanager->unknown_bl26, unknown_bl26); error++;
      }
  }
  {
    BITCODE_BL unknown_bl27;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl27", &unknown_bl27, NULL) &&
        unknown_bl27 == assocperssubentmanager->unknown_bl27)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl27 [BL]");
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl27 [BL] %u != %u", assocperssubentmanager->unknown_bl27, unknown_bl27); error++;
      }
  }
  {
    BITCODE_BL unknown_bl28;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl28", &unknown_bl28, NULL) &&
        unknown_bl28 == assocperssubentmanager->unknown_bl28)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl28 [BL]");
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl28 [BL] %u != %u", assocperssubentmanager->unknown_bl28, unknown_bl28); error++;
      }
  }
  {
    BITCODE_BL unknown_bl29;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl29", &unknown_bl29, NULL) &&
        unknown_bl29 == assocperssubentmanager->unknown_bl29)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl29 [BL]");
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl29 [BL] %u != %u", assocperssubentmanager->unknown_bl29, unknown_bl29); error++;
      }
  }
  {
    BITCODE_BL unknown_bl3;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl3", &unknown_bl3, NULL) &&
        unknown_bl3 == assocperssubentmanager->unknown_bl3)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl3 [BL]");
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl3 [BL] %u != %u", assocperssubentmanager->unknown_bl3, unknown_bl3); error++;
      }
  }
  {
    BITCODE_BL unknown_bl30;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl30", &unknown_bl30, NULL) &&
        unknown_bl30 == assocperssubentmanager->unknown_bl30)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl30 [BL]");
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl30 [BL] %u != %u", assocperssubentmanager->unknown_bl30, unknown_bl30); error++;
      }
  }
  {
    BITCODE_BL unknown_bl31;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl31", &unknown_bl31, NULL) &&
        unknown_bl31 == assocperssubentmanager->unknown_bl31)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl31 [BL]");
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl31 [BL] %u != %u", assocperssubentmanager->unknown_bl31, unknown_bl31); error++;
      }
  }
  {
    BITCODE_BL unknown_bl32;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl32", &unknown_bl32, NULL) &&
        unknown_bl32 == assocperssubentmanager->unknown_bl32)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl32 [BL]");
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl32 [BL] %u != %u", assocperssubentmanager->unknown_bl32, unknown_bl32); error++;
      }
  }
  {
    BITCODE_BL unknown_bl33;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl33", &unknown_bl33, NULL) &&
        unknown_bl33 == assocperssubentmanager->unknown_bl33)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl33 [BL]");
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl33 [BL] %u != %u", assocperssubentmanager->unknown_bl33, unknown_bl33); error++;
      }
  }
  {
    BITCODE_BL unknown_bl34;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl34", &unknown_bl34, NULL) &&
        unknown_bl34 == assocperssubentmanager->unknown_bl34)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl34 [BL]");
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl34 [BL] %u != %u", assocperssubentmanager->unknown_bl34, unknown_bl34); error++;
      }
  }
  {
    BITCODE_BL unknown_bl35;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl35", &unknown_bl35, NULL) &&
        unknown_bl35 == assocperssubentmanager->unknown_bl35)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl35 [BL]");
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl35 [BL] %u != %u", assocperssubentmanager->unknown_bl35, unknown_bl35); error++;
      }
  }
  {
    BITCODE_BL unknown_bl36;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl36", &unknown_bl36, NULL) &&
        unknown_bl36 == assocperssubentmanager->unknown_bl36)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl36 [BL]");
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl36 [BL] %u != %u", assocperssubentmanager->unknown_bl36, unknown_bl36); error++;
      }
  }
  {
    BITCODE_BL unknown_bl4;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl4", &unknown_bl4, NULL) &&
        unknown_bl4 == assocperssubentmanager->unknown_bl4)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl4 [BL]");
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl4 [BL] %u != %u", assocperssubentmanager->unknown_bl4, unknown_bl4); error++;
      }
  }
  {
    BITCODE_BL unknown_bl5;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl5", &unknown_bl5, NULL) &&
        unknown_bl5 == assocperssubentmanager->unknown_bl5)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl5 [BL]");
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl5 [BL] %u != %u", assocperssubentmanager->unknown_bl5, unknown_bl5); error++;
      }
  }
  {
    BITCODE_BL unknown_bl6;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl6", &unknown_bl6, NULL) &&
        unknown_bl6 == assocperssubentmanager->unknown_bl6)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl6 [BL]");
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl6 [BL] %u != %u", assocperssubentmanager->unknown_bl6, unknown_bl6); error++;
      }
  }
  {
    BITCODE_BL unknown_bl6a;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl6a", &unknown_bl6a, NULL) &&
        unknown_bl6a == assocperssubentmanager->unknown_bl6a)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl6a [BL]");
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl6a [BL] %u != %u", assocperssubentmanager->unknown_bl6a, unknown_bl6a); error++;
      }
  }
  {
    BITCODE_BL unknown_bl7;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl7", &unknown_bl7, NULL) &&
        unknown_bl7 == assocperssubentmanager->unknown_bl7)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl7 [BL]");
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl7 [BL] %u != %u", assocperssubentmanager->unknown_bl7, unknown_bl7); error++;
      }
  }
  {
    BITCODE_BL unknown_bl7a;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl7a", &unknown_bl7a, NULL) &&
        unknown_bl7a == assocperssubentmanager->unknown_bl7a)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl7a [BL]");
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl7a [BL] %u != %u", assocperssubentmanager->unknown_bl7a, unknown_bl7a); error++;
      }
  }
  {
    BITCODE_BL unknown_bl8;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl8", &unknown_bl8, NULL) &&
        unknown_bl8 == assocperssubentmanager->unknown_bl8)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl8 [BL]");
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl8 [BL] %u != %u", assocperssubentmanager->unknown_bl8, unknown_bl8); error++;
      }
  }
  {
    BITCODE_BL unknown_bl9;
    if (dwg_dynapi_entity_value(assocperssubentmanager, "ASSOCPERSSUBENTMANAGER", "unknown_bl9", &unknown_bl9, NULL) &&
        unknown_bl9 == assocperssubentmanager->unknown_bl9)
      pass ("ASSOCPERSSUBENTMANAGER.unknown_bl9 [BL]");
    else
      {
        fail ("ASSOCPERSSUBENTMANAGER.unknown_bl9 [BL] %u != %u", assocperssubentmanager->unknown_bl9, unknown_bl9); error++;
      }
  }
  return error;
}
static int test_ASSOCPLANESURFACEACTIONBODY (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_ASSOCPLANESURFACEACTIONBODY *assocplanesurfaceactionbody = obj->tio.object->tio.ASSOCPLANESURFACEACTIONBODY;
  {
    BITCODE_BL aab_status;
    if (dwg_dynapi_entity_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "aab_status", &aab_status, NULL) &&
        aab_status == assocplanesurfaceactionbody->aab_status)
      pass ("ASSOCPLANESURFACEACTIONBODY.aab_status [BL]");
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.aab_status [BL] %u != %u", assocplanesurfaceactionbody->aab_status, aab_status); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "ownerhandle", &ownerhandle, NULL) &&
        ownerhandle == assocplanesurfaceactionbody->ownerhandle)
      pass ("ASSOCPLANESURFACEACTIONBODY.ownerhandle [H]");
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.ownerhandle [H] %p != %p", assocplanesurfaceactionbody->ownerhandle, ownerhandle); error++;
      }
  }
  {
    BITCODE_BL pab_l2;
    if (dwg_dynapi_entity_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "pab_l2", &pab_l2, NULL) &&
        pab_l2 == assocplanesurfaceactionbody->pab_l2)
      pass ("ASSOCPLANESURFACEACTIONBODY.pab_l2 [BL]");
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.pab_l2 [BL] %u != %u", assocplanesurfaceactionbody->pab_l2, pab_l2); error++;
      }
  }
  {
    BITCODE_BL pab_l3;
    if (dwg_dynapi_entity_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "pab_l3", &pab_l3, NULL) &&
        pab_l3 == assocplanesurfaceactionbody->pab_l3)
      pass ("ASSOCPLANESURFACEACTIONBODY.pab_l3 [BL]");
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.pab_l3 [BL] %u != %u", assocplanesurfaceactionbody->pab_l3, pab_l3); error++;
      }
  }
  {
    BITCODE_BL pab_l4;
    if (dwg_dynapi_entity_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "pab_l4", &pab_l4, NULL) &&
        pab_l4 == assocplanesurfaceactionbody->pab_l4)
      pass ("ASSOCPLANESURFACEACTIONBODY.pab_l4 [BL]");
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.pab_l4 [BL] %u != %u", assocplanesurfaceactionbody->pab_l4, pab_l4); error++;
      }
  }
  {
    BITCODE_BL pab_l5;
    if (dwg_dynapi_entity_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "pab_l5", &pab_l5, NULL) &&
        pab_l5 == assocplanesurfaceactionbody->pab_l5)
      pass ("ASSOCPLANESURFACEACTIONBODY.pab_l5 [BL]");
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.pab_l5 [BL] %u != %u", assocplanesurfaceactionbody->pab_l5, pab_l5); error++;
      }
  }
  {
    BITCODE_BL pab_status;
    if (dwg_dynapi_entity_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "pab_status", &pab_status, NULL) &&
        pab_status == assocplanesurfaceactionbody->pab_status)
      pass ("ASSOCPLANESURFACEACTIONBODY.pab_status [BL]");
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.pab_status [BL] %u != %u", assocplanesurfaceactionbody->pab_status, pab_status); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "parent", &parent, NULL)
        && !memcmp(&parent, &assocplanesurfaceactionbody->parent, sizeof(assocplanesurfaceactionbody->parent)))
      pass ("ASSOCPLANESURFACEACTIONBODY.parent");
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.parent"); error++;
      }
  }
  {
    BITCODE_BL pbsab_status;
    if (dwg_dynapi_entity_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "pbsab_status", &pbsab_status, NULL) &&
        pbsab_status == assocplanesurfaceactionbody->pbsab_status)
      pass ("ASSOCPLANESURFACEACTIONBODY.pbsab_status [BL]");
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.pbsab_status [BL] %u != %u", assocplanesurfaceactionbody->pbsab_status, pbsab_status); error++;
      }
  }
  {
    BITCODE_BL psab_status;
    if (dwg_dynapi_entity_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "psab_status", &psab_status, NULL) &&
        psab_status == assocplanesurfaceactionbody->psab_status)
      pass ("ASSOCPLANESURFACEACTIONBODY.psab_status [BL]");
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.psab_status [BL] %u != %u", assocplanesurfaceactionbody->psab_status, psab_status); error++;
      }
  }
  {
    BITCODE_H readdep;
    if (dwg_dynapi_entity_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "readdep", &readdep, NULL) &&
        readdep == assocplanesurfaceactionbody->readdep)
      pass ("ASSOCPLANESURFACEACTIONBODY.readdep [H]");
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.readdep [H] %p != %p", assocplanesurfaceactionbody->readdep, readdep); error++;
      }
  }
  {
    BITCODE_B sab_b1;
    if (dwg_dynapi_entity_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "sab_b1", &sab_b1, NULL) &&
        sab_b1 == assocplanesurfaceactionbody->sab_b1)
      pass ("ASSOCPLANESURFACEACTIONBODY.sab_b1 [B]");
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.sab_b1 [B] " FORMAT_B " != " FORMAT_B "", assocplanesurfaceactionbody->sab_b1, sab_b1); error++;
      }
  }
  {
    BITCODE_B sab_b2;
    if (dwg_dynapi_entity_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "sab_b2", &sab_b2, NULL) &&
        sab_b2 == assocplanesurfaceactionbody->sab_b2)
      pass ("ASSOCPLANESURFACEACTIONBODY.sab_b2 [B]");
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.sab_b2 [B] " FORMAT_B " != " FORMAT_B "", assocplanesurfaceactionbody->sab_b2, sab_b2); error++;
      }
  }
  {
    BITCODE_BL sab_l2;
    if (dwg_dynapi_entity_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "sab_l2", &sab_l2, NULL) &&
        sab_l2 == assocplanesurfaceactionbody->sab_l2)
      pass ("ASSOCPLANESURFACEACTIONBODY.sab_l2 [BL]");
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.sab_l2 [BL] %u != %u", assocplanesurfaceactionbody->sab_l2, sab_l2); error++;
      }
  }
  {
    BITCODE_BS sab_s1;
    if (dwg_dynapi_entity_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "sab_s1", &sab_s1, NULL) &&
        sab_s1 == assocplanesurfaceactionbody->sab_s1)
      pass ("ASSOCPLANESURFACEACTIONBODY.sab_s1 [BS]");
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.sab_s1 [BS] %d != %d", assocplanesurfaceactionbody->sab_s1, sab_s1); error++;
      }
  }
  {
    BITCODE_BL sab_status;
    if (dwg_dynapi_entity_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "sab_status", &sab_status, NULL) &&
        sab_status == assocplanesurfaceactionbody->sab_status)
      pass ("ASSOCPLANESURFACEACTIONBODY.sab_status [BL]");
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.sab_status [BL] %u != %u", assocplanesurfaceactionbody->sab_status, sab_status); error++;
      }
  }
  {
    BITCODE_H writedep;
    if (dwg_dynapi_entity_value(assocplanesurfaceactionbody, "ASSOCPLANESURFACEACTIONBODY", "writedep", &writedep, NULL) &&
        writedep == assocplanesurfaceactionbody->writedep)
      pass ("ASSOCPLANESURFACEACTIONBODY.writedep [H]");
    else
      {
        fail ("ASSOCPLANESURFACEACTIONBODY.writedep [H] %p != %p", assocplanesurfaceactionbody->writedep, writedep); error++;
      }
  }
  return error;
}
static int test_BLOCK_CONTROL (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_BLOCK_CONTROL *block_control = obj->tio.object->tio.BLOCK_CONTROL;
  {
    Dwg_Object_Ref* block_headers;
    if (dwg_dynapi_entity_value(block_control, "BLOCK_CONTROL", "block_headers", &block_headers, NULL)
        && !memcmp(&block_headers, &block_control->block_headers, sizeof(block_control->block_headers)))
      pass ("BLOCK_CONTROL.block_headers");
    else
      {
        fail ("BLOCK_CONTROL.block_headers"); error++;
      }
  }
  {
    BITCODE_H model_space;
    if (dwg_dynapi_entity_value(block_control, "BLOCK_CONTROL", "model_space", &model_space, NULL) &&
        model_space == block_control->model_space)
      pass ("BLOCK_CONTROL.model_space [H]");
    else
      {
        fail ("BLOCK_CONTROL.model_space [H] %p != %p", block_control->model_space, model_space); error++;
      }
  }
  {
    Dwg_Object_Ref* null_handle;
    if (dwg_dynapi_entity_value(block_control, "BLOCK_CONTROL", "null_handle", &null_handle, NULL)
        && !memcmp(&null_handle, &block_control->null_handle, sizeof(block_control->null_handle)))
      pass ("BLOCK_CONTROL.null_handle");
    else
      {
        fail ("BLOCK_CONTROL.null_handle"); error++;
      }
  }
  {
    BITCODE_BS num_entries;
    if (dwg_dynapi_entity_value(block_control, "BLOCK_CONTROL", "num_entries", &num_entries, NULL) &&
        num_entries == block_control->num_entries)
      pass ("BLOCK_CONTROL.num_entries [BS]");
    else
      {
        fail ("BLOCK_CONTROL.num_entries [BS] %d != %d", block_control->num_entries, num_entries); error++;
      }
  }
  {
    BITCODE_BL objid;
    if (dwg_dynapi_entity_value(block_control, "BLOCK_CONTROL", "objid", &objid, NULL) &&
        objid == block_control->objid)
      pass ("BLOCK_CONTROL.objid [BL]");
    else
      {
        fail ("BLOCK_CONTROL.objid [BL] %u != %u", block_control->objid, objid); error++;
      }
  }
  {
    BITCODE_H paper_space;
    if (dwg_dynapi_entity_value(block_control, "BLOCK_CONTROL", "paper_space", &paper_space, NULL) &&
        paper_space == block_control->paper_space)
      pass ("BLOCK_CONTROL.paper_space [H]");
    else
      {
        fail ("BLOCK_CONTROL.paper_space [H] %p != %p", block_control->paper_space, paper_space); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(block_control, "BLOCK_CONTROL", "parent", &parent, NULL)
        && !memcmp(&parent, &block_control->parent, sizeof(block_control->parent)))
      pass ("BLOCK_CONTROL.parent");
    else
      {
        fail ("BLOCK_CONTROL.parent"); error++;
      }
  }
  {
    Dwg_Object_Ref* reactors;
    if (dwg_dynapi_entity_value(block_control, "BLOCK_CONTROL", "reactors", &reactors, NULL)
        && !memcmp(&reactors, &block_control->reactors, sizeof(block_control->reactors)))
      pass ("BLOCK_CONTROL.reactors");
    else
      {
        fail ("BLOCK_CONTROL.reactors"); error++;
      }
  }
  {
    Dwg_Object_Ref* xdicobjhandle;
    if (dwg_dynapi_entity_value(block_control, "BLOCK_CONTROL", "xdicobjhandle", &xdicobjhandle, NULL)
        && !memcmp(&xdicobjhandle, &block_control->xdicobjhandle, sizeof(block_control->xdicobjhandle)))
      pass ("BLOCK_CONTROL.xdicobjhandle");
    else
      {
        fail ("BLOCK_CONTROL.xdicobjhandle"); error++;
      }
  }
  return error;
}
static int test_BLOCK_HEADER (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_BLOCK_HEADER *block_header = obj->tio.object->tio.BLOCK_HEADER;
  {
    BITCODE_BL __iterator;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "__iterator", &__iterator, NULL) &&
        __iterator == block_header->__iterator)
      pass ("BLOCK_HEADER.__iterator [BL]");
    else
      {
        fail ("BLOCK_HEADER.__iterator [BL] %u != %u", block_header->__iterator, __iterator); error++;
      }
  }
  {
    BITCODE_B anonymous;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "anonymous", &anonymous, NULL) &&
        anonymous == block_header->anonymous)
      pass ("BLOCK_HEADER.anonymous [B]");
    else
      {
        fail ("BLOCK_HEADER.anonymous [B] " FORMAT_B " != " FORMAT_B "", block_header->anonymous, anonymous); error++;
      }
  }
  {
    BITCODE_3DPOINT base_pt;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "base_pt", &base_pt, NULL)
        && !memcmp(&base_pt, &block_header->base_pt, sizeof(block_header->base_pt)))
      pass ("BLOCK_HEADER.base_pt");
    else
      {
        fail ("BLOCK_HEADER.base_pt"); error++;
      }
  }
  {
    BITCODE_B blkisxref;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "blkisxref", &blkisxref, NULL) &&
        blkisxref == block_header->blkisxref)
      pass ("BLOCK_HEADER.blkisxref [B]");
    else
      {
        fail ("BLOCK_HEADER.blkisxref [B] " FORMAT_B " != " FORMAT_B "", block_header->blkisxref, blkisxref); error++;
      }
  }
  {
    BITCODE_H block_control;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "block_control", &block_control, NULL) &&
        block_control == block_header->block_control)
      pass ("BLOCK_HEADER.block_control [H]");
    else
      {
        fail ("BLOCK_HEADER.block_control [H] %p != %p", block_header->block_control, block_control); error++;
      }
  }
  {
    BITCODE_H block_entity;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "block_entity", &block_entity, NULL) &&
        block_entity == block_header->block_entity)
      pass ("BLOCK_HEADER.block_entity [H]");
    else
      {
        fail ("BLOCK_HEADER.block_entity [H] %p != %p", block_header->block_entity, block_entity); error++;
      }
  }
  {
    BITCODE_RC block_scaling;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "block_scaling", &block_scaling, NULL) &&
        block_scaling == block_header->block_scaling)
      pass ("BLOCK_HEADER.block_scaling [RC]");
    else
      {
        fail ("BLOCK_HEADER.block_scaling [RC] %c != %c", block_header->block_scaling, block_scaling); error++;
      }
  }
  {
    BITCODE_TV description;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "description", &description, NULL)
        && !strcmp((char*)&description, (char*)&block_header->description))
      pass ("BLOCK_HEADER.description");
    else
      {
        fail ("BLOCK_HEADER.description"); error++;
      }
  }
  {
    BITCODE_H endblk_entity;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "endblk_entity", &endblk_entity, NULL) &&
        endblk_entity == block_header->endblk_entity)
      pass ("BLOCK_HEADER.endblk_entity [H]");
    else
      {
        fail ("BLOCK_HEADER.endblk_entity [H] %p != %p", block_header->endblk_entity, endblk_entity); error++;
      }
  }
  {
    BITCODE_H* entities;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "entities", &entities, NULL)
        && !memcmp(&entities, &block_header->entities, sizeof(block_header->entities)))
      pass ("BLOCK_HEADER.entities");
    else
      {
        fail ("BLOCK_HEADER.entities"); error++;
      }
  }
  {
    BITCODE_B explodable;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "explodable", &explodable, NULL) &&
        explodable == block_header->explodable)
      pass ("BLOCK_HEADER.explodable [B]");
    else
      {
        fail ("BLOCK_HEADER.explodable [B] " FORMAT_B " != " FORMAT_B "", block_header->explodable, explodable); error++;
      }
  }
  {
    BITCODE_H first_entity;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "first_entity", &first_entity, NULL) &&
        first_entity == block_header->first_entity)
      pass ("BLOCK_HEADER.first_entity [H]");
    else
      {
        fail ("BLOCK_HEADER.first_entity [H] %p != %p", block_header->first_entity, first_entity); error++;
      }
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "flag", &flag, NULL) &&
        flag == block_header->flag)
      pass ("BLOCK_HEADER.flag [RC]");
    else
      {
        fail ("BLOCK_HEADER.flag [RC] %c != %c", block_header->flag, flag); error++;
      }
  }
  {
    BITCODE_RC flag2;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "flag2", &flag2, NULL) &&
        flag2 == block_header->flag2)
      pass ("BLOCK_HEADER.flag2 [RC]");
    else
      {
        fail ("BLOCK_HEADER.flag2 [RC] %c != %c", block_header->flag2, flag2); error++;
      }
  }
  {
    BITCODE_RS flag3;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "flag3", &flag3, NULL) &&
        flag3 == block_header->flag3)
      pass ("BLOCK_HEADER.flag3 [RS]");
    else
      {
        fail ("BLOCK_HEADER.flag3 [RS] " FORMAT_RS " != " FORMAT_RS "", block_header->flag3, flag3); error++;
      }
  }
  {
    BITCODE_B hasattrs;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "hasattrs", &hasattrs, NULL) &&
        hasattrs == block_header->hasattrs)
      pass ("BLOCK_HEADER.hasattrs [B]");
    else
      {
        fail ("BLOCK_HEADER.hasattrs [B] " FORMAT_B " != " FORMAT_B "", block_header->hasattrs, hasattrs); error++;
      }
  }
  {
    BITCODE_H* insert_handles;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "insert_handles", &insert_handles, NULL)
        && !memcmp(&insert_handles, &block_header->insert_handles, sizeof(block_header->insert_handles)))
      pass ("BLOCK_HEADER.insert_handles");
    else
      {
        fail ("BLOCK_HEADER.insert_handles"); error++;
      }
  }
  {
    BITCODE_BS insert_units;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "insert_units", &insert_units, NULL) &&
        insert_units == block_header->insert_units)
      pass ("BLOCK_HEADER.insert_units [BS]");
    else
      {
        fail ("BLOCK_HEADER.insert_units [BS] %d != %d", block_header->insert_units, insert_units); error++;
      }
  }
  {
    BITCODE_H last_entity;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "last_entity", &last_entity, NULL) &&
        last_entity == block_header->last_entity)
      pass ("BLOCK_HEADER.last_entity [H]");
    else
      {
        fail ("BLOCK_HEADER.last_entity [H] %p != %p", block_header->last_entity, last_entity); error++;
      }
  }
  {
    BITCODE_H layout_handle;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "layout_handle", &layout_handle, NULL) &&
        layout_handle == block_header->layout_handle)
      pass ("BLOCK_HEADER.layout_handle [H]");
    else
      {
        fail ("BLOCK_HEADER.layout_handle [H] %p != %p", block_header->layout_handle, layout_handle); error++;
      }
  }
  {
    BITCODE_B loaded_bit;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "loaded_bit", &loaded_bit, NULL) &&
        loaded_bit == block_header->loaded_bit)
      pass ("BLOCK_HEADER.loaded_bit [B]");
    else
      {
        fail ("BLOCK_HEADER.loaded_bit [B] " FORMAT_B " != " FORMAT_B "", block_header->loaded_bit, loaded_bit); error++;
      }
  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "name", &name, NULL)
        && !strcmp((char*)&name, (char*)&block_header->name))
      pass ("BLOCK_HEADER.name");
    else
      {
        fail ("BLOCK_HEADER.name"); error++;
      }
  }
  {
    BITCODE_H null_handle;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "null_handle", &null_handle, NULL) &&
        null_handle == block_header->null_handle)
      pass ("BLOCK_HEADER.null_handle [H]");
    else
      {
        fail ("BLOCK_HEADER.null_handle [H] %p != %p", block_header->null_handle, null_handle); error++;
      }
  }
  {
    BITCODE_RL num_inserts;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "num_inserts", &num_inserts, NULL) &&
        num_inserts == block_header->num_inserts)
      pass ("BLOCK_HEADER.num_inserts [RL]");
    else
      {
        fail ("BLOCK_HEADER.num_inserts [RL] " FORMAT_RL " != " FORMAT_RL "", block_header->num_inserts, num_inserts); error++;
      }
  }
  {
    BITCODE_BL num_owned;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "num_owned", &num_owned, NULL) &&
        num_owned == block_header->num_owned)
      pass ("BLOCK_HEADER.num_owned [BL]");
    else
      {
        fail ("BLOCK_HEADER.num_owned [BL] %u != %u", block_header->num_owned, num_owned); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "parent", &parent, NULL)
        && !memcmp(&parent, &block_header->parent, sizeof(block_header->parent)))
      pass ("BLOCK_HEADER.parent");
    else
      {
        fail ("BLOCK_HEADER.parent"); error++;
      }
  }
  {
    BITCODE_TV preview_data;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "preview_data", &preview_data, NULL)
        && !strcmp((char*)&preview_data, (char*)&block_header->preview_data))
      pass ("BLOCK_HEADER.preview_data");
    else
      {
        fail ("BLOCK_HEADER.preview_data"); error++;
      }
  }
  {
    BITCODE_BL preview_data_size;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "preview_data_size", &preview_data_size, NULL) &&
        preview_data_size == block_header->preview_data_size)
      pass ("BLOCK_HEADER.preview_data_size [BL]");
    else
      {
        fail ("BLOCK_HEADER.preview_data_size [BL] %u != %u", block_header->preview_data_size, preview_data_size); error++;
      }
  }
  {
    BITCODE_RS used;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "used", &used, NULL) &&
        used == block_header->used)
      pass ("BLOCK_HEADER.used [RS]");
    else
      {
        fail ("BLOCK_HEADER.used [RS] " FORMAT_RS " != " FORMAT_RS "", block_header->used, used); error++;
      }
  }
  {
    BITCODE_TV xref_pname;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "xref_pname", &xref_pname, NULL)
        && !strcmp((char*)&xref_pname, (char*)&block_header->xref_pname))
      pass ("BLOCK_HEADER.xref_pname");
    else
      {
        fail ("BLOCK_HEADER.xref_pname"); error++;
      }
  }
  {
    BITCODE_B xrefdep;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "xrefdep", &xrefdep, NULL) &&
        xrefdep == block_header->xrefdep)
      pass ("BLOCK_HEADER.xrefdep [B]");
    else
      {
        fail ("BLOCK_HEADER.xrefdep [B] " FORMAT_B " != " FORMAT_B "", block_header->xrefdep, xrefdep); error++;
      }
  }
  {
    BITCODE_BS xrefindex_plus1;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "xrefindex_plus1", &xrefindex_plus1, NULL) &&
        xrefindex_plus1 == block_header->xrefindex_plus1)
      pass ("BLOCK_HEADER.xrefindex_plus1 [BS]");
    else
      {
        fail ("BLOCK_HEADER.xrefindex_plus1 [BS] %d != %d", block_header->xrefindex_plus1, xrefindex_plus1); error++;
      }
  }
  {
    BITCODE_B xrefoverlaid;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "xrefoverlaid", &xrefoverlaid, NULL) &&
        xrefoverlaid == block_header->xrefoverlaid)
      pass ("BLOCK_HEADER.xrefoverlaid [B]");
    else
      {
        fail ("BLOCK_HEADER.xrefoverlaid [B] " FORMAT_B " != " FORMAT_B "", block_header->xrefoverlaid, xrefoverlaid); error++;
      }
  }
  {
    BITCODE_B xrefref;
    if (dwg_dynapi_entity_value(block_header, "BLOCK_HEADER", "xrefref", &xrefref, NULL) &&
        xrefref == block_header->xrefref)
      pass ("BLOCK_HEADER.xrefref [B]");
    else
      {
        fail ("BLOCK_HEADER.xrefref [B] " FORMAT_B " != " FORMAT_B "", block_header->xrefref, xrefref); error++;
      }
  }
  return error;
}
static int test_CELLSTYLEMAP (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_CELLSTYLEMAP *cellstylemap = obj->tio.object->tio.CELLSTYLEMAP;
  {
    Dwg_CELLSTYLEMAP_Cell* cells;
    if (dwg_dynapi_entity_value(cellstylemap, "CELLSTYLEMAP", "cells", &cells, NULL)
        && !memcmp(&cells, &cellstylemap->cells, sizeof(cellstylemap->cells)))
      pass ("CELLSTYLEMAP.cells");
    else
      {
        fail ("CELLSTYLEMAP.cells"); error++;
      }
  }
  {
    BITCODE_BL num_cells;
    if (dwg_dynapi_entity_value(cellstylemap, "CELLSTYLEMAP", "num_cells", &num_cells, NULL) &&
        num_cells == cellstylemap->num_cells)
      pass ("CELLSTYLEMAP.num_cells [BL]");
    else
      {
        fail ("CELLSTYLEMAP.num_cells [BL] %u != %u", cellstylemap->num_cells, num_cells); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(cellstylemap, "CELLSTYLEMAP", "parent", &parent, NULL)
        && !memcmp(&parent, &cellstylemap->parent, sizeof(cellstylemap->parent)))
      pass ("CELLSTYLEMAP.parent");
    else
      {
        fail ("CELLSTYLEMAP.parent"); error++;
      }
  }
  return error;
}
static int test_DATATABLE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_DATATABLE *datatable = obj->tio.object->tio.DATATABLE;
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(datatable, "DATATABLE", "parent", &parent, NULL)
        && !memcmp(&parent, &datatable->parent, sizeof(datatable->parent)))
      pass ("DATATABLE.parent");
    else
      {
        fail ("DATATABLE.parent"); error++;
      }
  }
  return error;
}
static int test_DBCOLOR (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_DBCOLOR *dbcolor = obj->tio.object->tio.DBCOLOR;
  {
    BITCODE_T catalog;
    if (dwg_dynapi_entity_value(dbcolor, "DBCOLOR", "catalog", &catalog, NULL)
        && !memcmp(&catalog, &dbcolor->catalog, sizeof(dbcolor->catalog)))
      pass ("DBCOLOR.catalog");
    else
      {
        fail ("DBCOLOR.catalog"); error++;
      }
  }
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value(dbcolor, "DBCOLOR", "class_version", &class_version, NULL) &&
        class_version == dbcolor->class_version)
      pass ("DBCOLOR.class_version [BL]");
    else
      {
        fail ("DBCOLOR.class_version [BL] %u != %u", dbcolor->class_version, class_version); error++;
      }
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value(dbcolor, "DBCOLOR", "name", &name, NULL)
        && !memcmp(&name, &dbcolor->name, sizeof(dbcolor->name)))
      pass ("DBCOLOR.name");
    else
      {
        fail ("DBCOLOR.name"); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(dbcolor, "DBCOLOR", "ownerhandle", &ownerhandle, NULL) &&
        ownerhandle == dbcolor->ownerhandle)
      pass ("DBCOLOR.ownerhandle [H]");
    else
      {
        fail ("DBCOLOR.ownerhandle [H] %p != %p", dbcolor->ownerhandle, ownerhandle); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(dbcolor, "DBCOLOR", "parent", &parent, NULL)
        && !memcmp(&parent, &dbcolor->parent, sizeof(dbcolor->parent)))
      pass ("DBCOLOR.parent");
    else
      {
        fail ("DBCOLOR.parent"); error++;
      }
  }
  {
    BITCODE_RL rgb;
    if (dwg_dynapi_entity_value(dbcolor, "DBCOLOR", "rgb", &rgb, NULL) &&
        rgb == dbcolor->rgb)
      pass ("DBCOLOR.rgb [RL]");
    else
      {
        fail ("DBCOLOR.rgb [RL] " FORMAT_RL " != " FORMAT_RL "", dbcolor->rgb, rgb); error++;
      }
  }
  {
    BITCODE_BB unknown1;
    if (dwg_dynapi_entity_value(dbcolor, "DBCOLOR", "unknown1", &unknown1, NULL) &&
        unknown1 == dbcolor->unknown1)
      pass ("DBCOLOR.unknown1 [BB]");
    else
      {
        fail ("DBCOLOR.unknown1 [BB] " FORMAT_BB " != " FORMAT_BB "", dbcolor->unknown1, unknown1); error++;
      }
  }
  {
    BITCODE_RC unknown2;
    if (dwg_dynapi_entity_value(dbcolor, "DBCOLOR", "unknown2", &unknown2, NULL) &&
        unknown2 == dbcolor->unknown2)
      pass ("DBCOLOR.unknown2 [RC]");
    else
      {
        fail ("DBCOLOR.unknown2 [RC] %c != %c", dbcolor->unknown2, unknown2); error++;
      }
  }
  return error;
}
static int test_DICTIONARY (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_DICTIONARY *dictionary = obj->tio.object->tio.DICTIONARY;
  {
    BITCODE_BS cloning;
    if (dwg_dynapi_entity_value(dictionary, "DICTIONARY", "cloning", &cloning, NULL) &&
        cloning == dictionary->cloning)
      pass ("DICTIONARY.cloning [BS]");
    else
      {
        fail ("DICTIONARY.cloning [BS] %d != %d", dictionary->cloning, cloning); error++;
      }
  }
  {
    BITCODE_RC hard_owner;
    if (dwg_dynapi_entity_value(dictionary, "DICTIONARY", "hard_owner", &hard_owner, NULL) &&
        hard_owner == dictionary->hard_owner)
      pass ("DICTIONARY.hard_owner [RC]");
    else
      {
        fail ("DICTIONARY.hard_owner [RC] %c != %c", dictionary->hard_owner, hard_owner); error++;
      }
  }
  {
    BITCODE_H* itemhandles;
    if (dwg_dynapi_entity_value(dictionary, "DICTIONARY", "itemhandles", &itemhandles, NULL)
        && !memcmp(&itemhandles, &dictionary->itemhandles, sizeof(dictionary->itemhandles)))
      pass ("DICTIONARY.itemhandles");
    else
      {
        fail ("DICTIONARY.itemhandles"); error++;
      }
  }
  {
    BITCODE_BL numitems;
    if (dwg_dynapi_entity_value(dictionary, "DICTIONARY", "numitems", &numitems, NULL) &&
        numitems == dictionary->numitems)
      pass ("DICTIONARY.numitems [BL]");
    else
      {
        fail ("DICTIONARY.numitems [BL] %u != %u", dictionary->numitems, numitems); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(dictionary, "DICTIONARY", "ownerhandle", &ownerhandle, NULL) &&
        ownerhandle == dictionary->ownerhandle)
      pass ("DICTIONARY.ownerhandle [H]");
    else
      {
        fail ("DICTIONARY.ownerhandle [H] %p != %p", dictionary->ownerhandle, ownerhandle); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(dictionary, "DICTIONARY", "parent", &parent, NULL)
        && !memcmp(&parent, &dictionary->parent, sizeof(dictionary->parent)))
      pass ("DICTIONARY.parent");
    else
      {
        fail ("DICTIONARY.parent"); error++;
      }
  }
  {
    BITCODE_TV* text;
    if (dwg_dynapi_entity_value(dictionary, "DICTIONARY", "text", &text, NULL)
        && !memcmp(&text, &dictionary->text, sizeof(dictionary->text)))
      pass ("DICTIONARY.text");
    else
      {
        fail ("DICTIONARY.text"); error++;
      }
  }
  {
    BITCODE_RC unknown_r14;
    if (dwg_dynapi_entity_value(dictionary, "DICTIONARY", "unknown_r14", &unknown_r14, NULL) &&
        unknown_r14 == dictionary->unknown_r14)
      pass ("DICTIONARY.unknown_r14 [RC]");
    else
      {
        fail ("DICTIONARY.unknown_r14 [RC] %c != %c", dictionary->unknown_r14, unknown_r14); error++;
      }
  }
  return error;
}
static int test_DICTIONARYVAR (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_DICTIONARYVAR *dictionaryvar = obj->tio.object->tio.DICTIONARYVAR;
  {
    BITCODE_RC intval;
    if (dwg_dynapi_entity_value(dictionaryvar, "DICTIONARYVAR", "intval", &intval, NULL) &&
        intval == dictionaryvar->intval)
      pass ("DICTIONARYVAR.intval [RC]");
    else
      {
        fail ("DICTIONARYVAR.intval [RC] %c != %c", dictionaryvar->intval, intval); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(dictionaryvar, "DICTIONARYVAR", "ownerhandle", &ownerhandle, NULL) &&
        ownerhandle == dictionaryvar->ownerhandle)
      pass ("DICTIONARYVAR.ownerhandle [H]");
    else
      {
        fail ("DICTIONARYVAR.ownerhandle [H] %p != %p", dictionaryvar->ownerhandle, ownerhandle); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(dictionaryvar, "DICTIONARYVAR", "parent", &parent, NULL)
        && !memcmp(&parent, &dictionaryvar->parent, sizeof(dictionaryvar->parent)))
      pass ("DICTIONARYVAR.parent");
    else
      {
        fail ("DICTIONARYVAR.parent"); error++;
      }
  }
  {
    BITCODE_TV str;
    if (dwg_dynapi_entity_value(dictionaryvar, "DICTIONARYVAR", "str", &str, NULL)
        && !strcmp((char*)&str, (char*)&dictionaryvar->str))
      pass ("DICTIONARYVAR.str");
    else
      {
        fail ("DICTIONARYVAR.str"); error++;
      }
  }
  return error;
}
static int test_DICTIONARYWDFLT (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_DICTIONARYWDFLT *dictionarywdflt = obj->tio.object->tio.DICTIONARYWDFLT;
  {
    BITCODE_BS cloning;
    if (dwg_dynapi_entity_value(dictionarywdflt, "DICTIONARYWDFLT", "cloning", &cloning, NULL) &&
        cloning == dictionarywdflt->cloning)
      pass ("DICTIONARYWDFLT.cloning [BS]");
    else
      {
        fail ("DICTIONARYWDFLT.cloning [BS] %d != %d", dictionarywdflt->cloning, cloning); error++;
      }
  }
  {
    BITCODE_RL cloning_rl;
    if (dwg_dynapi_entity_value(dictionarywdflt, "DICTIONARYWDFLT", "cloning_rl", &cloning_rl, NULL) &&
        cloning_rl == dictionarywdflt->cloning_rl)
      pass ("DICTIONARYWDFLT.cloning_rl [RL]");
    else
      {
        fail ("DICTIONARYWDFLT.cloning_rl [RL] " FORMAT_RL " != " FORMAT_RL "", dictionarywdflt->cloning_rl, cloning_rl); error++;
      }
  }
  {
    BITCODE_H defaultid;
    if (dwg_dynapi_entity_value(dictionarywdflt, "DICTIONARYWDFLT", "defaultid", &defaultid, NULL) &&
        defaultid == dictionarywdflt->defaultid)
      pass ("DICTIONARYWDFLT.defaultid [H]");
    else
      {
        fail ("DICTIONARYWDFLT.defaultid [H] %p != %p", dictionarywdflt->defaultid, defaultid); error++;
      }
  }
  {
    BITCODE_RC hard_owner;
    if (dwg_dynapi_entity_value(dictionarywdflt, "DICTIONARYWDFLT", "hard_owner", &hard_owner, NULL) &&
        hard_owner == dictionarywdflt->hard_owner)
      pass ("DICTIONARYWDFLT.hard_owner [RC]");
    else
      {
        fail ("DICTIONARYWDFLT.hard_owner [RC] %c != %c", dictionarywdflt->hard_owner, hard_owner); error++;
      }
  }
  {
    BITCODE_H* itemhandles;
    if (dwg_dynapi_entity_value(dictionarywdflt, "DICTIONARYWDFLT", "itemhandles", &itemhandles, NULL)
        && !memcmp(&itemhandles, &dictionarywdflt->itemhandles, sizeof(dictionarywdflt->itemhandles)))
      pass ("DICTIONARYWDFLT.itemhandles");
    else
      {
        fail ("DICTIONARYWDFLT.itemhandles"); error++;
      }
  }
  {
    BITCODE_BL numitems;
    if (dwg_dynapi_entity_value(dictionarywdflt, "DICTIONARYWDFLT", "numitems", &numitems, NULL) &&
        numitems == dictionarywdflt->numitems)
      pass ("DICTIONARYWDFLT.numitems [BL]");
    else
      {
        fail ("DICTIONARYWDFLT.numitems [BL] %u != %u", dictionarywdflt->numitems, numitems); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(dictionarywdflt, "DICTIONARYWDFLT", "ownerhandle", &ownerhandle, NULL) &&
        ownerhandle == dictionarywdflt->ownerhandle)
      pass ("DICTIONARYWDFLT.ownerhandle [H]");
    else
      {
        fail ("DICTIONARYWDFLT.ownerhandle [H] %p != %p", dictionarywdflt->ownerhandle, ownerhandle); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(dictionarywdflt, "DICTIONARYWDFLT", "parent", &parent, NULL)
        && !memcmp(&parent, &dictionarywdflt->parent, sizeof(dictionarywdflt->parent)))
      pass ("DICTIONARYWDFLT.parent");
    else
      {
        fail ("DICTIONARYWDFLT.parent"); error++;
      }
  }
  {
    BITCODE_TV* text;
    if (dwg_dynapi_entity_value(dictionarywdflt, "DICTIONARYWDFLT", "text", &text, NULL)
        && !memcmp(&text, &dictionarywdflt->text, sizeof(dictionarywdflt->text)))
      pass ("DICTIONARYWDFLT.text");
    else
      {
        fail ("DICTIONARYWDFLT.text"); error++;
      }
  }
  return error;
}
static int test_DIMASSOC (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_DIMASSOC *dimassoc = obj->tio.object->tio.DIMASSOC;
  {
    BITCODE_BL associativity;
    if (dwg_dynapi_entity_value(dimassoc, "DIMASSOC", "associativity", &associativity, NULL) &&
        associativity == dimassoc->associativity)
      pass ("DIMASSOC.associativity [BL]");
    else
      {
        fail ("DIMASSOC.associativity [BL] %u != %u", dimassoc->associativity, associativity); error++;
      }
  }
  {
    BITCODE_H dimensionobj;
    if (dwg_dynapi_entity_value(dimassoc, "DIMASSOC", "dimensionobj", &dimensionobj, NULL) &&
        dimensionobj == dimassoc->dimensionobj)
      pass ("DIMASSOC.dimensionobj [H]");
    else
      {
        fail ("DIMASSOC.dimensionobj [H] %p != %p", dimassoc->dimensionobj, dimensionobj); error++;
      }
  }
  {
    BITCODE_BL intsect_gsmarker;
    if (dwg_dynapi_entity_value(dimassoc, "DIMASSOC", "intsect_gsmarker", &intsect_gsmarker, NULL) &&
        intsect_gsmarker == dimassoc->intsect_gsmarker)
      pass ("DIMASSOC.intsect_gsmarker [BL]");
    else
      {
        fail ("DIMASSOC.intsect_gsmarker [BL] %u != %u", dimassoc->intsect_gsmarker, intsect_gsmarker); error++;
      }
  }
  {
    BITCODE_H intsectobj;
    if (dwg_dynapi_entity_value(dimassoc, "DIMASSOC", "intsectobj", &intsectobj, NULL) &&
        intsectobj == dimassoc->intsectobj)
      pass ("DIMASSOC.intsectobj [H]");
    else
      {
        fail ("DIMASSOC.intsectobj [H] %p != %p", dimassoc->intsectobj, intsectobj); error++;
      }
  }
  {
    BITCODE_H intsectxrefobj;
    if (dwg_dynapi_entity_value(dimassoc, "DIMASSOC", "intsectxrefobj", &intsectxrefobj, NULL) &&
        intsectxrefobj == dimassoc->intsectxrefobj)
      pass ("DIMASSOC.intsectxrefobj [H]");
    else
      {
        fail ("DIMASSOC.intsectxrefobj [H] %p != %p", dimassoc->intsectxrefobj, intsectxrefobj); error++;
      }
  }
  {
    BITCODE_H mainobj;
    if (dwg_dynapi_entity_value(dimassoc, "DIMASSOC", "mainobj", &mainobj, NULL) &&
        mainobj == dimassoc->mainobj)
      pass ("DIMASSOC.mainobj [H]");
    else
      {
        fail ("DIMASSOC.mainobj [H] %p != %p", dimassoc->mainobj, mainobj); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(dimassoc, "DIMASSOC", "ownerhandle", &ownerhandle, NULL) &&
        ownerhandle == dimassoc->ownerhandle)
      pass ("DIMASSOC.ownerhandle [H]");
    else
      {
        fail ("DIMASSOC.ownerhandle [H] %p != %p", dimassoc->ownerhandle, ownerhandle); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(dimassoc, "DIMASSOC", "parent", &parent, NULL)
        && !memcmp(&parent, &dimassoc->parent, sizeof(dimassoc->parent)))
      pass ("DIMASSOC.parent");
    else
      {
        fail ("DIMASSOC.parent"); error++;
      }
  }
  {
    Dwg_DIMASSOC_Ref* ref;
    if (dwg_dynapi_entity_value(dimassoc, "DIMASSOC", "ref", &ref, NULL)
        && !memcmp(&ref, &dimassoc->ref, sizeof(dimassoc->ref)))
      pass ("DIMASSOC.ref");
    else
      {
        fail ("DIMASSOC.ref"); error++;
      }
  }
  {
    BITCODE_RC trans_space_flag;
    if (dwg_dynapi_entity_value(dimassoc, "DIMASSOC", "trans_space_flag", &trans_space_flag, NULL) &&
        trans_space_flag == dimassoc->trans_space_flag)
      pass ("DIMASSOC.trans_space_flag [RC]");
    else
      {
        fail ("DIMASSOC.trans_space_flag [RC] %c != %c", dimassoc->trans_space_flag, trans_space_flag); error++;
      }
  }
  {
    BITCODE_H xrefobj;
    if (dwg_dynapi_entity_value(dimassoc, "DIMASSOC", "xrefobj", &xrefobj, NULL) &&
        xrefobj == dimassoc->xrefobj)
      pass ("DIMASSOC.xrefobj [H]");
    else
      {
        fail ("DIMASSOC.xrefobj [H] %p != %p", dimassoc->xrefobj, xrefobj); error++;
      }
  }
  return error;
}
static int test_DIMSTYLE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_DIMSTYLE *dimstyle = obj->tio.object->tio.DIMSTYLE;
  {
    BITCODE_BS DIMADEC;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMADEC", &DIMADEC, NULL) &&
        DIMADEC == dimstyle->DIMADEC)
      pass ("DIMSTYLE.DIMADEC [BS]");
    else
      {
        fail ("DIMSTYLE.DIMADEC [BS] %d != %d", dimstyle->DIMADEC, DIMADEC); error++;
      }
  }
  {
    BITCODE_B DIMALT;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMALT", &DIMALT, NULL) &&
        DIMALT == dimstyle->DIMALT)
      pass ("DIMSTYLE.DIMALT [B]");
    else
      {
        fail ("DIMSTYLE.DIMALT [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMALT, DIMALT); error++;
      }
  }
  {
    BITCODE_BS DIMALTD;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMALTD", &DIMALTD, NULL) &&
        DIMALTD == dimstyle->DIMALTD)
      pass ("DIMSTYLE.DIMALTD [BS]");
    else
      {
        fail ("DIMSTYLE.DIMALTD [BS] %d != %d", dimstyle->DIMALTD, DIMALTD); error++;
      }
  }
  {
    BITCODE_BD DIMALTF;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMALTF", &DIMALTF, NULL) &&
        DIMALTF == dimstyle->DIMALTF)
      pass ("DIMSTYLE.DIMALTF [BD]");
    else
      {
        fail ("DIMSTYLE.DIMALTF [BD] %g != %g", dimstyle->DIMALTF, DIMALTF); error++;
      }
  }
  {
    BITCODE_BD DIMALTMZF;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMALTMZF", &DIMALTMZF, NULL) &&
        DIMALTMZF == dimstyle->DIMALTMZF)
      pass ("DIMSTYLE.DIMALTMZF [BD]");
    else
      {
        fail ("DIMSTYLE.DIMALTMZF [BD] %g != %g", dimstyle->DIMALTMZF, DIMALTMZF); error++;
      }
  }
  {
    BITCODE_T DIMALTMZS;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMALTMZS", &DIMALTMZS, NULL)
        && !memcmp(&DIMALTMZS, &dimstyle->DIMALTMZS, sizeof(dimstyle->DIMALTMZS)))
      pass ("DIMSTYLE.DIMALTMZS");
    else
      {
        fail ("DIMSTYLE.DIMALTMZS"); error++;
      }
  }
  {
    BITCODE_BD DIMALTRND;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMALTRND", &DIMALTRND, NULL) &&
        DIMALTRND == dimstyle->DIMALTRND)
      pass ("DIMSTYLE.DIMALTRND [BD]");
    else
      {
        fail ("DIMSTYLE.DIMALTRND [BD] %g != %g", dimstyle->DIMALTRND, DIMALTRND); error++;
      }
  }
  {
    BITCODE_BS DIMALTTD;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMALTTD", &DIMALTTD, NULL) &&
        DIMALTTD == dimstyle->DIMALTTD)
      pass ("DIMSTYLE.DIMALTTD [BS]");
    else
      {
        fail ("DIMSTYLE.DIMALTTD [BS] %d != %d", dimstyle->DIMALTTD, DIMALTTD); error++;
      }
  }
  {
    BITCODE_BS DIMALTTZ;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMALTTZ", &DIMALTTZ, NULL) &&
        DIMALTTZ == dimstyle->DIMALTTZ)
      pass ("DIMSTYLE.DIMALTTZ [BS]");
    else
      {
        fail ("DIMSTYLE.DIMALTTZ [BS] %d != %d", dimstyle->DIMALTTZ, DIMALTTZ); error++;
      }
  }
  {
    BITCODE_BS DIMALTU;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMALTU", &DIMALTU, NULL) &&
        DIMALTU == dimstyle->DIMALTU)
      pass ("DIMSTYLE.DIMALTU [BS]");
    else
      {
        fail ("DIMSTYLE.DIMALTU [BS] %d != %d", dimstyle->DIMALTU, DIMALTU); error++;
      }
  }
  {
    BITCODE_BS DIMALTZ;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMALTZ", &DIMALTZ, NULL) &&
        DIMALTZ == dimstyle->DIMALTZ)
      pass ("DIMSTYLE.DIMALTZ [BS]");
    else
      {
        fail ("DIMSTYLE.DIMALTZ [BS] %d != %d", dimstyle->DIMALTZ, DIMALTZ); error++;
      }
  }
  {
    BITCODE_T DIMAPOST;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMAPOST", &DIMAPOST, NULL)
        && !memcmp(&DIMAPOST, &dimstyle->DIMAPOST, sizeof(dimstyle->DIMAPOST)))
      pass ("DIMSTYLE.DIMAPOST");
    else
      {
        fail ("DIMSTYLE.DIMAPOST"); error++;
      }
  }
  {
    BITCODE_BS DIMARCSYM;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMARCSYM", &DIMARCSYM, NULL) &&
        DIMARCSYM == dimstyle->DIMARCSYM)
      pass ("DIMSTYLE.DIMARCSYM [BS]");
    else
      {
        fail ("DIMSTYLE.DIMARCSYM [BS] %d != %d", dimstyle->DIMARCSYM, DIMARCSYM); error++;
      }
  }
  {
    BITCODE_BD DIMASZ;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMASZ", &DIMASZ, NULL) &&
        DIMASZ == dimstyle->DIMASZ)
      pass ("DIMSTYLE.DIMASZ [BD]");
    else
      {
        fail ("DIMSTYLE.DIMASZ [BD] %g != %g", dimstyle->DIMASZ, DIMASZ); error++;
      }
  }
  {
    BITCODE_BS DIMATFIT;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMATFIT", &DIMATFIT, NULL) &&
        DIMATFIT == dimstyle->DIMATFIT)
      pass ("DIMSTYLE.DIMATFIT [BS]");
    else
      {
        fail ("DIMSTYLE.DIMATFIT [BS] %d != %d", dimstyle->DIMATFIT, DIMATFIT); error++;
      }
  }
  {
    BITCODE_BS DIMAUNIT;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMAUNIT", &DIMAUNIT, NULL) &&
        DIMAUNIT == dimstyle->DIMAUNIT)
      pass ("DIMSTYLE.DIMAUNIT [BS]");
    else
      {
        fail ("DIMSTYLE.DIMAUNIT [BS] %d != %d", dimstyle->DIMAUNIT, DIMAUNIT); error++;
      }
  }
  {
    BITCODE_BS DIMAZIN;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMAZIN", &DIMAZIN, NULL) &&
        DIMAZIN == dimstyle->DIMAZIN)
      pass ("DIMSTYLE.DIMAZIN [BS]");
    else
      {
        fail ("DIMSTYLE.DIMAZIN [BS] %d != %d", dimstyle->DIMAZIN, DIMAZIN); error++;
      }
  }
  {
    BITCODE_H DIMBLK;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMBLK", &DIMBLK, NULL) &&
        DIMBLK == dimstyle->DIMBLK)
      pass ("DIMSTYLE.DIMBLK [H]");
    else
      {
        fail ("DIMSTYLE.DIMBLK [H] %p != %p", dimstyle->DIMBLK, DIMBLK); error++;
      }
  }
  {
    BITCODE_H DIMBLK1;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMBLK1", &DIMBLK1, NULL) &&
        DIMBLK1 == dimstyle->DIMBLK1)
      pass ("DIMSTYLE.DIMBLK1 [H]");
    else
      {
        fail ("DIMSTYLE.DIMBLK1 [H] %p != %p", dimstyle->DIMBLK1, DIMBLK1); error++;
      }
  }
  {
    BITCODE_T DIMBLK1_T;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMBLK1_T", &DIMBLK1_T, NULL)
        && !memcmp(&DIMBLK1_T, &dimstyle->DIMBLK1_T, sizeof(dimstyle->DIMBLK1_T)))
      pass ("DIMSTYLE.DIMBLK1_T");
    else
      {
        fail ("DIMSTYLE.DIMBLK1_T"); error++;
      }
  }
  {
    BITCODE_H DIMBLK2;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMBLK2", &DIMBLK2, NULL) &&
        DIMBLK2 == dimstyle->DIMBLK2)
      pass ("DIMSTYLE.DIMBLK2 [H]");
    else
      {
        fail ("DIMSTYLE.DIMBLK2 [H] %p != %p", dimstyle->DIMBLK2, DIMBLK2); error++;
      }
  }
  {
    BITCODE_T DIMBLK2_T;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMBLK2_T", &DIMBLK2_T, NULL)
        && !memcmp(&DIMBLK2_T, &dimstyle->DIMBLK2_T, sizeof(dimstyle->DIMBLK2_T)))
      pass ("DIMSTYLE.DIMBLK2_T");
    else
      {
        fail ("DIMSTYLE.DIMBLK2_T"); error++;
      }
  }
  {
    BITCODE_T DIMBLK_T;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMBLK_T", &DIMBLK_T, NULL)
        && !memcmp(&DIMBLK_T, &dimstyle->DIMBLK_T, sizeof(dimstyle->DIMBLK_T)))
      pass ("DIMSTYLE.DIMBLK_T");
    else
      {
        fail ("DIMSTYLE.DIMBLK_T"); error++;
      }
  }
  {
    BITCODE_BD DIMCEN;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMCEN", &DIMCEN, NULL) &&
        DIMCEN == dimstyle->DIMCEN)
      pass ("DIMSTYLE.DIMCEN [BD]");
    else
      {
        fail ("DIMSTYLE.DIMCEN [BD] %g != %g", dimstyle->DIMCEN, DIMCEN); error++;
      }
  }
  {
    BITCODE_CMC DIMCLRD;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMCLRD", &DIMCLRD, NULL)
        && !memcmp(&DIMCLRD, &dimstyle->DIMCLRD, sizeof(dimstyle->DIMCLRD)))
      pass ("DIMSTYLE.DIMCLRD");
    else
      {
        fail ("DIMSTYLE.DIMCLRD"); error++;
      }
  }
  {
    BITCODE_RS DIMCLRD_N;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMCLRD_N", &DIMCLRD_N, NULL) &&
        DIMCLRD_N == dimstyle->DIMCLRD_N)
      pass ("DIMSTYLE.DIMCLRD_N [RS]");
    else
      {
        fail ("DIMSTYLE.DIMCLRD_N [RS] " FORMAT_RS " != " FORMAT_RS "", dimstyle->DIMCLRD_N, DIMCLRD_N); error++;
      }
  }
  {
    BITCODE_CMC DIMCLRE;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMCLRE", &DIMCLRE, NULL)
        && !memcmp(&DIMCLRE, &dimstyle->DIMCLRE, sizeof(dimstyle->DIMCLRE)))
      pass ("DIMSTYLE.DIMCLRE");
    else
      {
        fail ("DIMSTYLE.DIMCLRE"); error++;
      }
  }
  {
    BITCODE_RS DIMCLRE_N;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMCLRE_N", &DIMCLRE_N, NULL) &&
        DIMCLRE_N == dimstyle->DIMCLRE_N)
      pass ("DIMSTYLE.DIMCLRE_N [RS]");
    else
      {
        fail ("DIMSTYLE.DIMCLRE_N [RS] " FORMAT_RS " != " FORMAT_RS "", dimstyle->DIMCLRE_N, DIMCLRE_N); error++;
      }
  }
  {
    BITCODE_CMC DIMCLRT;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMCLRT", &DIMCLRT, NULL)
        && !memcmp(&DIMCLRT, &dimstyle->DIMCLRT, sizeof(dimstyle->DIMCLRT)))
      pass ("DIMSTYLE.DIMCLRT");
    else
      {
        fail ("DIMSTYLE.DIMCLRT"); error++;
      }
  }
  {
    BITCODE_RS DIMCLRT_N;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMCLRT_N", &DIMCLRT_N, NULL) &&
        DIMCLRT_N == dimstyle->DIMCLRT_N)
      pass ("DIMSTYLE.DIMCLRT_N [RS]");
    else
      {
        fail ("DIMSTYLE.DIMCLRT_N [RS] " FORMAT_RS " != " FORMAT_RS "", dimstyle->DIMCLRT_N, DIMCLRT_N); error++;
      }
  }
  {
    BITCODE_BS DIMDEC;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMDEC", &DIMDEC, NULL) &&
        DIMDEC == dimstyle->DIMDEC)
      pass ("DIMSTYLE.DIMDEC [BS]");
    else
      {
        fail ("DIMSTYLE.DIMDEC [BS] %d != %d", dimstyle->DIMDEC, DIMDEC); error++;
      }
  }
  {
    BITCODE_BD DIMDLE;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMDLE", &DIMDLE, NULL) &&
        DIMDLE == dimstyle->DIMDLE)
      pass ("DIMSTYLE.DIMDLE [BD]");
    else
      {
        fail ("DIMSTYLE.DIMDLE [BD] %g != %g", dimstyle->DIMDLE, DIMDLE); error++;
      }
  }
  {
    BITCODE_BD DIMDLI;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMDLI", &DIMDLI, NULL) &&
        DIMDLI == dimstyle->DIMDLI)
      pass ("DIMSTYLE.DIMDLI [BD]");
    else
      {
        fail ("DIMSTYLE.DIMDLI [BD] %g != %g", dimstyle->DIMDLI, DIMDLI); error++;
      }
  }
  {
    BITCODE_BS DIMDSEP;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMDSEP", &DIMDSEP, NULL) &&
        DIMDSEP == dimstyle->DIMDSEP)
      pass ("DIMSTYLE.DIMDSEP [BS]");
    else
      {
        fail ("DIMSTYLE.DIMDSEP [BS] %d != %d", dimstyle->DIMDSEP, DIMDSEP); error++;
      }
  }
  {
    BITCODE_BD DIMEXE;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMEXE", &DIMEXE, NULL) &&
        DIMEXE == dimstyle->DIMEXE)
      pass ("DIMSTYLE.DIMEXE [BD]");
    else
      {
        fail ("DIMSTYLE.DIMEXE [BD] %g != %g", dimstyle->DIMEXE, DIMEXE); error++;
      }
  }
  {
    BITCODE_BD DIMEXO;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMEXO", &DIMEXO, NULL) &&
        DIMEXO == dimstyle->DIMEXO)
      pass ("DIMSTYLE.DIMEXO [BD]");
    else
      {
        fail ("DIMSTYLE.DIMEXO [BD] %g != %g", dimstyle->DIMEXO, DIMEXO); error++;
      }
  }
  {
    BITCODE_BS DIMFIT;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMFIT", &DIMFIT, NULL) &&
        DIMFIT == dimstyle->DIMFIT)
      pass ("DIMSTYLE.DIMFIT [BS]");
    else
      {
        fail ("DIMSTYLE.DIMFIT [BS] %d != %d", dimstyle->DIMFIT, DIMFIT); error++;
      }
  }
  {
    BITCODE_BS DIMFRAC;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMFRAC", &DIMFRAC, NULL) &&
        DIMFRAC == dimstyle->DIMFRAC)
      pass ("DIMSTYLE.DIMFRAC [BS]");
    else
      {
        fail ("DIMSTYLE.DIMFRAC [BS] %d != %d", dimstyle->DIMFRAC, DIMFRAC); error++;
      }
  }
  {
    BITCODE_BD DIMFXL;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMFXL", &DIMFXL, NULL) &&
        DIMFXL == dimstyle->DIMFXL)
      pass ("DIMSTYLE.DIMFXL [BD]");
    else
      {
        fail ("DIMSTYLE.DIMFXL [BD] %g != %g", dimstyle->DIMFXL, DIMFXL); error++;
      }
  }
  {
    BITCODE_B DIMFXLON;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMFXLON", &DIMFXLON, NULL) &&
        DIMFXLON == dimstyle->DIMFXLON)
      pass ("DIMSTYLE.DIMFXLON [B]");
    else
      {
        fail ("DIMSTYLE.DIMFXLON [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMFXLON, DIMFXLON); error++;
      }
  }
  {
    BITCODE_BD DIMGAP;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMGAP", &DIMGAP, NULL) &&
        DIMGAP == dimstyle->DIMGAP)
      pass ("DIMSTYLE.DIMGAP [BD]");
    else
      {
        fail ("DIMSTYLE.DIMGAP [BD] %g != %g", dimstyle->DIMGAP, DIMGAP); error++;
      }
  }
  {
    BITCODE_BD DIMJOGANG;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMJOGANG", &DIMJOGANG, NULL) &&
        DIMJOGANG == dimstyle->DIMJOGANG)
      pass ("DIMSTYLE.DIMJOGANG [BD]");
    else
      {
        fail ("DIMSTYLE.DIMJOGANG [BD] %g != %g", dimstyle->DIMJOGANG, DIMJOGANG); error++;
      }
  }
  {
    BITCODE_BS DIMJUST;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMJUST", &DIMJUST, NULL) &&
        DIMJUST == dimstyle->DIMJUST)
      pass ("DIMSTYLE.DIMJUST [BS]");
    else
      {
        fail ("DIMSTYLE.DIMJUST [BS] %d != %d", dimstyle->DIMJUST, DIMJUST); error++;
      }
  }
  {
    BITCODE_H DIMLDRBLK;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMLDRBLK", &DIMLDRBLK, NULL) &&
        DIMLDRBLK == dimstyle->DIMLDRBLK)
      pass ("DIMSTYLE.DIMLDRBLK [H]");
    else
      {
        fail ("DIMSTYLE.DIMLDRBLK [H] %p != %p", dimstyle->DIMLDRBLK, DIMLDRBLK); error++;
      }
  }
  {
    BITCODE_BD DIMLFAC;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMLFAC", &DIMLFAC, NULL) &&
        DIMLFAC == dimstyle->DIMLFAC)
      pass ("DIMSTYLE.DIMLFAC [BD]");
    else
      {
        fail ("DIMSTYLE.DIMLFAC [BD] %g != %g", dimstyle->DIMLFAC, DIMLFAC); error++;
      }
  }
  {
    BITCODE_B DIMLIM;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMLIM", &DIMLIM, NULL) &&
        DIMLIM == dimstyle->DIMLIM)
      pass ("DIMSTYLE.DIMLIM [B]");
    else
      {
        fail ("DIMSTYLE.DIMLIM [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMLIM, DIMLIM); error++;
      }
  }
  {
    BITCODE_H DIMLTEX1;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMLTEX1", &DIMLTEX1, NULL) &&
        DIMLTEX1 == dimstyle->DIMLTEX1)
      pass ("DIMSTYLE.DIMLTEX1 [H]");
    else
      {
        fail ("DIMSTYLE.DIMLTEX1 [H] %p != %p", dimstyle->DIMLTEX1, DIMLTEX1); error++;
      }
  }
  {
    BITCODE_H DIMLTEX2;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMLTEX2", &DIMLTEX2, NULL) &&
        DIMLTEX2 == dimstyle->DIMLTEX2)
      pass ("DIMSTYLE.DIMLTEX2 [H]");
    else
      {
        fail ("DIMSTYLE.DIMLTEX2 [H] %p != %p", dimstyle->DIMLTEX2, DIMLTEX2); error++;
      }
  }
  {
    BITCODE_H DIMLTYPE;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMLTYPE", &DIMLTYPE, NULL) &&
        DIMLTYPE == dimstyle->DIMLTYPE)
      pass ("DIMSTYLE.DIMLTYPE [H]");
    else
      {
        fail ("DIMSTYLE.DIMLTYPE [H] %p != %p", dimstyle->DIMLTYPE, DIMLTYPE); error++;
      }
  }
  {
    BITCODE_BS DIMLUNIT;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMLUNIT", &DIMLUNIT, NULL) &&
        DIMLUNIT == dimstyle->DIMLUNIT)
      pass ("DIMSTYLE.DIMLUNIT [BS]");
    else
      {
        fail ("DIMSTYLE.DIMLUNIT [BS] %d != %d", dimstyle->DIMLUNIT, DIMLUNIT); error++;
      }
  }
  {
    BITCODE_BS DIMLWD;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMLWD", &DIMLWD, NULL) &&
        DIMLWD == dimstyle->DIMLWD)
      pass ("DIMSTYLE.DIMLWD [BS]");
    else
      {
        fail ("DIMSTYLE.DIMLWD [BS] %d != %d", dimstyle->DIMLWD, DIMLWD); error++;
      }
  }
  {
    BITCODE_BS DIMLWE;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMLWE", &DIMLWE, NULL) &&
        DIMLWE == dimstyle->DIMLWE)
      pass ("DIMSTYLE.DIMLWE [BS]");
    else
      {
        fail ("DIMSTYLE.DIMLWE [BS] %d != %d", dimstyle->DIMLWE, DIMLWE); error++;
      }
  }
  {
    BITCODE_BS DIMMALTTZ;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMMALTTZ", &DIMMALTTZ, NULL) &&
        DIMMALTTZ == dimstyle->DIMMALTTZ)
      pass ("DIMSTYLE.DIMMALTTZ [BS]");
    else
      {
        fail ("DIMSTYLE.DIMMALTTZ [BS] %d != %d", dimstyle->DIMMALTTZ, DIMMALTTZ); error++;
      }
  }
  {
    BITCODE_BS DIMMALTZ;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMMALTZ", &DIMMALTZ, NULL) &&
        DIMMALTZ == dimstyle->DIMMALTZ)
      pass ("DIMSTYLE.DIMMALTZ [BS]");
    else
      {
        fail ("DIMSTYLE.DIMMALTZ [BS] %d != %d", dimstyle->DIMMALTZ, DIMMALTZ); error++;
      }
  }
  {
    BITCODE_BD DIMMZF;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMMZF", &DIMMZF, NULL) &&
        DIMMZF == dimstyle->DIMMZF)
      pass ("DIMSTYLE.DIMMZF [BD]");
    else
      {
        fail ("DIMSTYLE.DIMMZF [BD] %g != %g", dimstyle->DIMMZF, DIMMZF); error++;
      }
  }
  {
    BITCODE_T DIMMZS;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMMZS", &DIMMZS, NULL)
        && !memcmp(&DIMMZS, &dimstyle->DIMMZS, sizeof(dimstyle->DIMMZS)))
      pass ("DIMSTYLE.DIMMZS");
    else
      {
        fail ("DIMSTYLE.DIMMZS"); error++;
      }
  }
  {
    BITCODE_T DIMPOST;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMPOST", &DIMPOST, NULL)
        && !memcmp(&DIMPOST, &dimstyle->DIMPOST, sizeof(dimstyle->DIMPOST)))
      pass ("DIMSTYLE.DIMPOST");
    else
      {
        fail ("DIMSTYLE.DIMPOST"); error++;
      }
  }
  {
    BITCODE_BD DIMRND;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMRND", &DIMRND, NULL) &&
        DIMRND == dimstyle->DIMRND)
      pass ("DIMSTYLE.DIMRND [BD]");
    else
      {
        fail ("DIMSTYLE.DIMRND [BD] %g != %g", dimstyle->DIMRND, DIMRND); error++;
      }
  }
  {
    BITCODE_B DIMSAH;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMSAH", &DIMSAH, NULL) &&
        DIMSAH == dimstyle->DIMSAH)
      pass ("DIMSTYLE.DIMSAH [B]");
    else
      {
        fail ("DIMSTYLE.DIMSAH [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMSAH, DIMSAH); error++;
      }
  }
  {
    BITCODE_BD DIMSCALE;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMSCALE", &DIMSCALE, NULL) &&
        DIMSCALE == dimstyle->DIMSCALE)
      pass ("DIMSTYLE.DIMSCALE [BD]");
    else
      {
        fail ("DIMSTYLE.DIMSCALE [BD] %g != %g", dimstyle->DIMSCALE, DIMSCALE); error++;
      }
  }
  {
    BITCODE_B DIMSD1;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMSD1", &DIMSD1, NULL) &&
        DIMSD1 == dimstyle->DIMSD1)
      pass ("DIMSTYLE.DIMSD1 [B]");
    else
      {
        fail ("DIMSTYLE.DIMSD1 [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMSD1, DIMSD1); error++;
      }
  }
  {
    BITCODE_B DIMSD2;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMSD2", &DIMSD2, NULL) &&
        DIMSD2 == dimstyle->DIMSD2)
      pass ("DIMSTYLE.DIMSD2 [B]");
    else
      {
        fail ("DIMSTYLE.DIMSD2 [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMSD2, DIMSD2); error++;
      }
  }
  {
    BITCODE_B DIMSE1;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMSE1", &DIMSE1, NULL) &&
        DIMSE1 == dimstyle->DIMSE1)
      pass ("DIMSTYLE.DIMSE1 [B]");
    else
      {
        fail ("DIMSTYLE.DIMSE1 [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMSE1, DIMSE1); error++;
      }
  }
  {
    BITCODE_B DIMSE2;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMSE2", &DIMSE2, NULL) &&
        DIMSE2 == dimstyle->DIMSE2)
      pass ("DIMSTYLE.DIMSE2 [B]");
    else
      {
        fail ("DIMSTYLE.DIMSE2 [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMSE2, DIMSE2); error++;
      }
  }
  {
    BITCODE_B DIMSOXD;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMSOXD", &DIMSOXD, NULL) &&
        DIMSOXD == dimstyle->DIMSOXD)
      pass ("DIMSTYLE.DIMSOXD [B]");
    else
      {
        fail ("DIMSTYLE.DIMSOXD [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMSOXD, DIMSOXD); error++;
      }
  }
  {
    BITCODE_BS DIMTAD;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMTAD", &DIMTAD, NULL) &&
        DIMTAD == dimstyle->DIMTAD)
      pass ("DIMSTYLE.DIMTAD [BS]");
    else
      {
        fail ("DIMSTYLE.DIMTAD [BS] %d != %d", dimstyle->DIMTAD, DIMTAD); error++;
      }
  }
  {
    BITCODE_BS DIMTDEC;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMTDEC", &DIMTDEC, NULL) &&
        DIMTDEC == dimstyle->DIMTDEC)
      pass ("DIMSTYLE.DIMTDEC [BS]");
    else
      {
        fail ("DIMSTYLE.DIMTDEC [BS] %d != %d", dimstyle->DIMTDEC, DIMTDEC); error++;
      }
  }
  {
    BITCODE_BD DIMTFAC;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMTFAC", &DIMTFAC, NULL) &&
        DIMTFAC == dimstyle->DIMTFAC)
      pass ("DIMSTYLE.DIMTFAC [BD]");
    else
      {
        fail ("DIMSTYLE.DIMTFAC [BD] %g != %g", dimstyle->DIMTFAC, DIMTFAC); error++;
      }
  }
  {
    BITCODE_BS DIMTFILL;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMTFILL", &DIMTFILL, NULL) &&
        DIMTFILL == dimstyle->DIMTFILL)
      pass ("DIMSTYLE.DIMTFILL [BS]");
    else
      {
        fail ("DIMSTYLE.DIMTFILL [BS] %d != %d", dimstyle->DIMTFILL, DIMTFILL); error++;
      }
  }
  {
    BITCODE_CMC DIMTFILLCLR;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMTFILLCLR", &DIMTFILLCLR, NULL)
        && !memcmp(&DIMTFILLCLR, &dimstyle->DIMTFILLCLR, sizeof(dimstyle->DIMTFILLCLR)))
      pass ("DIMSTYLE.DIMTFILLCLR");
    else
      {
        fail ("DIMSTYLE.DIMTFILLCLR"); error++;
      }
  }
  {
    BITCODE_B DIMTIH;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMTIH", &DIMTIH, NULL) &&
        DIMTIH == dimstyle->DIMTIH)
      pass ("DIMSTYLE.DIMTIH [B]");
    else
      {
        fail ("DIMSTYLE.DIMTIH [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMTIH, DIMTIH); error++;
      }
  }
  {
    BITCODE_B DIMTIX;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMTIX", &DIMTIX, NULL) &&
        DIMTIX == dimstyle->DIMTIX)
      pass ("DIMSTYLE.DIMTIX [B]");
    else
      {
        fail ("DIMSTYLE.DIMTIX [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMTIX, DIMTIX); error++;
      }
  }
  {
    BITCODE_BD DIMTM;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMTM", &DIMTM, NULL) &&
        DIMTM == dimstyle->DIMTM)
      pass ("DIMSTYLE.DIMTM [BD]");
    else
      {
        fail ("DIMSTYLE.DIMTM [BD] %g != %g", dimstyle->DIMTM, DIMTM); error++;
      }
  }
  {
    BITCODE_BS DIMTMOVE;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMTMOVE", &DIMTMOVE, NULL) &&
        DIMTMOVE == dimstyle->DIMTMOVE)
      pass ("DIMSTYLE.DIMTMOVE [BS]");
    else
      {
        fail ("DIMSTYLE.DIMTMOVE [BS] %d != %d", dimstyle->DIMTMOVE, DIMTMOVE); error++;
      }
  }
  {
    BITCODE_B DIMTOFL;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMTOFL", &DIMTOFL, NULL) &&
        DIMTOFL == dimstyle->DIMTOFL)
      pass ("DIMSTYLE.DIMTOFL [B]");
    else
      {
        fail ("DIMSTYLE.DIMTOFL [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMTOFL, DIMTOFL); error++;
      }
  }
  {
    BITCODE_B DIMTOH;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMTOH", &DIMTOH, NULL) &&
        DIMTOH == dimstyle->DIMTOH)
      pass ("DIMSTYLE.DIMTOH [B]");
    else
      {
        fail ("DIMSTYLE.DIMTOH [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMTOH, DIMTOH); error++;
      }
  }
  {
    BITCODE_B DIMTOL;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMTOL", &DIMTOL, NULL) &&
        DIMTOL == dimstyle->DIMTOL)
      pass ("DIMSTYLE.DIMTOL [B]");
    else
      {
        fail ("DIMSTYLE.DIMTOL [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMTOL, DIMTOL); error++;
      }
  }
  {
    BITCODE_BS DIMTOLJ;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMTOLJ", &DIMTOLJ, NULL) &&
        DIMTOLJ == dimstyle->DIMTOLJ)
      pass ("DIMSTYLE.DIMTOLJ [BS]");
    else
      {
        fail ("DIMSTYLE.DIMTOLJ [BS] %d != %d", dimstyle->DIMTOLJ, DIMTOLJ); error++;
      }
  }
  {
    BITCODE_BD DIMTP;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMTP", &DIMTP, NULL) &&
        DIMTP == dimstyle->DIMTP)
      pass ("DIMSTYLE.DIMTP [BD]");
    else
      {
        fail ("DIMSTYLE.DIMTP [BD] %g != %g", dimstyle->DIMTP, DIMTP); error++;
      }
  }
  {
    BITCODE_BD DIMTSZ;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMTSZ", &DIMTSZ, NULL) &&
        DIMTSZ == dimstyle->DIMTSZ)
      pass ("DIMSTYLE.DIMTSZ [BD]");
    else
      {
        fail ("DIMSTYLE.DIMTSZ [BD] %g != %g", dimstyle->DIMTSZ, DIMTSZ); error++;
      }
  }
  {
    BITCODE_BD DIMTVP;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMTVP", &DIMTVP, NULL) &&
        DIMTVP == dimstyle->DIMTVP)
      pass ("DIMSTYLE.DIMTVP [BD]");
    else
      {
        fail ("DIMSTYLE.DIMTVP [BD] %g != %g", dimstyle->DIMTVP, DIMTVP); error++;
      }
  }
  {
    BITCODE_H DIMTXSTY;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMTXSTY", &DIMTXSTY, NULL) &&
        DIMTXSTY == dimstyle->DIMTXSTY)
      pass ("DIMSTYLE.DIMTXSTY [H]");
    else
      {
        fail ("DIMSTYLE.DIMTXSTY [H] %p != %p", dimstyle->DIMTXSTY, DIMTXSTY); error++;
      }
  }
  {
    BITCODE_BD DIMTXT;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMTXT", &DIMTXT, NULL) &&
        DIMTXT == dimstyle->DIMTXT)
      pass ("DIMSTYLE.DIMTXT [BD]");
    else
      {
        fail ("DIMSTYLE.DIMTXT [BD] %g != %g", dimstyle->DIMTXT, DIMTXT); error++;
      }
  }
  {
    BITCODE_B DIMTXTDIRECTION;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMTXTDIRECTION", &DIMTXTDIRECTION, NULL) &&
        DIMTXTDIRECTION == dimstyle->DIMTXTDIRECTION)
      pass ("DIMSTYLE.DIMTXTDIRECTION [B]");
    else
      {
        fail ("DIMSTYLE.DIMTXTDIRECTION [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMTXTDIRECTION, DIMTXTDIRECTION); error++;
      }
  }
  {
    BITCODE_BS DIMTZIN;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMTZIN", &DIMTZIN, NULL) &&
        DIMTZIN == dimstyle->DIMTZIN)
      pass ("DIMSTYLE.DIMTZIN [BS]");
    else
      {
        fail ("DIMSTYLE.DIMTZIN [BS] %d != %d", dimstyle->DIMTZIN, DIMTZIN); error++;
      }
  }
  {
    BITCODE_BS DIMUNIT;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMUNIT", &DIMUNIT, NULL) &&
        DIMUNIT == dimstyle->DIMUNIT)
      pass ("DIMSTYLE.DIMUNIT [BS]");
    else
      {
        fail ("DIMSTYLE.DIMUNIT [BS] %d != %d", dimstyle->DIMUNIT, DIMUNIT); error++;
      }
  }
  {
    BITCODE_B DIMUPT;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMUPT", &DIMUPT, NULL) &&
        DIMUPT == dimstyle->DIMUPT)
      pass ("DIMSTYLE.DIMUPT [B]");
    else
      {
        fail ("DIMSTYLE.DIMUPT [B] " FORMAT_B " != " FORMAT_B "", dimstyle->DIMUPT, DIMUPT); error++;
      }
  }
  {
    BITCODE_BS DIMZIN;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "DIMZIN", &DIMZIN, NULL) &&
        DIMZIN == dimstyle->DIMZIN)
      pass ("DIMSTYLE.DIMZIN [BS]");
    else
      {
        fail ("DIMSTYLE.DIMZIN [BS] %d != %d", dimstyle->DIMZIN, DIMZIN); error++;
      }
  }
  {
    BITCODE_H dimstyle_control;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "dimstyle_control", &dimstyle_control, NULL) &&
        dimstyle_control == dimstyle->dimstyle_control)
      pass ("DIMSTYLE.dimstyle_control [H]");
    else
      {
        fail ("DIMSTYLE.dimstyle_control [H] %p != %p", dimstyle->dimstyle_control, dimstyle_control); error++;
      }
  }
  {
    BITCODE_H extref_handle;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "extref_handle", &extref_handle, NULL) &&
        extref_handle == dimstyle->extref_handle)
      pass ("DIMSTYLE.extref_handle [H]");
    else
      {
        fail ("DIMSTYLE.extref_handle [H] %p != %p", dimstyle->extref_handle, extref_handle); error++;
      }
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "flag", &flag, NULL) &&
        flag == dimstyle->flag)
      pass ("DIMSTYLE.flag [RC]");
    else
      {
        fail ("DIMSTYLE.flag [RC] %c != %c", dimstyle->flag, flag); error++;
      }
  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "name", &name, NULL)
        && !strcmp((char*)&name, (char*)&dimstyle->name))
      pass ("DIMSTYLE.name");
    else
      {
        fail ("DIMSTYLE.name"); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "parent", &parent, NULL)
        && !memcmp(&parent, &dimstyle->parent, sizeof(dimstyle->parent)))
      pass ("DIMSTYLE.parent");
    else
      {
        fail ("DIMSTYLE.parent"); error++;
      }
  }
  {
    BITCODE_RS used;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "used", &used, NULL) &&
        used == dimstyle->used)
      pass ("DIMSTYLE.used [RS]");
    else
      {
        fail ("DIMSTYLE.used [RS] " FORMAT_RS " != " FORMAT_RS "", dimstyle->used, used); error++;
      }
  }
  {
    BITCODE_B xrefdep;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "xrefdep", &xrefdep, NULL) &&
        xrefdep == dimstyle->xrefdep)
      pass ("DIMSTYLE.xrefdep [B]");
    else
      {
        fail ("DIMSTYLE.xrefdep [B] " FORMAT_B " != " FORMAT_B "", dimstyle->xrefdep, xrefdep); error++;
      }
  }
  {
    BITCODE_BS xrefindex_plus1;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "xrefindex_plus1", &xrefindex_plus1, NULL) &&
        xrefindex_plus1 == dimstyle->xrefindex_plus1)
      pass ("DIMSTYLE.xrefindex_plus1 [BS]");
    else
      {
        fail ("DIMSTYLE.xrefindex_plus1 [BS] %d != %d", dimstyle->xrefindex_plus1, xrefindex_plus1); error++;
      }
  }
  {
    BITCODE_B xrefref;
    if (dwg_dynapi_entity_value(dimstyle, "DIMSTYLE", "xrefref", &xrefref, NULL) &&
        xrefref == dimstyle->xrefref)
      pass ("DIMSTYLE.xrefref [B]");
    else
      {
        fail ("DIMSTYLE.xrefref [B] " FORMAT_B " != " FORMAT_B "", dimstyle->xrefref, xrefref); error++;
      }
  }
  return error;
}
static int test_DIMSTYLE_CONTROL (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_DIMSTYLE_CONTROL *dimstyle_control = obj->tio.object->tio.DIMSTYLE_CONTROL;
  {
    Dwg_Object_Ref* dimstyles;
    if (dwg_dynapi_entity_value(dimstyle_control, "DIMSTYLE_CONTROL", "dimstyles", &dimstyles, NULL)
        && !memcmp(&dimstyles, &dimstyle_control->dimstyles, sizeof(dimstyle_control->dimstyles)))
      pass ("DIMSTYLE_CONTROL.dimstyles");
    else
      {
        fail ("DIMSTYLE_CONTROL.dimstyles"); error++;
      }
  }
  {
    BITCODE_H* morehandles;
    if (dwg_dynapi_entity_value(dimstyle_control, "DIMSTYLE_CONTROL", "morehandles", &morehandles, NULL)
        && !memcmp(&morehandles, &dimstyle_control->morehandles, sizeof(dimstyle_control->morehandles)))
      pass ("DIMSTYLE_CONTROL.morehandles");
    else
      {
        fail ("DIMSTYLE_CONTROL.morehandles"); error++;
      }
  }
  {
    Dwg_Object_Ref* null_handle;
    if (dwg_dynapi_entity_value(dimstyle_control, "DIMSTYLE_CONTROL", "null_handle", &null_handle, NULL)
        && !memcmp(&null_handle, &dimstyle_control->null_handle, sizeof(dimstyle_control->null_handle)))
      pass ("DIMSTYLE_CONTROL.null_handle");
    else
      {
        fail ("DIMSTYLE_CONTROL.null_handle"); error++;
      }
  }
  {
    BITCODE_BS num_entries;
    if (dwg_dynapi_entity_value(dimstyle_control, "DIMSTYLE_CONTROL", "num_entries", &num_entries, NULL) &&
        num_entries == dimstyle_control->num_entries)
      pass ("DIMSTYLE_CONTROL.num_entries [BS]");
    else
      {
        fail ("DIMSTYLE_CONTROL.num_entries [BS] %d != %d", dimstyle_control->num_entries, num_entries); error++;
      }
  }
  {
    BITCODE_RC num_morehandles;
    if (dwg_dynapi_entity_value(dimstyle_control, "DIMSTYLE_CONTROL", "num_morehandles", &num_morehandles, NULL) &&
        num_morehandles == dimstyle_control->num_morehandles)
      pass ("DIMSTYLE_CONTROL.num_morehandles [RC]");
    else
      {
        fail ("DIMSTYLE_CONTROL.num_morehandles [RC] %c != %c", dimstyle_control->num_morehandles, num_morehandles); error++;
      }
  }
  {
    BITCODE_BL objid;
    if (dwg_dynapi_entity_value(dimstyle_control, "DIMSTYLE_CONTROL", "objid", &objid, NULL) &&
        objid == dimstyle_control->objid)
      pass ("DIMSTYLE_CONTROL.objid [BL]");
    else
      {
        fail ("DIMSTYLE_CONTROL.objid [BL] %u != %u", dimstyle_control->objid, objid); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(dimstyle_control, "DIMSTYLE_CONTROL", "parent", &parent, NULL)
        && !memcmp(&parent, &dimstyle_control->parent, sizeof(dimstyle_control->parent)))
      pass ("DIMSTYLE_CONTROL.parent");
    else
      {
        fail ("DIMSTYLE_CONTROL.parent"); error++;
      }
  }
  {
    Dwg_Object_Ref* reactors;
    if (dwg_dynapi_entity_value(dimstyle_control, "DIMSTYLE_CONTROL", "reactors", &reactors, NULL)
        && !memcmp(&reactors, &dimstyle_control->reactors, sizeof(dimstyle_control->reactors)))
      pass ("DIMSTYLE_CONTROL.reactors");
    else
      {
        fail ("DIMSTYLE_CONTROL.reactors"); error++;
      }
  }
  {
    Dwg_Object_Ref* xdicobjhandle;
    if (dwg_dynapi_entity_value(dimstyle_control, "DIMSTYLE_CONTROL", "xdicobjhandle", &xdicobjhandle, NULL)
        && !memcmp(&xdicobjhandle, &dimstyle_control->xdicobjhandle, sizeof(dimstyle_control->xdicobjhandle)))
      pass ("DIMSTYLE_CONTROL.xdicobjhandle");
    else
      {
        fail ("DIMSTYLE_CONTROL.xdicobjhandle"); error++;
      }
  }
  return error;
}
static int test_DUMMY (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_DUMMY *dummy = obj->tio.object->tio.DUMMY;
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(dummy, "DUMMY", "parent", &parent, NULL)
        && !memcmp(&parent, &dummy->parent, sizeof(dummy->parent)))
      pass ("DUMMY.parent");
    else
      {
        fail ("DUMMY.parent"); error++;
      }
  }
  return error;
}
static int test_DYNAMICBLOCKPURGEPREVENTER (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_DYNAMICBLOCKPURGEPREVENTER *dynamicblockpurgepreventer = obj->tio.object->tio.DYNAMICBLOCKPURGEPREVENTER;
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value(dynamicblockpurgepreventer, "DYNAMICBLOCKPURGEPREVENTER", "flag", &flag, NULL) &&
        flag == dynamicblockpurgepreventer->flag)
      pass ("DYNAMICBLOCKPURGEPREVENTER.flag [BS]");
    else
      {
        fail ("DYNAMICBLOCKPURGEPREVENTER.flag [BS] %d != %d", dynamicblockpurgepreventer->flag, flag); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(dynamicblockpurgepreventer, "DYNAMICBLOCKPURGEPREVENTER", "ownerhandle", &ownerhandle, NULL) &&
        ownerhandle == dynamicblockpurgepreventer->ownerhandle)
      pass ("DYNAMICBLOCKPURGEPREVENTER.ownerhandle [H]");
    else
      {
        fail ("DYNAMICBLOCKPURGEPREVENTER.ownerhandle [H] %p != %p", dynamicblockpurgepreventer->ownerhandle, ownerhandle); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(dynamicblockpurgepreventer, "DYNAMICBLOCKPURGEPREVENTER", "parent", &parent, NULL)
        && !memcmp(&parent, &dynamicblockpurgepreventer->parent, sizeof(dynamicblockpurgepreventer->parent)))
      pass ("DYNAMICBLOCKPURGEPREVENTER.parent");
    else
      {
        fail ("DYNAMICBLOCKPURGEPREVENTER.parent"); error++;
      }
  }
  {
    BITCODE_RS unknown_rs1;
    if (dwg_dynapi_entity_value(dynamicblockpurgepreventer, "DYNAMICBLOCKPURGEPREVENTER", "unknown_rs1", &unknown_rs1, NULL) &&
        unknown_rs1 == dynamicblockpurgepreventer->unknown_rs1)
      pass ("DYNAMICBLOCKPURGEPREVENTER.unknown_rs1 [RS]");
    else
      {
        fail ("DYNAMICBLOCKPURGEPREVENTER.unknown_rs1 [RS] " FORMAT_RS " != " FORMAT_RS "", dynamicblockpurgepreventer->unknown_rs1, unknown_rs1); error++;
      }
  }
  return error;
}
static int test_EVALUATION_GRAPH (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_EVALUATION_GRAPH *evaluation_graph = obj->tio.object->tio.EVALUATION_GRAPH;
  {
    BITCODE_BL edge_flags;
    if (dwg_dynapi_entity_value(evaluation_graph, "EVALUATION_GRAPH", "edge_flags", &edge_flags, NULL) &&
        edge_flags == evaluation_graph->edge_flags)
      pass ("EVALUATION_GRAPH.edge_flags [BL]");
    else
      {
        fail ("EVALUATION_GRAPH.edge_flags [BL] %u != %u", evaluation_graph->edge_flags, edge_flags); error++;
      }
  }
  {
    Dwg_Object_Ref* evalexpr;
    if (dwg_dynapi_entity_value(evaluation_graph, "EVALUATION_GRAPH", "evalexpr", &evalexpr, NULL)
        && !memcmp(&evalexpr, &evaluation_graph->evalexpr, sizeof(evaluation_graph->evalexpr)))
      pass ("EVALUATION_GRAPH.evalexpr");
    else
      {
        fail ("EVALUATION_GRAPH.evalexpr"); error++;
      }
  }
  {
    BITCODE_BL has_graph;
    if (dwg_dynapi_entity_value(evaluation_graph, "EVALUATION_GRAPH", "has_graph", &has_graph, NULL) &&
        has_graph == evaluation_graph->has_graph)
      pass ("EVALUATION_GRAPH.has_graph [BL]");
    else
      {
        fail ("EVALUATION_GRAPH.has_graph [BL] %u != %u", evaluation_graph->has_graph, has_graph); error++;
      }
  }
  {
    BITCODE_BL node_edge1;
    if (dwg_dynapi_entity_value(evaluation_graph, "EVALUATION_GRAPH", "node_edge1", &node_edge1, NULL) &&
        node_edge1 == evaluation_graph->node_edge1)
      pass ("EVALUATION_GRAPH.node_edge1 [BL]");
    else
      {
        fail ("EVALUATION_GRAPH.node_edge1 [BL] %u != %u", evaluation_graph->node_edge1, node_edge1); error++;
      }
  }
  {
    BITCODE_BL node_edge2;
    if (dwg_dynapi_entity_value(evaluation_graph, "EVALUATION_GRAPH", "node_edge2", &node_edge2, NULL) &&
        node_edge2 == evaluation_graph->node_edge2)
      pass ("EVALUATION_GRAPH.node_edge2 [BL]");
    else
      {
        fail ("EVALUATION_GRAPH.node_edge2 [BL] %u != %u", evaluation_graph->node_edge2, node_edge2); error++;
      }
  }
  {
    BITCODE_BL node_edge3;
    if (dwg_dynapi_entity_value(evaluation_graph, "EVALUATION_GRAPH", "node_edge3", &node_edge3, NULL) &&
        node_edge3 == evaluation_graph->node_edge3)
      pass ("EVALUATION_GRAPH.node_edge3 [BL]");
    else
      {
        fail ("EVALUATION_GRAPH.node_edge3 [BL] %u != %u", evaluation_graph->node_edge3, node_edge3); error++;
      }
  }
  {
    BITCODE_BL node_edge4;
    if (dwg_dynapi_entity_value(evaluation_graph, "EVALUATION_GRAPH", "node_edge4", &node_edge4, NULL) &&
        node_edge4 == evaluation_graph->node_edge4)
      pass ("EVALUATION_GRAPH.node_edge4 [BL]");
    else
      {
        fail ("EVALUATION_GRAPH.node_edge4 [BL] %u != %u", evaluation_graph->node_edge4, node_edge4); error++;
      }
  }
  {
    BITCODE_BL nodeid;
    if (dwg_dynapi_entity_value(evaluation_graph, "EVALUATION_GRAPH", "nodeid", &nodeid, NULL) &&
        nodeid == evaluation_graph->nodeid)
      pass ("EVALUATION_GRAPH.nodeid [BL]");
    else
      {
        fail ("EVALUATION_GRAPH.nodeid [BL] %u != %u", evaluation_graph->nodeid, nodeid); error++;
      }
  }
  {
    BITCODE_BL num_evalexpr;
    if (dwg_dynapi_entity_value(evaluation_graph, "EVALUATION_GRAPH", "num_evalexpr", &num_evalexpr, NULL) &&
        num_evalexpr == evaluation_graph->num_evalexpr)
      pass ("EVALUATION_GRAPH.num_evalexpr [BL]");
    else
      {
        fail ("EVALUATION_GRAPH.num_evalexpr [BL] %u != %u", evaluation_graph->num_evalexpr, num_evalexpr); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(evaluation_graph, "EVALUATION_GRAPH", "ownerhandle", &ownerhandle, NULL) &&
        ownerhandle == evaluation_graph->ownerhandle)
      pass ("EVALUATION_GRAPH.ownerhandle [H]");
    else
      {
        fail ("EVALUATION_GRAPH.ownerhandle [H] %p != %p", evaluation_graph->ownerhandle, ownerhandle); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(evaluation_graph, "EVALUATION_GRAPH", "parent", &parent, NULL)
        && !memcmp(&parent, &evaluation_graph->parent, sizeof(evaluation_graph->parent)))
      pass ("EVALUATION_GRAPH.parent");
    else
      {
        fail ("EVALUATION_GRAPH.parent"); error++;
      }
  }
  {
    BITCODE_BL unknown1;
    if (dwg_dynapi_entity_value(evaluation_graph, "EVALUATION_GRAPH", "unknown1", &unknown1, NULL) &&
        unknown1 == evaluation_graph->unknown1)
      pass ("EVALUATION_GRAPH.unknown1 [BL]");
    else
      {
        fail ("EVALUATION_GRAPH.unknown1 [BL] %u != %u", evaluation_graph->unknown1, unknown1); error++;
      }
  }
  {
    BITCODE_BL unknown2;
    if (dwg_dynapi_entity_value(evaluation_graph, "EVALUATION_GRAPH", "unknown2", &unknown2, NULL) &&
        unknown2 == evaluation_graph->unknown2)
      pass ("EVALUATION_GRAPH.unknown2 [BL]");
    else
      {
        fail ("EVALUATION_GRAPH.unknown2 [BL] %u != %u", evaluation_graph->unknown2, unknown2); error++;
      }
  }
  return error;
}
static int test_FIELD (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_FIELD *field = obj->tio.object->tio.FIELD;
  {
    Dwg_Object_Ref* childs;
    if (dwg_dynapi_entity_value(field, "FIELD", "childs", &childs, NULL)
        && !memcmp(&childs, &field->childs, sizeof(field->childs)))
      pass ("FIELD.childs");
    else
      {
        fail ("FIELD.childs"); error++;
      }
  }
  {
    Dwg_FIELD_ChildValue* childval;
    if (dwg_dynapi_entity_value(field, "FIELD", "childval", &childval, NULL)
        && !memcmp(&childval, &field->childval, sizeof(field->childval)))
      pass ("FIELD.childval");
    else
      {
        fail ("FIELD.childval"); error++;
      }
  }
  {
    BITCODE_TV code;
    if (dwg_dynapi_entity_value(field, "FIELD", "code", &code, NULL)
        && !strcmp((char*)&code, (char*)&field->code))
      pass ("FIELD.code");
    else
      {
        fail ("FIELD.code"); error++;
      }
  }
  {
    BITCODE_BL evaluation_error_code;
    if (dwg_dynapi_entity_value(field, "FIELD", "evaluation_error_code", &evaluation_error_code, NULL) &&
        evaluation_error_code == field->evaluation_error_code)
      pass ("FIELD.evaluation_error_code [BL]");
    else
      {
        fail ("FIELD.evaluation_error_code [BL] %u != %u", field->evaluation_error_code, evaluation_error_code); error++;
      }
  }
  {
    BITCODE_TV evaluation_error_msg;
    if (dwg_dynapi_entity_value(field, "FIELD", "evaluation_error_msg", &evaluation_error_msg, NULL)
        && !strcmp((char*)&evaluation_error_msg, (char*)&field->evaluation_error_msg))
      pass ("FIELD.evaluation_error_msg");
    else
      {
        fail ("FIELD.evaluation_error_msg"); error++;
      }
  }
  {
    BITCODE_BL evaluation_option;
    if (dwg_dynapi_entity_value(field, "FIELD", "evaluation_option", &evaluation_option, NULL) &&
        evaluation_option == field->evaluation_option)
      pass ("FIELD.evaluation_option [BL]");
    else
      {
        fail ("FIELD.evaluation_option [BL] %u != %u", field->evaluation_option, evaluation_option); error++;
      }
  }
  {
    BITCODE_BL evaluation_status;
    if (dwg_dynapi_entity_value(field, "FIELD", "evaluation_status", &evaluation_status, NULL) &&
        evaluation_status == field->evaluation_status)
      pass ("FIELD.evaluation_status [BL]");
    else
      {
        fail ("FIELD.evaluation_status [BL] %u != %u", field->evaluation_status, evaluation_status); error++;
      }
  }
  {
    BITCODE_BL field_state;
    if (dwg_dynapi_entity_value(field, "FIELD", "field_state", &field_state, NULL) &&
        field_state == field->field_state)
      pass ("FIELD.field_state [BL]");
    else
      {
        fail ("FIELD.field_state [BL] %u != %u", field->field_state, field_state); error++;
      }
  }
  {
    BITCODE_BL filing_option;
    if (dwg_dynapi_entity_value(field, "FIELD", "filing_option", &filing_option, NULL) &&
        filing_option == field->filing_option)
      pass ("FIELD.filing_option [BL]");
    else
      {
        fail ("FIELD.filing_option [BL] %u != %u", field->filing_option, filing_option); error++;
      }
  }
  {
    BITCODE_TV format;
    if (dwg_dynapi_entity_value(field, "FIELD", "format", &format, NULL)
        && !strcmp((char*)&format, (char*)&field->format))
      pass ("FIELD.format");
    else
      {
        fail ("FIELD.format"); error++;
      }
  }
  {
    BITCODE_TV id;
    if (dwg_dynapi_entity_value(field, "FIELD", "id", &id, NULL)
        && !strcmp((char*)&id, (char*)&field->id))
      pass ("FIELD.id");
    else
      {
        fail ("FIELD.id"); error++;
      }
  }
  {
    BITCODE_BL num_childs;
    if (dwg_dynapi_entity_value(field, "FIELD", "num_childs", &num_childs, NULL) &&
        num_childs == field->num_childs)
      pass ("FIELD.num_childs [BL]");
    else
      {
        fail ("FIELD.num_childs [BL] %u != %u", field->num_childs, num_childs); error++;
      }
  }
  {
    BITCODE_BL num_childval;
    if (dwg_dynapi_entity_value(field, "FIELD", "num_childval", &num_childval, NULL) &&
        num_childval == field->num_childval)
      pass ("FIELD.num_childval [BL]");
    else
      {
        fail ("FIELD.num_childval [BL] %u != %u", field->num_childval, num_childval); error++;
      }
  }
  {
    BITCODE_BL num_objects;
    if (dwg_dynapi_entity_value(field, "FIELD", "num_objects", &num_objects, NULL) &&
        num_objects == field->num_objects)
      pass ("FIELD.num_objects [BL]");
    else
      {
        fail ("FIELD.num_objects [BL] %u != %u", field->num_objects, num_objects); error++;
      }
  }
  {
    Dwg_Object_Ref* objects;
    if (dwg_dynapi_entity_value(field, "FIELD", "objects", &objects, NULL)
        && !memcmp(&objects, &field->objects, sizeof(field->objects)))
      pass ("FIELD.objects");
    else
      {
        fail ("FIELD.objects"); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(field, "FIELD", "parent", &parent, NULL)
        && !memcmp(&parent, &field->parent, sizeof(field->parent)))
      pass ("FIELD.parent");
    else
      {
        fail ("FIELD.parent"); error++;
      }
  }
  {
    Dwg_TABLE_value value;
    if (dwg_dynapi_entity_value(field, "FIELD", "value", &value, NULL)
        && !memcmp(&value, &field->value, sizeof(field->value)))
      pass ("FIELD.value");
    else
      {
        fail ("FIELD.value"); error++;
      }
  }
  {
    BITCODE_TV value_string;
    if (dwg_dynapi_entity_value(field, "FIELD", "value_string", &value_string, NULL)
        && !strcmp((char*)&value_string, (char*)&field->value_string))
      pass ("FIELD.value_string");
    else
      {
        fail ("FIELD.value_string"); error++;
      }
  }
  {
    BITCODE_BL value_string_length;
    if (dwg_dynapi_entity_value(field, "FIELD", "value_string_length", &value_string_length, NULL) &&
        value_string_length == field->value_string_length)
      pass ("FIELD.value_string_length [BL]");
    else
      {
        fail ("FIELD.value_string_length [BL] %u != %u", field->value_string_length, value_string_length); error++;
      }
  }
  return error;
}
static int test_FIELDLIST (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_FIELDLIST *fieldlist = obj->tio.object->tio.FIELDLIST;
  {
    BITCODE_H * field_handles;
    if (dwg_dynapi_entity_value(fieldlist, "FIELDLIST", "field_handles", &field_handles, NULL)
        && !memcmp(&field_handles, &fieldlist->field_handles, sizeof(fieldlist->field_handles)))
      pass ("FIELDLIST.field_handles");
    else
      {
        fail ("FIELDLIST.field_handles"); error++;
      }
  }
  {
    BITCODE_BL num_fields;
    if (dwg_dynapi_entity_value(fieldlist, "FIELDLIST", "num_fields", &num_fields, NULL) &&
        num_fields == fieldlist->num_fields)
      pass ("FIELDLIST.num_fields [BL]");
    else
      {
        fail ("FIELDLIST.num_fields [BL] %u != %u", fieldlist->num_fields, num_fields); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(fieldlist, "FIELDLIST", "parent", &parent, NULL)
        && !memcmp(&parent, &fieldlist->parent, sizeof(fieldlist->parent)))
      pass ("FIELDLIST.parent");
    else
      {
        fail ("FIELDLIST.parent"); error++;
      }
  }
  {
    BITCODE_B unknown;
    if (dwg_dynapi_entity_value(fieldlist, "FIELDLIST", "unknown", &unknown, NULL) &&
        unknown == fieldlist->unknown)
      pass ("FIELDLIST.unknown [B]");
    else
      {
        fail ("FIELDLIST.unknown [B] " FORMAT_B " != " FORMAT_B "", fieldlist->unknown, unknown); error++;
      }
  }
  return error;
}
static int test_GEODATA (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_GEODATA *geodata = obj->tio.object->tio.GEODATA;
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "class_version", &class_version, NULL) &&
        class_version == geodata->class_version)
      pass ("GEODATA.class_version [BL]");
    else
      {
        fail ("GEODATA.class_version [BL] %u != %u", geodata->class_version, class_version); error++;
      }
  }
  {
    BITCODE_BD coord_proj_radius;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "coord_proj_radius", &coord_proj_radius, NULL) &&
        coord_proj_radius == geodata->coord_proj_radius)
      pass ("GEODATA.coord_proj_radius [BD]");
    else
      {
        fail ("GEODATA.coord_proj_radius [BD] %g != %g", geodata->coord_proj_radius, coord_proj_radius); error++;
      }
  }
  {
    BITCODE_T coord_system_datum;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "coord_system_datum", &coord_system_datum, NULL)
        && !memcmp(&coord_system_datum, &geodata->coord_system_datum, sizeof(geodata->coord_system_datum)))
      pass ("GEODATA.coord_system_datum");
    else
      {
        fail ("GEODATA.coord_system_datum"); error++;
      }
  }
  {
    BITCODE_T coord_system_def;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "coord_system_def", &coord_system_def, NULL)
        && !memcmp(&coord_system_def, &geodata->coord_system_def, sizeof(geodata->coord_system_def)))
      pass ("GEODATA.coord_system_def");
    else
      {
        fail ("GEODATA.coord_system_def"); error++;
      }
  }
  {
    BITCODE_T coord_system_wkt;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "coord_system_wkt", &coord_system_wkt, NULL)
        && !memcmp(&coord_system_wkt, &geodata->coord_system_wkt, sizeof(geodata->coord_system_wkt)))
      pass ("GEODATA.coord_system_wkt");
    else
      {
        fail ("GEODATA.coord_system_wkt"); error++;
      }
  }
  {
    BITCODE_BS coord_type;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "coord_type", &coord_type, NULL) &&
        coord_type == geodata->coord_type)
      pass ("GEODATA.coord_type [BS]");
    else
      {
        fail ("GEODATA.coord_type [BS] %d != %d", geodata->coord_type, coord_type); error++;
      }
  }
  {
    BITCODE_3BD design_pt;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "design_pt", &design_pt, NULL)
        && !memcmp(&design_pt, &geodata->design_pt, sizeof(geodata->design_pt)))
      pass ("GEODATA.design_pt");
    else
      {
        fail ("GEODATA.design_pt"); error++;
      }
  }
  {
    BITCODE_T geo_rss_tag;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "geo_rss_tag", &geo_rss_tag, NULL)
        && !memcmp(&geo_rss_tag, &geodata->geo_rss_tag, sizeof(geodata->geo_rss_tag)))
      pass ("GEODATA.geo_rss_tag");
    else
      {
        fail ("GEODATA.geo_rss_tag"); error++;
      }
  }
  {
    Dwg_GEODATA_meshface* geomesh_faces;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "geomesh_faces", &geomesh_faces, NULL)
        && !memcmp(&geomesh_faces, &geodata->geomesh_faces, sizeof(geodata->geomesh_faces)))
      pass ("GEODATA.geomesh_faces");
    else
      {
        fail ("GEODATA.geomesh_faces"); error++;
      }
  }
  {
    Dwg_GEODATA_meshpt* geomesh_pts;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "geomesh_pts", &geomesh_pts, NULL)
        && !memcmp(&geomesh_pts, &geodata->geomesh_pts, sizeof(geodata->geomesh_pts)))
      pass ("GEODATA.geomesh_pts");
    else
      {
        fail ("GEODATA.geomesh_pts"); error++;
      }
  }
  {
    BITCODE_B has_civil_data;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "has_civil_data", &has_civil_data, NULL) &&
        has_civil_data == geodata->has_civil_data)
      pass ("GEODATA.has_civil_data [B]");
    else
      {
        fail ("GEODATA.has_civil_data [B] " FORMAT_B " != " FORMAT_B "", geodata->has_civil_data, has_civil_data); error++;
      }
  }
  {
    BITCODE_H host_block;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "host_block", &host_block, NULL) &&
        host_block == geodata->host_block)
      pass ("GEODATA.host_block [H]");
    else
      {
        fail ("GEODATA.host_block [H] %p != %p", geodata->host_block, host_block); error++;
      }
  }
  {
    BITCODE_3BD north_dir;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "north_dir", &north_dir, NULL)
        && !memcmp(&north_dir, &geodata->north_dir, sizeof(geodata->north_dir)))
      pass ("GEODATA.north_dir");
    else
      {
        fail ("GEODATA.north_dir"); error++;
      }
  }
  {
    BITCODE_BD north_dir_angle_deg;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "north_dir_angle_deg", &north_dir_angle_deg, NULL) &&
        north_dir_angle_deg == geodata->north_dir_angle_deg)
      pass ("GEODATA.north_dir_angle_deg [BD]");
    else
      {
        fail ("GEODATA.north_dir_angle_deg [BD] %g != %g", geodata->north_dir_angle_deg, north_dir_angle_deg); error++;
      }
  }
  {
    BITCODE_BD north_dir_angle_rad;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "north_dir_angle_rad", &north_dir_angle_rad, NULL) &&
        north_dir_angle_rad == geodata->north_dir_angle_rad)
      pass ("GEODATA.north_dir_angle_rad [BD]");
    else
      {
        fail ("GEODATA.north_dir_angle_rad [BD] %g != %g", geodata->north_dir_angle_rad, north_dir_angle_rad); error++;
      }
  }
  {
    BITCODE_BL num_geomesh_faces;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "num_geomesh_faces", &num_geomesh_faces, NULL) &&
        num_geomesh_faces == geodata->num_geomesh_faces)
      pass ("GEODATA.num_geomesh_faces [BL]");
    else
      {
        fail ("GEODATA.num_geomesh_faces [BL] %u != %u", geodata->num_geomesh_faces, num_geomesh_faces); error++;
      }
  }
  {
    BITCODE_BL num_geomesh_pts;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "num_geomesh_pts", &num_geomesh_pts, NULL) &&
        num_geomesh_pts == geodata->num_geomesh_pts)
      pass ("GEODATA.num_geomesh_pts [BL]");
    else
      {
        fail ("GEODATA.num_geomesh_pts [BL] %u != %u", geodata->num_geomesh_pts, num_geomesh_pts); error++;
      }
  }
  {
    BITCODE_3BD obs_pt;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "obs_pt", &obs_pt, NULL)
        && !memcmp(&obs_pt, &geodata->obs_pt, sizeof(geodata->obs_pt)))
      pass ("GEODATA.obs_pt");
    else
      {
        fail ("GEODATA.obs_pt"); error++;
      }
  }
  {
    BITCODE_T observation_coverage_tag;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "observation_coverage_tag", &observation_coverage_tag, NULL)
        && !memcmp(&observation_coverage_tag, &geodata->observation_coverage_tag, sizeof(geodata->observation_coverage_tag)))
      pass ("GEODATA.observation_coverage_tag");
    else
      {
        fail ("GEODATA.observation_coverage_tag"); error++;
      }
  }
  {
    BITCODE_T observation_from_tag;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "observation_from_tag", &observation_from_tag, NULL)
        && !memcmp(&observation_from_tag, &geodata->observation_from_tag, sizeof(geodata->observation_from_tag)))
      pass ("GEODATA.observation_from_tag");
    else
      {
        fail ("GEODATA.observation_from_tag"); error++;
      }
  }
  {
    BITCODE_T observation_to_tag;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "observation_to_tag", &observation_to_tag, NULL)
        && !memcmp(&observation_to_tag, &geodata->observation_to_tag, sizeof(geodata->observation_to_tag)))
      pass ("GEODATA.observation_to_tag");
    else
      {
        fail ("GEODATA.observation_to_tag"); error++;
      }
  }
  {
    BITCODE_B obsolete_false;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "obsolete_false", &obsolete_false, NULL) &&
        obsolete_false == geodata->obsolete_false)
      pass ("GEODATA.obsolete_false [B]");
    else
      {
        fail ("GEODATA.obsolete_false [B] " FORMAT_B " != " FORMAT_B "", geodata->obsolete_false, obsolete_false); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "parent", &parent, NULL)
        && !memcmp(&parent, &geodata->parent, sizeof(geodata->parent)))
      pass ("GEODATA.parent");
    else
      {
        fail ("GEODATA.parent"); error++;
      }
  }
  {
    BITCODE_3BD ref_pt;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "ref_pt", &ref_pt, NULL)
        && !memcmp(&ref_pt, &geodata->ref_pt, sizeof(geodata->ref_pt)))
      pass ("GEODATA.ref_pt");
    else
      {
        fail ("GEODATA.ref_pt"); error++;
      }
  }
  {
    BITCODE_BL scale_est;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "scale_est", &scale_est, NULL) &&
        scale_est == geodata->scale_est)
      pass ("GEODATA.scale_est [BL]");
    else
      {
        fail ("GEODATA.scale_est [BL] %u != %u", geodata->scale_est, scale_est); error++;
      }
  }
  {
    BITCODE_B sea_level_corr;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "sea_level_corr", &sea_level_corr, NULL) &&
        sea_level_corr == geodata->sea_level_corr)
      pass ("GEODATA.sea_level_corr [B]");
    else
      {
        fail ("GEODATA.sea_level_corr [B] " FORMAT_B " != " FORMAT_B "", geodata->sea_level_corr, sea_level_corr); error++;
      }
  }
  {
    BITCODE_BD sea_level_elev;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "sea_level_elev", &sea_level_elev, NULL) &&
        sea_level_elev == geodata->sea_level_elev)
      pass ("GEODATA.sea_level_elev [BD]");
    else
      {
        fail ("GEODATA.sea_level_elev [BD] %g != %g", geodata->sea_level_elev, sea_level_elev); error++;
      }
  }
  {
    BITCODE_BD unit_scale_horiz;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "unit_scale_horiz", &unit_scale_horiz, NULL) &&
        unit_scale_horiz == geodata->unit_scale_horiz)
      pass ("GEODATA.unit_scale_horiz [BD]");
    else
      {
        fail ("GEODATA.unit_scale_horiz [BD] %g != %g", geodata->unit_scale_horiz, unit_scale_horiz); error++;
      }
  }
  {
    BITCODE_BD unit_scale_vert;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "unit_scale_vert", &unit_scale_vert, NULL) &&
        unit_scale_vert == geodata->unit_scale_vert)
      pass ("GEODATA.unit_scale_vert [BD]");
    else
      {
        fail ("GEODATA.unit_scale_vert [BD] %g != %g", geodata->unit_scale_vert, unit_scale_vert); error++;
      }
  }
  {
    BITCODE_BL units_value_horiz;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "units_value_horiz", &units_value_horiz, NULL) &&
        units_value_horiz == geodata->units_value_horiz)
      pass ("GEODATA.units_value_horiz [BL]");
    else
      {
        fail ("GEODATA.units_value_horiz [BL] %u != %u", geodata->units_value_horiz, units_value_horiz); error++;
      }
  }
  {
    BITCODE_BL units_value_vert;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "units_value_vert", &units_value_vert, NULL) &&
        units_value_vert == geodata->units_value_vert)
      pass ("GEODATA.units_value_vert [BL]");
    else
      {
        fail ("GEODATA.units_value_vert [BL] %u != %u", geodata->units_value_vert, units_value_vert); error++;
      }
  }
  {
    BITCODE_3BD up_dir;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "up_dir", &up_dir, NULL)
        && !memcmp(&up_dir, &geodata->up_dir, sizeof(geodata->up_dir)))
      pass ("GEODATA.up_dir");
    else
      {
        fail ("GEODATA.up_dir"); error++;
      }
  }
  {
    BITCODE_BD user_scale_factor;
    if (dwg_dynapi_entity_value(geodata, "GEODATA", "user_scale_factor", &user_scale_factor, NULL) &&
        user_scale_factor == geodata->user_scale_factor)
      pass ("GEODATA.user_scale_factor [BD]");
    else
      {
        fail ("GEODATA.user_scale_factor [BD] %g != %g", geodata->user_scale_factor, user_scale_factor); error++;
      }
  }
  return error;
}
static int test_GROUP (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_GROUP *group = obj->tio.object->tio.GROUP;
  {
    BITCODE_H* group_entries;
    if (dwg_dynapi_entity_value(group, "GROUP", "group_entries", &group_entries, NULL)
        && !memcmp(&group_entries, &group->group_entries, sizeof(group->group_entries)))
      pass ("GROUP.group_entries");
    else
      {
        fail ("GROUP.group_entries"); error++;
      }
  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value(group, "GROUP", "name", &name, NULL)
        && !strcmp((char*)&name, (char*)&group->name))
      pass ("GROUP.name");
    else
      {
        fail ("GROUP.name"); error++;
      }
  }
  {
    BITCODE_BL num_handles;
    if (dwg_dynapi_entity_value(group, "GROUP", "num_handles", &num_handles, NULL) &&
        num_handles == group->num_handles)
      pass ("GROUP.num_handles [BL]");
    else
      {
        fail ("GROUP.num_handles [BL] %u != %u", group->num_handles, num_handles); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(group, "GROUP", "ownerhandle", &ownerhandle, NULL) &&
        ownerhandle == group->ownerhandle)
      pass ("GROUP.ownerhandle [H]");
    else
      {
        fail ("GROUP.ownerhandle [H] %p != %p", group->ownerhandle, ownerhandle); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(group, "GROUP", "parent", &parent, NULL)
        && !memcmp(&parent, &group->parent, sizeof(group->parent)))
      pass ("GROUP.parent");
    else
      {
        fail ("GROUP.parent"); error++;
      }
  }
  {
    BITCODE_BS selectable;
    if (dwg_dynapi_entity_value(group, "GROUP", "selectable", &selectable, NULL) &&
        selectable == group->selectable)
      pass ("GROUP.selectable [BS]");
    else
      {
        fail ("GROUP.selectable [BS] %d != %d", group->selectable, selectable); error++;
      }
  }
  {
    BITCODE_BS unnamed;
    if (dwg_dynapi_entity_value(group, "GROUP", "unnamed", &unnamed, NULL) &&
        unnamed == group->unnamed)
      pass ("GROUP.unnamed [BS]");
    else
      {
        fail ("GROUP.unnamed [BS] %d != %d", group->unnamed, unnamed); error++;
      }
  }
  return error;
}
static int test_IDBUFFER (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_IDBUFFER *idbuffer = obj->tio.object->tio.IDBUFFER;
  {
    BITCODE_BL num_obj_ids;
    if (dwg_dynapi_entity_value(idbuffer, "IDBUFFER", "num_obj_ids", &num_obj_ids, NULL) &&
        num_obj_ids == idbuffer->num_obj_ids)
      pass ("IDBUFFER.num_obj_ids [BL]");
    else
      {
        fail ("IDBUFFER.num_obj_ids [BL] %u != %u", idbuffer->num_obj_ids, num_obj_ids); error++;
      }
  }
  {
    BITCODE_H* obj_ids;
    if (dwg_dynapi_entity_value(idbuffer, "IDBUFFER", "obj_ids", &obj_ids, NULL)
        && !memcmp(&obj_ids, &idbuffer->obj_ids, sizeof(idbuffer->obj_ids)))
      pass ("IDBUFFER.obj_ids");
    else
      {
        fail ("IDBUFFER.obj_ids"); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(idbuffer, "IDBUFFER", "ownerhandle", &ownerhandle, NULL) &&
        ownerhandle == idbuffer->ownerhandle)
      pass ("IDBUFFER.ownerhandle [H]");
    else
      {
        fail ("IDBUFFER.ownerhandle [H] %p != %p", idbuffer->ownerhandle, ownerhandle); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(idbuffer, "IDBUFFER", "parent", &parent, NULL)
        && !memcmp(&parent, &idbuffer->parent, sizeof(idbuffer->parent)))
      pass ("IDBUFFER.parent");
    else
      {
        fail ("IDBUFFER.parent"); error++;
      }
  }
  {
    BITCODE_RC unknown;
    if (dwg_dynapi_entity_value(idbuffer, "IDBUFFER", "unknown", &unknown, NULL) &&
        unknown == idbuffer->unknown)
      pass ("IDBUFFER.unknown [RC]");
    else
      {
        fail ("IDBUFFER.unknown [RC] %c != %c", idbuffer->unknown, unknown); error++;
      }
  }
  return error;
}
static int test_IMAGEDEF (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_IMAGEDEF *imagedef = obj->tio.object->tio.IMAGEDEF;
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value(imagedef, "IMAGEDEF", "class_version", &class_version, NULL) &&
        class_version == imagedef->class_version)
      pass ("IMAGEDEF.class_version [BL]");
    else
      {
        fail ("IMAGEDEF.class_version [BL] %u != %u", imagedef->class_version, class_version); error++;
      }
  }
  {
    BITCODE_TV file_path;
    if (dwg_dynapi_entity_value(imagedef, "IMAGEDEF", "file_path", &file_path, NULL)
        && !strcmp((char*)&file_path, (char*)&imagedef->file_path))
      pass ("IMAGEDEF.file_path");
    else
      {
        fail ("IMAGEDEF.file_path"); error++;
      }
  }
  {
    BITCODE_2RD image_size;
    if (dwg_dynapi_entity_value(imagedef, "IMAGEDEF", "image_size", &image_size, NULL)
        && !memcmp(&image_size, &imagedef->image_size, sizeof(imagedef->image_size)))
      pass ("IMAGEDEF.image_size");
    else
      {
        fail ("IMAGEDEF.image_size"); error++;
      }
  }
  {
    BITCODE_B is_loaded;
    if (dwg_dynapi_entity_value(imagedef, "IMAGEDEF", "is_loaded", &is_loaded, NULL) &&
        is_loaded == imagedef->is_loaded)
      pass ("IMAGEDEF.is_loaded [B]");
    else
      {
        fail ("IMAGEDEF.is_loaded [B] " FORMAT_B " != " FORMAT_B "", imagedef->is_loaded, is_loaded); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(imagedef, "IMAGEDEF", "ownerhandle", &ownerhandle, NULL) &&
        ownerhandle == imagedef->ownerhandle)
      pass ("IMAGEDEF.ownerhandle [H]");
    else
      {
        fail ("IMAGEDEF.ownerhandle [H] %p != %p", imagedef->ownerhandle, ownerhandle); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(imagedef, "IMAGEDEF", "parent", &parent, NULL)
        && !memcmp(&parent, &imagedef->parent, sizeof(imagedef->parent)))
      pass ("IMAGEDEF.parent");
    else
      {
        fail ("IMAGEDEF.parent"); error++;
      }
  }
  {
    BITCODE_2RD pixel_size;
    if (dwg_dynapi_entity_value(imagedef, "IMAGEDEF", "pixel_size", &pixel_size, NULL)
        && !memcmp(&pixel_size, &imagedef->pixel_size, sizeof(imagedef->pixel_size)))
      pass ("IMAGEDEF.pixel_size");
    else
      {
        fail ("IMAGEDEF.pixel_size"); error++;
      }
  }
  {
    BITCODE_RC resunits;
    if (dwg_dynapi_entity_value(imagedef, "IMAGEDEF", "resunits", &resunits, NULL) &&
        resunits == imagedef->resunits)
      pass ("IMAGEDEF.resunits [RC]");
    else
      {
        fail ("IMAGEDEF.resunits [RC] %c != %c", imagedef->resunits, resunits); error++;
      }
  }
  return error;
}
static int test_IMAGEDEF_REACTOR (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_IMAGEDEF_REACTOR *imagedef_reactor = obj->tio.object->tio.IMAGEDEF_REACTOR;
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value(imagedef_reactor, "IMAGEDEF_REACTOR", "class_version", &class_version, NULL) &&
        class_version == imagedef_reactor->class_version)
      pass ("IMAGEDEF_REACTOR.class_version [BL]");
    else
      {
        fail ("IMAGEDEF_REACTOR.class_version [BL] %u != %u", imagedef_reactor->class_version, class_version); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(imagedef_reactor, "IMAGEDEF_REACTOR", "ownerhandle", &ownerhandle, NULL) &&
        ownerhandle == imagedef_reactor->ownerhandle)
      pass ("IMAGEDEF_REACTOR.ownerhandle [H]");
    else
      {
        fail ("IMAGEDEF_REACTOR.ownerhandle [H] %p != %p", imagedef_reactor->ownerhandle, ownerhandle); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(imagedef_reactor, "IMAGEDEF_REACTOR", "parent", &parent, NULL)
        && !memcmp(&parent, &imagedef_reactor->parent, sizeof(imagedef_reactor->parent)))
      pass ("IMAGEDEF_REACTOR.parent");
    else
      {
        fail ("IMAGEDEF_REACTOR.parent"); error++;
      }
  }
  return error;
}
static int test_LAYER (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_LAYER *layer = obj->tio.object->tio.LAYER;
  {
    BITCODE_CMC color;
    if (dwg_dynapi_entity_value(layer, "LAYER", "color", &color, NULL)
        && !memcmp(&color, &layer->color, sizeof(layer->color)))
      pass ("LAYER.color");
    else
      {
        fail ("LAYER.color"); error++;
      }
  }
  {
    short color_rs;
    if (dwg_dynapi_entity_value(layer, "LAYER", "color_rs", &color_rs, NULL) &&
        color_rs == layer->color_rs)
      pass ("LAYER.color_rs [short]");
    else
      {
        fail ("LAYER.color_rs [short] %hd != %hd", layer->color_rs, color_rs); error++;
      }
  }
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value(layer, "LAYER", "flag", &flag, NULL) &&
        flag == layer->flag)
      pass ("LAYER.flag [BS]");
    else
      {
        fail ("LAYER.flag [BS] %d != %d", layer->flag, flag); error++;
      }
  }
  {
    BITCODE_B frozen;
    if (dwg_dynapi_entity_value(layer, "LAYER", "frozen", &frozen, NULL) &&
        frozen == layer->frozen)
      pass ("LAYER.frozen [B]");
    else
      {
        fail ("LAYER.frozen [B] " FORMAT_B " != " FORMAT_B "", layer->frozen, frozen); error++;
      }
  }
  {
    BITCODE_B frozen_in_new;
    if (dwg_dynapi_entity_value(layer, "LAYER", "frozen_in_new", &frozen_in_new, NULL) &&
        frozen_in_new == layer->frozen_in_new)
      pass ("LAYER.frozen_in_new [B]");
    else
      {
        fail ("LAYER.frozen_in_new [B] " FORMAT_B " != " FORMAT_B "", layer->frozen_in_new, frozen_in_new); error++;
      }
  }
  {
    BITCODE_H layer_control;
    if (dwg_dynapi_entity_value(layer, "LAYER", "layer_control", &layer_control, NULL) &&
        layer_control == layer->layer_control)
      pass ("LAYER.layer_control [H]");
    else
      {
        fail ("LAYER.layer_control [H] %p != %p", layer->layer_control, layer_control); error++;
      }
  }
  {
    BITCODE_H linetype;
    if (dwg_dynapi_entity_value(layer, "LAYER", "linetype", &linetype, NULL) &&
        linetype == layer->linetype)
      pass ("LAYER.linetype [H]");
    else
      {
        fail ("LAYER.linetype [H] %p != %p", layer->linetype, linetype); error++;
      }
  }
  {
    BITCODE_RS linetype_rs;
    if (dwg_dynapi_entity_value(layer, "LAYER", "linetype_rs", &linetype_rs, NULL) &&
        linetype_rs == layer->linetype_rs)
      pass ("LAYER.linetype_rs [RS]");
    else
      {
        fail ("LAYER.linetype_rs [RS] " FORMAT_RS " != " FORMAT_RS "", layer->linetype_rs, linetype_rs); error++;
      }
  }
  {
    BITCODE_RC linewt;
    if (dwg_dynapi_entity_value(layer, "LAYER", "linewt", &linewt, NULL) &&
        linewt == layer->linewt)
      pass ("LAYER.linewt [RC]");
    else
      {
        fail ("LAYER.linewt [RC] %c != %c", layer->linewt, linewt); error++;
      }
  }
  {
    BITCODE_B locked;
    if (dwg_dynapi_entity_value(layer, "LAYER", "locked", &locked, NULL) &&
        locked == layer->locked)
      pass ("LAYER.locked [B]");
    else
      {
        fail ("LAYER.locked [B] " FORMAT_B " != " FORMAT_B "", layer->locked, locked); error++;
      }
  }
  {
    BITCODE_H material;
    if (dwg_dynapi_entity_value(layer, "LAYER", "material", &material, NULL) &&
        material == layer->material)
      pass ("LAYER.material [H]");
    else
      {
        fail ("LAYER.material [H] %p != %p", layer->material, material); error++;
      }
  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value(layer, "LAYER", "name", &name, NULL)
        && !strcmp((char*)&name, (char*)&layer->name))
      pass ("LAYER.name");
    else
      {
        fail ("LAYER.name"); error++;
      }
  }
  {
    BITCODE_H null_handle;
    if (dwg_dynapi_entity_value(layer, "LAYER", "null_handle", &null_handle, NULL) &&
        null_handle == layer->null_handle)
      pass ("LAYER.null_handle [H]");
    else
      {
        fail ("LAYER.null_handle [H] %p != %p", layer->null_handle, null_handle); error++;
      }
  }
  {
    BITCODE_B on;
    if (dwg_dynapi_entity_value(layer, "LAYER", "on", &on, NULL) &&
        on == layer->on)
      pass ("LAYER.on [B]");
    else
      {
        fail ("LAYER.on [B] " FORMAT_B " != " FORMAT_B "", layer->on, on); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(layer, "LAYER", "parent", &parent, NULL)
        && !memcmp(&parent, &layer->parent, sizeof(layer->parent)))
      pass ("LAYER.parent");
    else
      {
        fail ("LAYER.parent"); error++;
      }
  }
  {
    BITCODE_B plotflag;
    if (dwg_dynapi_entity_value(layer, "LAYER", "plotflag", &plotflag, NULL) &&
        plotflag == layer->plotflag)
      pass ("LAYER.plotflag [B]");
    else
      {
        fail ("LAYER.plotflag [B] " FORMAT_B " != " FORMAT_B "", layer->plotflag, plotflag); error++;
      }
  }
  {
    BITCODE_H plotstyle;
    if (dwg_dynapi_entity_value(layer, "LAYER", "plotstyle", &plotstyle, NULL) &&
        plotstyle == layer->plotstyle)
      pass ("LAYER.plotstyle [H]");
    else
      {
        fail ("LAYER.plotstyle [H] %p != %p", layer->plotstyle, plotstyle); error++;
      }
  }
  {
    BITCODE_RS used;
    if (dwg_dynapi_entity_value(layer, "LAYER", "used", &used, NULL) &&
        used == layer->used)
      pass ("LAYER.used [RS]");
    else
      {
        fail ("LAYER.used [RS] " FORMAT_RS " != " FORMAT_RS "", layer->used, used); error++;
      }
  }
  {
    BITCODE_H xref;
    if (dwg_dynapi_entity_value(layer, "LAYER", "xref", &xref, NULL) &&
        xref == layer->xref)
      pass ("LAYER.xref [H]");
    else
      {
        fail ("LAYER.xref [H] %p != %p", layer->xref, xref); error++;
      }
  }
  {
    BITCODE_B xrefdep;
    if (dwg_dynapi_entity_value(layer, "LAYER", "xrefdep", &xrefdep, NULL) &&
        xrefdep == layer->xrefdep)
      pass ("LAYER.xrefdep [B]");
    else
      {
        fail ("LAYER.xrefdep [B] " FORMAT_B " != " FORMAT_B "", layer->xrefdep, xrefdep); error++;
      }
  }
  {
    BITCODE_BS xrefindex_plus1;
    if (dwg_dynapi_entity_value(layer, "LAYER", "xrefindex_plus1", &xrefindex_plus1, NULL) &&
        xrefindex_plus1 == layer->xrefindex_plus1)
      pass ("LAYER.xrefindex_plus1 [BS]");
    else
      {
        fail ("LAYER.xrefindex_plus1 [BS] %d != %d", layer->xrefindex_plus1, xrefindex_plus1); error++;
      }
  }
  {
    BITCODE_B xrefref;
    if (dwg_dynapi_entity_value(layer, "LAYER", "xrefref", &xrefref, NULL) &&
        xrefref == layer->xrefref)
      pass ("LAYER.xrefref [B]");
    else
      {
        fail ("LAYER.xrefref [B] " FORMAT_B " != " FORMAT_B "", layer->xrefref, xrefref); error++;
      }
  }
  return error;
}
static int test_LAYER_CONTROL (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_LAYER_CONTROL *layer_control = obj->tio.object->tio.LAYER_CONTROL;
  {
    Dwg_Object_Ref* layers;
    if (dwg_dynapi_entity_value(layer_control, "LAYER_CONTROL", "layers", &layers, NULL)
        && !memcmp(&layers, &layer_control->layers, sizeof(layer_control->layers)))
      pass ("LAYER_CONTROL.layers");
    else
      {
        fail ("LAYER_CONTROL.layers"); error++;
      }
  }
  {
    Dwg_Object_Ref* null_handle;
    if (dwg_dynapi_entity_value(layer_control, "LAYER_CONTROL", "null_handle", &null_handle, NULL)
        && !memcmp(&null_handle, &layer_control->null_handle, sizeof(layer_control->null_handle)))
      pass ("LAYER_CONTROL.null_handle");
    else
      {
        fail ("LAYER_CONTROL.null_handle"); error++;
      }
  }
  {
    BITCODE_BS num_entries;
    if (dwg_dynapi_entity_value(layer_control, "LAYER_CONTROL", "num_entries", &num_entries, NULL) &&
        num_entries == layer_control->num_entries)
      pass ("LAYER_CONTROL.num_entries [BS]");
    else
      {
        fail ("LAYER_CONTROL.num_entries [BS] %d != %d", layer_control->num_entries, num_entries); error++;
      }
  }
  {
    BITCODE_BL objid;
    if (dwg_dynapi_entity_value(layer_control, "LAYER_CONTROL", "objid", &objid, NULL) &&
        objid == layer_control->objid)
      pass ("LAYER_CONTROL.objid [BL]");
    else
      {
        fail ("LAYER_CONTROL.objid [BL] %u != %u", layer_control->objid, objid); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(layer_control, "LAYER_CONTROL", "parent", &parent, NULL)
        && !memcmp(&parent, &layer_control->parent, sizeof(layer_control->parent)))
      pass ("LAYER_CONTROL.parent");
    else
      {
        fail ("LAYER_CONTROL.parent"); error++;
      }
  }
  {
    Dwg_Object_Ref* reactors;
    if (dwg_dynapi_entity_value(layer_control, "LAYER_CONTROL", "reactors", &reactors, NULL)
        && !memcmp(&reactors, &layer_control->reactors, sizeof(layer_control->reactors)))
      pass ("LAYER_CONTROL.reactors");
    else
      {
        fail ("LAYER_CONTROL.reactors"); error++;
      }
  }
  {
    Dwg_Object_Ref* xdicobjhandle;
    if (dwg_dynapi_entity_value(layer_control, "LAYER_CONTROL", "xdicobjhandle", &xdicobjhandle, NULL)
        && !memcmp(&xdicobjhandle, &layer_control->xdicobjhandle, sizeof(layer_control->xdicobjhandle)))
      pass ("LAYER_CONTROL.xdicobjhandle");
    else
      {
        fail ("LAYER_CONTROL.xdicobjhandle"); error++;
      }
  }
  return error;
}
static int test_LAYER_INDEX (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_LAYER_INDEX *layer_index = obj->tio.object->tio.LAYER_INDEX;
  {
    Dwg_LAYER_entry* entries;
    if (dwg_dynapi_entity_value(layer_index, "LAYER_INDEX", "entries", &entries, NULL)
        && !memcmp(&entries, &layer_index->entries, sizeof(layer_index->entries)))
      pass ("LAYER_INDEX.entries");
    else
      {
        fail ("LAYER_INDEX.entries"); error++;
      }
  }
  {
    BITCODE_H* entry_handles;
    if (dwg_dynapi_entity_value(layer_index, "LAYER_INDEX", "entry_handles", &entry_handles, NULL)
        && !memcmp(&entry_handles, &layer_index->entry_handles, sizeof(layer_index->entry_handles)))
      pass ("LAYER_INDEX.entry_handles");
    else
      {
        fail ("LAYER_INDEX.entry_handles"); error++;
      }
  }
  {
    BITCODE_BL num_entries;
    if (dwg_dynapi_entity_value(layer_index, "LAYER_INDEX", "num_entries", &num_entries, NULL) &&
        num_entries == layer_index->num_entries)
      pass ("LAYER_INDEX.num_entries [BL]");
    else
      {
        fail ("LAYER_INDEX.num_entries [BL] %u != %u", layer_index->num_entries, num_entries); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(layer_index, "LAYER_INDEX", "ownerhandle", &ownerhandle, NULL) &&
        ownerhandle == layer_index->ownerhandle)
      pass ("LAYER_INDEX.ownerhandle [H]");
    else
      {
        fail ("LAYER_INDEX.ownerhandle [H] %p != %p", layer_index->ownerhandle, ownerhandle); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(layer_index, "LAYER_INDEX", "parent", &parent, NULL)
        && !memcmp(&parent, &layer_index->parent, sizeof(layer_index->parent)))
      pass ("LAYER_INDEX.parent");
    else
      {
        fail ("LAYER_INDEX.parent"); error++;
      }
  }
  {
    BITCODE_BL timestamp1;
    if (dwg_dynapi_entity_value(layer_index, "LAYER_INDEX", "timestamp1", &timestamp1, NULL) &&
        timestamp1 == layer_index->timestamp1)
      pass ("LAYER_INDEX.timestamp1 [BL]");
    else
      {
        fail ("LAYER_INDEX.timestamp1 [BL] %u != %u", layer_index->timestamp1, timestamp1); error++;
      }
  }
  {
    BITCODE_BL timestamp2;
    if (dwg_dynapi_entity_value(layer_index, "LAYER_INDEX", "timestamp2", &timestamp2, NULL) &&
        timestamp2 == layer_index->timestamp2)
      pass ("LAYER_INDEX.timestamp2 [BL]");
    else
      {
        fail ("LAYER_INDEX.timestamp2 [BL] %u != %u", layer_index->timestamp2, timestamp2); error++;
      }
  }
  return error;
}
static int test_LAYOUT (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_LAYOUT *layout = obj->tio.object->tio.LAYOUT;
  {
    BITCODE_H base_ucs;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "base_ucs", &base_ucs, NULL) &&
        base_ucs == layout->base_ucs)
      pass ("LAYOUT.base_ucs [H]");
    else
      {
        fail ("LAYOUT.base_ucs [H] %p != %p", layout->base_ucs, base_ucs); error++;
      }
  }
  {
    BITCODE_BD bottom_margin;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "bottom_margin", &bottom_margin, NULL) &&
        bottom_margin == layout->bottom_margin)
      pass ("LAYOUT.bottom_margin [BD]");
    else
      {
        fail ("LAYOUT.bottom_margin [BD] %g != %g", layout->bottom_margin, bottom_margin); error++;
      }
  }
  {
    BITCODE_TV current_style_sheet;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "current_style_sheet", &current_style_sheet, NULL)
        && !strcmp((char*)&current_style_sheet, (char*)&layout->current_style_sheet))
      pass ("LAYOUT.current_style_sheet");
    else
      {
        fail ("LAYOUT.current_style_sheet"); error++;
      }
  }
  {
    BITCODE_BD drawing_units;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "drawing_units", &drawing_units, NULL) &&
        drawing_units == layout->drawing_units)
      pass ("LAYOUT.drawing_units [BD]");
    else
      {
        fail ("LAYOUT.drawing_units [BD] %g != %g", layout->drawing_units, drawing_units); error++;
      }
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "elevation", &elevation, NULL) &&
        elevation == layout->elevation)
      pass ("LAYOUT.elevation [BD]");
    else
      {
        fail ("LAYOUT.elevation [BD] %g != %g", layout->elevation, elevation); error++;
      }
  }
  {
    BITCODE_3DPOINT extent_max;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "extent_max", &extent_max, NULL)
        && !memcmp(&extent_max, &layout->extent_max, sizeof(layout->extent_max)))
      pass ("LAYOUT.extent_max");
    else
      {
        fail ("LAYOUT.extent_max"); error++;
      }
  }
  {
    BITCODE_3DPOINT extent_min;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "extent_min", &extent_min, NULL)
        && !memcmp(&extent_min, &layout->extent_min, sizeof(layout->extent_min)))
      pass ("LAYOUT.extent_min");
    else
      {
        fail ("LAYOUT.extent_min"); error++;
      }
  }
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "flag", &flag, NULL) &&
        flag == layout->flag)
      pass ("LAYOUT.flag [BS]");
    else
      {
        fail ("LAYOUT.flag [BS] %d != %d", layout->flag, flag); error++;
      }
  }
  {
    BITCODE_3DPOINT ins_point;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "ins_point", &ins_point, NULL)
        && !memcmp(&ins_point, &layout->ins_point, sizeof(layout->ins_point)))
      pass ("LAYOUT.ins_point");
    else
      {
        fail ("LAYOUT.ins_point"); error++;
      }
  }
  {
    BITCODE_H last_viewport;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "last_viewport", &last_viewport, NULL) &&
        last_viewport == layout->last_viewport)
      pass ("LAYOUT.last_viewport [H]");
    else
      {
        fail ("LAYOUT.last_viewport [H] %p != %p", layout->last_viewport, last_viewport); error++;
      }
  }
  {
    BITCODE_TV layout_name;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "layout_name", &layout_name, NULL)
        && !strcmp((char*)&layout_name, (char*)&layout->layout_name))
      pass ("LAYOUT.layout_name");
    else
      {
        fail ("LAYOUT.layout_name"); error++;
      }
  }
  {
    BITCODE_BD left_margin;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "left_margin", &left_margin, NULL) &&
        left_margin == layout->left_margin)
      pass ("LAYOUT.left_margin [BD]");
    else
      {
        fail ("LAYOUT.left_margin [BD] %g != %g", layout->left_margin, left_margin); error++;
      }
  }
  {
    BITCODE_2DPOINT maximum_limits;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "maximum_limits", &maximum_limits, NULL)
        && !memcmp(&maximum_limits, &layout->maximum_limits, sizeof(layout->maximum_limits)))
      pass ("LAYOUT.maximum_limits");
    else
      {
        fail ("LAYOUT.maximum_limits"); error++;
      }
  }
  {
    BITCODE_2DPOINT minimum_limits;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "minimum_limits", &minimum_limits, NULL)
        && !memcmp(&minimum_limits, &layout->minimum_limits, sizeof(layout->minimum_limits)))
      pass ("LAYOUT.minimum_limits");
    else
      {
        fail ("LAYOUT.minimum_limits"); error++;
      }
  }
  {
    BITCODE_H named_ucs;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "named_ucs", &named_ucs, NULL) &&
        named_ucs == layout->named_ucs)
      pass ("LAYOUT.named_ucs [H]");
    else
      {
        fail ("LAYOUT.named_ucs [H] %p != %p", layout->named_ucs, named_ucs); error++;
      }
  }
  {
    BITCODE_RL num_viewports;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "num_viewports", &num_viewports, NULL) &&
        num_viewports == layout->num_viewports)
      pass ("LAYOUT.num_viewports [RL]");
    else
      {
        fail ("LAYOUT.num_viewports [RL] " FORMAT_RL " != " FORMAT_RL "", layout->num_viewports, num_viewports); error++;
      }
  }
  {
    BITCODE_BS orthoview_type;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "orthoview_type", &orthoview_type, NULL) &&
        orthoview_type == layout->orthoview_type)
      pass ("LAYOUT.orthoview_type [BS]");
    else
      {
        fail ("LAYOUT.orthoview_type [BS] %d != %d", layout->orthoview_type, orthoview_type); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "ownerhandle", &ownerhandle, NULL) &&
        ownerhandle == layout->ownerhandle)
      pass ("LAYOUT.ownerhandle [H]");
    else
      {
        fail ("LAYOUT.ownerhandle [H] %p != %p", layout->ownerhandle, ownerhandle); error++;
      }
  }
  {
    BITCODE_TV page_setup_name;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "page_setup_name", &page_setup_name, NULL)
        && !strcmp((char*)&page_setup_name, (char*)&layout->page_setup_name))
      pass ("LAYOUT.page_setup_name");
    else
      {
        fail ("LAYOUT.page_setup_name"); error++;
      }
  }
  {
    BITCODE_BD paper_height;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "paper_height", &paper_height, NULL) &&
        paper_height == layout->paper_height)
      pass ("LAYOUT.paper_height [BD]");
    else
      {
        fail ("LAYOUT.paper_height [BD] %g != %g", layout->paper_height, paper_height); error++;
      }
  }
  {
    BITCODE_2DPOINT paper_image_origin;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "paper_image_origin", &paper_image_origin, NULL)
        && !memcmp(&paper_image_origin, &layout->paper_image_origin, sizeof(layout->paper_image_origin)))
      pass ("LAYOUT.paper_image_origin");
    else
      {
        fail ("LAYOUT.paper_image_origin"); error++;
      }
  }
  {
    BITCODE_TV paper_size;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "paper_size", &paper_size, NULL)
        && !strcmp((char*)&paper_size, (char*)&layout->paper_size))
      pass ("LAYOUT.paper_size");
    else
      {
        fail ("LAYOUT.paper_size"); error++;
      }
  }
  {
    BITCODE_BS paper_units;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "paper_units", &paper_units, NULL) &&
        paper_units == layout->paper_units)
      pass ("LAYOUT.paper_units [BS]");
    else
      {
        fail ("LAYOUT.paper_units [BS] %d != %d", layout->paper_units, paper_units); error++;
      }
  }
  {
    BITCODE_BD paper_width;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "paper_width", &paper_width, NULL) &&
        paper_width == layout->paper_width)
      pass ("LAYOUT.paper_width [BD]");
    else
      {
        fail ("LAYOUT.paper_width [BD] %g != %g", layout->paper_width, paper_width); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "parent", &parent, NULL)
        && !memcmp(&parent, &layout->parent, sizeof(layout->parent)))
      pass ("LAYOUT.parent");
    else
      {
        fail ("LAYOUT.parent"); error++;
      }
  }
  {
    BITCODE_BS plot_layout_flags;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "plot_layout_flags", &plot_layout_flags, NULL) &&
        plot_layout_flags == layout->plot_layout_flags)
      pass ("LAYOUT.plot_layout_flags [BS]");
    else
      {
        fail ("LAYOUT.plot_layout_flags [BS] %d != %d", layout->plot_layout_flags, plot_layout_flags); error++;
      }
  }
  {
    BITCODE_2DPOINT plot_origin;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "plot_origin", &plot_origin, NULL)
        && !memcmp(&plot_origin, &layout->plot_origin, sizeof(layout->plot_origin)))
      pass ("LAYOUT.plot_origin");
    else
      {
        fail ("LAYOUT.plot_origin"); error++;
      }
  }
  {
    BITCODE_BS plot_rotation;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "plot_rotation", &plot_rotation, NULL) &&
        plot_rotation == layout->plot_rotation)
      pass ("LAYOUT.plot_rotation [BS]");
    else
      {
        fail ("LAYOUT.plot_rotation [BS] %d != %d", layout->plot_rotation, plot_rotation); error++;
      }
  }
  {
    BITCODE_BS plot_type;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "plot_type", &plot_type, NULL) &&
        plot_type == layout->plot_type)
      pass ("LAYOUT.plot_type [BS]");
    else
      {
        fail ("LAYOUT.plot_type [BS] %d != %d", layout->plot_type, plot_type); error++;
      }
  }
  {
    BITCODE_H plot_view;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "plot_view", &plot_view, NULL) &&
        plot_view == layout->plot_view)
      pass ("LAYOUT.plot_view [H]");
    else
      {
        fail ("LAYOUT.plot_view [H] %p != %p", layout->plot_view, plot_view); error++;
      }
  }
  {
    BITCODE_TV plot_view_name;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "plot_view_name", &plot_view_name, NULL)
        && !strcmp((char*)&plot_view_name, (char*)&layout->plot_view_name))
      pass ("LAYOUT.plot_view_name");
    else
      {
        fail ("LAYOUT.plot_view_name"); error++;
      }
  }
  {
    BITCODE_TV printer_or_config;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "printer_or_config", &printer_or_config, NULL)
        && !strcmp((char*)&printer_or_config, (char*)&layout->printer_or_config))
      pass ("LAYOUT.printer_or_config");
    else
      {
        fail ("LAYOUT.printer_or_config"); error++;
      }
  }
  {
    BITCODE_H pspace_block_record;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "pspace_block_record", &pspace_block_record, NULL) &&
        pspace_block_record == layout->pspace_block_record)
      pass ("LAYOUT.pspace_block_record [H]");
    else
      {
        fail ("LAYOUT.pspace_block_record [H] %p != %p", layout->pspace_block_record, pspace_block_record); error++;
      }
  }
  {
    BITCODE_BD real_world_units;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "real_world_units", &real_world_units, NULL) &&
        real_world_units == layout->real_world_units)
      pass ("LAYOUT.real_world_units [BD]");
    else
      {
        fail ("LAYOUT.real_world_units [BD] %g != %g", layout->real_world_units, real_world_units); error++;
      }
  }
  {
    BITCODE_BD right_margin;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "right_margin", &right_margin, NULL) &&
        right_margin == layout->right_margin)
      pass ("LAYOUT.right_margin [BD]");
    else
      {
        fail ("LAYOUT.right_margin [BD] %g != %g", layout->right_margin, right_margin); error++;
      }
  }
  {
    BITCODE_BD scale_factor;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "scale_factor", &scale_factor, NULL) &&
        scale_factor == layout->scale_factor)
      pass ("LAYOUT.scale_factor [BD]");
    else
      {
        fail ("LAYOUT.scale_factor [BD] %g != %g", layout->scale_factor, scale_factor); error++;
      }
  }
  {
    BITCODE_BS scale_type;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "scale_type", &scale_type, NULL) &&
        scale_type == layout->scale_type)
      pass ("LAYOUT.scale_type [BS]");
    else
      {
        fail ("LAYOUT.scale_type [BS] %d != %d", layout->scale_type, scale_type); error++;
      }
  }
  {
    BITCODE_BS shade_plot_custom_dpi;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "shade_plot_custom_dpi", &shade_plot_custom_dpi, NULL) &&
        shade_plot_custom_dpi == layout->shade_plot_custom_dpi)
      pass ("LAYOUT.shade_plot_custom_dpi [BS]");
    else
      {
        fail ("LAYOUT.shade_plot_custom_dpi [BS] %d != %d", layout->shade_plot_custom_dpi, shade_plot_custom_dpi); error++;
      }
  }
  {
    BITCODE_BS shade_plot_mode;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "shade_plot_mode", &shade_plot_mode, NULL) &&
        shade_plot_mode == layout->shade_plot_mode)
      pass ("LAYOUT.shade_plot_mode [BS]");
    else
      {
        fail ("LAYOUT.shade_plot_mode [BS] %d != %d", layout->shade_plot_mode, shade_plot_mode); error++;
      }
  }
  {
    BITCODE_BS shade_plot_res_level;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "shade_plot_res_level", &shade_plot_res_level, NULL) &&
        shade_plot_res_level == layout->shade_plot_res_level)
      pass ("LAYOUT.shade_plot_res_level [BS]");
    else
      {
        fail ("LAYOUT.shade_plot_res_level [BS] %d != %d", layout->shade_plot_res_level, shade_plot_res_level); error++;
      }
  }
  {
    BITCODE_BS tab_order;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "tab_order", &tab_order, NULL) &&
        tab_order == layout->tab_order)
      pass ("LAYOUT.tab_order [BS]");
    else
      {
        fail ("LAYOUT.tab_order [BS] %d != %d", layout->tab_order, tab_order); error++;
      }
  }
  {
    BITCODE_BD top_margin;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "top_margin", &top_margin, NULL) &&
        top_margin == layout->top_margin)
      pass ("LAYOUT.top_margin [BD]");
    else
      {
        fail ("LAYOUT.top_margin [BD] %g != %g", layout->top_margin, top_margin); error++;
      }
  }
  {
    BITCODE_3DPOINT ucs_origin;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "ucs_origin", &ucs_origin, NULL)
        && !memcmp(&ucs_origin, &layout->ucs_origin, sizeof(layout->ucs_origin)))
      pass ("LAYOUT.ucs_origin");
    else
      {
        fail ("LAYOUT.ucs_origin"); error++;
      }
  }
  {
    BITCODE_3DPOINT ucs_x_axis;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "ucs_x_axis", &ucs_x_axis, NULL)
        && !memcmp(&ucs_x_axis, &layout->ucs_x_axis, sizeof(layout->ucs_x_axis)))
      pass ("LAYOUT.ucs_x_axis");
    else
      {
        fail ("LAYOUT.ucs_x_axis"); error++;
      }
  }
  {
    BITCODE_3DPOINT ucs_y_axis;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "ucs_y_axis", &ucs_y_axis, NULL)
        && !memcmp(&ucs_y_axis, &layout->ucs_y_axis, sizeof(layout->ucs_y_axis)))
      pass ("LAYOUT.ucs_y_axis");
    else
      {
        fail ("LAYOUT.ucs_y_axis"); error++;
      }
  }
  {
    BITCODE_H* viewports;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "viewports", &viewports, NULL)
        && !memcmp(&viewports, &layout->viewports, sizeof(layout->viewports)))
      pass ("LAYOUT.viewports");
    else
      {
        fail ("LAYOUT.viewports"); error++;
      }
  }
  {
    BITCODE_H visual_style;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "visual_style", &visual_style, NULL) &&
        visual_style == layout->visual_style)
      pass ("LAYOUT.visual_style [H]");
    else
      {
        fail ("LAYOUT.visual_style [H] %p != %p", layout->visual_style, visual_style); error++;
      }
  }
  {
    BITCODE_2DPOINT window_max;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "window_max", &window_max, NULL)
        && !memcmp(&window_max, &layout->window_max, sizeof(layout->window_max)))
      pass ("LAYOUT.window_max");
    else
      {
        fail ("LAYOUT.window_max"); error++;
      }
  }
  {
    BITCODE_2DPOINT window_min;
    if (dwg_dynapi_entity_value(layout, "LAYOUT", "window_min", &window_min, NULL)
        && !memcmp(&window_min, &layout->window_min, sizeof(layout->window_min)))
      pass ("LAYOUT.window_min");
    else
      {
        fail ("LAYOUT.window_min"); error++;
      }
  }
  return error;
}
static int test_LIGHTLIST (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_LIGHTLIST *lightlist = obj->tio.object->tio.LIGHTLIST;
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value(lightlist, "LIGHTLIST", "class_version", &class_version, NULL) &&
        class_version == lightlist->class_version)
      pass ("LIGHTLIST.class_version [BS]");
    else
      {
        fail ("LIGHTLIST.class_version [BS] %d != %d", lightlist->class_version, class_version); error++;
      }
  }
  {
    BITCODE_H* dictionary;
    if (dwg_dynapi_entity_value(lightlist, "LIGHTLIST", "dictionary", &dictionary, NULL)
        && !memcmp(&dictionary, &lightlist->dictionary, sizeof(lightlist->dictionary)))
      pass ("LIGHTLIST.dictionary");
    else
      {
        fail ("LIGHTLIST.dictionary"); error++;
      }
  }
  {
    BITCODE_H light_handle;
    if (dwg_dynapi_entity_value(lightlist, "LIGHTLIST", "light_handle", &light_handle, NULL) &&
        light_handle == lightlist->light_handle)
      pass ("LIGHTLIST.light_handle [H]");
    else
      {
        fail ("LIGHTLIST.light_handle [H] %p != %p", lightlist->light_handle, light_handle); error++;
      }
  }
  {
    BITCODE_TV light_name;
    if (dwg_dynapi_entity_value(lightlist, "LIGHTLIST", "light_name", &light_name, NULL)
        && !strcmp((char*)&light_name, (char*)&lightlist->light_name))
      pass ("LIGHTLIST.light_name");
    else
      {
        fail ("LIGHTLIST.light_name"); error++;
      }
  }
  {
    BITCODE_BS num_lights;
    if (dwg_dynapi_entity_value(lightlist, "LIGHTLIST", "num_lights", &num_lights, NULL) &&
        num_lights == lightlist->num_lights)
      pass ("LIGHTLIST.num_lights [BS]");
    else
      {
        fail ("LIGHTLIST.num_lights [BS] %d != %d", lightlist->num_lights, num_lights); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(lightlist, "LIGHTLIST", "parent", &parent, NULL)
        && !memcmp(&parent, &lightlist->parent, sizeof(lightlist->parent)))
      pass ("LIGHTLIST.parent");
    else
      {
        fail ("LIGHTLIST.parent"); error++;
      }
  }
  return error;
}
static int test_LONG_TRANSACTION (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_LONG_TRANSACTION *long_transaction = obj->tio.object->tio.LONG_TRANSACTION;
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(long_transaction, "LONG_TRANSACTION", "parent", &parent, NULL)
        && !memcmp(&parent, &long_transaction->parent, sizeof(long_transaction->parent)))
      pass ("LONG_TRANSACTION.parent");
    else
      {
        fail ("LONG_TRANSACTION.parent"); error++;
      }
  }
  return error;
}
static int test_LTYPE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_LTYPE *ltype = obj->tio.object->tio.LTYPE;
  {
    BITCODE_RC alignment;
    if (dwg_dynapi_entity_value(ltype, "LTYPE", "alignment", &alignment, NULL) &&
        alignment == ltype->alignment)
      pass ("LTYPE.alignment [RC]");
    else
      {
        fail ("LTYPE.alignment [RC] %c != %c", ltype->alignment, alignment); error++;
      }
  }
  {
    Dwg_LTYPE_dash* dash;
    if (dwg_dynapi_entity_value(ltype, "LTYPE", "dash", &dash, NULL)
        && !memcmp(&dash, &ltype->dash, sizeof(ltype->dash)))
      pass ("LTYPE.dash");
    else
      {
        fail ("LTYPE.dash"); error++;
      }
  }
  {
    BITCODE_RD* dashes_r11;
    if (dwg_dynapi_entity_value(ltype, "LTYPE", "dashes_r11", &dashes_r11, NULL)
        && !memcmp(&dashes_r11, &ltype->dashes_r11, sizeof(ltype->dashes_r11)))
      pass ("LTYPE.dashes_r11");
    else
      {
        fail ("LTYPE.dashes_r11"); error++;
      }
  }
  {
    BITCODE_TV description;
    if (dwg_dynapi_entity_value(ltype, "LTYPE", "description", &description, NULL)
        && !strcmp((char*)&description, (char*)&ltype->description))
      pass ("LTYPE.description");
    else
      {
        fail ("LTYPE.description"); error++;
      }
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value(ltype, "LTYPE", "flag", &flag, NULL) &&
        flag == ltype->flag)
      pass ("LTYPE.flag [RC]");
    else
      {
        fail ("LTYPE.flag [RC] %c != %c", ltype->flag, flag); error++;
      }
  }
  {
    BITCODE_H linetype_control;
    if (dwg_dynapi_entity_value(ltype, "LTYPE", "linetype_control", &linetype_control, NULL) &&
        linetype_control == ltype->linetype_control)
      pass ("LTYPE.linetype_control [H]");
    else
      {
        fail ("LTYPE.linetype_control [H] %p != %p", ltype->linetype_control, linetype_control); error++;
      }
  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value(ltype, "LTYPE", "name", &name, NULL)
        && !strcmp((char*)&name, (char*)&ltype->name))
      pass ("LTYPE.name");
    else
      {
        fail ("LTYPE.name"); error++;
      }
  }
  {
    BITCODE_H null_handle;
    if (dwg_dynapi_entity_value(ltype, "LTYPE", "null_handle", &null_handle, NULL) &&
        null_handle == ltype->null_handle)
      pass ("LTYPE.null_handle [H]");
    else
      {
        fail ("LTYPE.null_handle [H] %p != %p", ltype->null_handle, null_handle); error++;
      }
  }
  {
    BITCODE_RC num_dashes;
    if (dwg_dynapi_entity_value(ltype, "LTYPE", "num_dashes", &num_dashes, NULL) &&
        num_dashes == ltype->num_dashes)
      pass ("LTYPE.num_dashes [RC]");
    else
      {
        fail ("LTYPE.num_dashes [RC] %c != %c", ltype->num_dashes, num_dashes); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(ltype, "LTYPE", "parent", &parent, NULL)
        && !memcmp(&parent, &ltype->parent, sizeof(ltype->parent)))
      pass ("LTYPE.parent");
    else
      {
        fail ("LTYPE.parent"); error++;
      }
  }
  {
    BITCODE_BD pattern_len;
    if (dwg_dynapi_entity_value(ltype, "LTYPE", "pattern_len", &pattern_len, NULL) &&
        pattern_len == ltype->pattern_len)
      pass ("LTYPE.pattern_len [BD]");
    else
      {
        fail ("LTYPE.pattern_len [BD] %g != %g", ltype->pattern_len, pattern_len); error++;
      }
  }
  {
    BITCODE_TV strings_area;
    if (dwg_dynapi_entity_value(ltype, "LTYPE", "strings_area", &strings_area, NULL)
        && !strcmp((char*)&strings_area, (char*)&ltype->strings_area))
      pass ("LTYPE.strings_area");
    else
      {
        fail ("LTYPE.strings_area"); error++;
      }
  }
  {
    BITCODE_H* styles;
    if (dwg_dynapi_entity_value(ltype, "LTYPE", "styles", &styles, NULL)
        && !memcmp(&styles, &ltype->styles, sizeof(ltype->styles)))
      pass ("LTYPE.styles");
    else
      {
        fail ("LTYPE.styles"); error++;
      }
  }
  {
    BITCODE_B text_area_is_present;
    if (dwg_dynapi_entity_value(ltype, "LTYPE", "text_area_is_present", &text_area_is_present, NULL) &&
        text_area_is_present == ltype->text_area_is_present)
      pass ("LTYPE.text_area_is_present [B]");
    else
      {
        fail ("LTYPE.text_area_is_present [B] " FORMAT_B " != " FORMAT_B "", ltype->text_area_is_present, text_area_is_present); error++;
      }
  }
  {
    BITCODE_RS used;
    if (dwg_dynapi_entity_value(ltype, "LTYPE", "used", &used, NULL) &&
        used == ltype->used)
      pass ("LTYPE.used [RS]");
    else
      {
        fail ("LTYPE.used [RS] " FORMAT_RS " != " FORMAT_RS "", ltype->used, used); error++;
      }
  }
  {
    BITCODE_B xrefdep;
    if (dwg_dynapi_entity_value(ltype, "LTYPE", "xrefdep", &xrefdep, NULL) &&
        xrefdep == ltype->xrefdep)
      pass ("LTYPE.xrefdep [B]");
    else
      {
        fail ("LTYPE.xrefdep [B] " FORMAT_B " != " FORMAT_B "", ltype->xrefdep, xrefdep); error++;
      }
  }
  {
    BITCODE_BS xrefindex_plus1;
    if (dwg_dynapi_entity_value(ltype, "LTYPE", "xrefindex_plus1", &xrefindex_plus1, NULL) &&
        xrefindex_plus1 == ltype->xrefindex_plus1)
      pass ("LTYPE.xrefindex_plus1 [BS]");
    else
      {
        fail ("LTYPE.xrefindex_plus1 [BS] %d != %d", ltype->xrefindex_plus1, xrefindex_plus1); error++;
      }
  }
  {
    BITCODE_B xrefref;
    if (dwg_dynapi_entity_value(ltype, "LTYPE", "xrefref", &xrefref, NULL) &&
        xrefref == ltype->xrefref)
      pass ("LTYPE.xrefref [B]");
    else
      {
        fail ("LTYPE.xrefref [B] " FORMAT_B " != " FORMAT_B "", ltype->xrefref, xrefref); error++;
      }
  }
  return error;
}
static int test_LTYPE_CONTROL (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_LTYPE_CONTROL *ltype_control = obj->tio.object->tio.LTYPE_CONTROL;
  {
    BITCODE_H byblock;
    if (dwg_dynapi_entity_value(ltype_control, "LTYPE_CONTROL", "byblock", &byblock, NULL) &&
        byblock == ltype_control->byblock)
      pass ("LTYPE_CONTROL.byblock [H]");
    else
      {
        fail ("LTYPE_CONTROL.byblock [H] %p != %p", ltype_control->byblock, byblock); error++;
      }
  }
  {
    BITCODE_H bylayer;
    if (dwg_dynapi_entity_value(ltype_control, "LTYPE_CONTROL", "bylayer", &bylayer, NULL) &&
        bylayer == ltype_control->bylayer)
      pass ("LTYPE_CONTROL.bylayer [H]");
    else
      {
        fail ("LTYPE_CONTROL.bylayer [H] %p != %p", ltype_control->bylayer, bylayer); error++;
      }
  }
  {
    Dwg_Object_Ref* linetypes;
    if (dwg_dynapi_entity_value(ltype_control, "LTYPE_CONTROL", "linetypes", &linetypes, NULL)
        && !memcmp(&linetypes, &ltype_control->linetypes, sizeof(ltype_control->linetypes)))
      pass ("LTYPE_CONTROL.linetypes");
    else
      {
        fail ("LTYPE_CONTROL.linetypes"); error++;
      }
  }
  {
    Dwg_Object_Ref* null_handle;
    if (dwg_dynapi_entity_value(ltype_control, "LTYPE_CONTROL", "null_handle", &null_handle, NULL)
        && !memcmp(&null_handle, &ltype_control->null_handle, sizeof(ltype_control->null_handle)))
      pass ("LTYPE_CONTROL.null_handle");
    else
      {
        fail ("LTYPE_CONTROL.null_handle"); error++;
      }
  }
  {
    BITCODE_BS num_entries;
    if (dwg_dynapi_entity_value(ltype_control, "LTYPE_CONTROL", "num_entries", &num_entries, NULL) &&
        num_entries == ltype_control->num_entries)
      pass ("LTYPE_CONTROL.num_entries [BS]");
    else
      {
        fail ("LTYPE_CONTROL.num_entries [BS] %d != %d", ltype_control->num_entries, num_entries); error++;
      }
  }
  {
    BITCODE_BL objid;
    if (dwg_dynapi_entity_value(ltype_control, "LTYPE_CONTROL", "objid", &objid, NULL) &&
        objid == ltype_control->objid)
      pass ("LTYPE_CONTROL.objid [BL]");
    else
      {
        fail ("LTYPE_CONTROL.objid [BL] %u != %u", ltype_control->objid, objid); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(ltype_control, "LTYPE_CONTROL", "parent", &parent, NULL)
        && !memcmp(&parent, &ltype_control->parent, sizeof(ltype_control->parent)))
      pass ("LTYPE_CONTROL.parent");
    else
      {
        fail ("LTYPE_CONTROL.parent"); error++;
      }
  }
  {
    Dwg_Object_Ref* reactors;
    if (dwg_dynapi_entity_value(ltype_control, "LTYPE_CONTROL", "reactors", &reactors, NULL)
        && !memcmp(&reactors, &ltype_control->reactors, sizeof(ltype_control->reactors)))
      pass ("LTYPE_CONTROL.reactors");
    else
      {
        fail ("LTYPE_CONTROL.reactors"); error++;
      }
  }
  {
    Dwg_Object_Ref* xdicobjhandle;
    if (dwg_dynapi_entity_value(ltype_control, "LTYPE_CONTROL", "xdicobjhandle", &xdicobjhandle, NULL)
        && !memcmp(&xdicobjhandle, &ltype_control->xdicobjhandle, sizeof(ltype_control->xdicobjhandle)))
      pass ("LTYPE_CONTROL.xdicobjhandle");
    else
      {
        fail ("LTYPE_CONTROL.xdicobjhandle"); error++;
      }
  }
  return error;
}
static int test_MATERIAL (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_MATERIAL *material = obj->tio.object->tio.MATERIAL;
  {
    BITCODE_CMC ambient_color;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "ambient_color", &ambient_color, NULL)
        && !memcmp(&ambient_color, &material->ambient_color, sizeof(material->ambient_color)))
      pass ("MATERIAL.ambient_color");
    else
      {
        fail ("MATERIAL.ambient_color"); error++;
      }
  }
  {
    BITCODE_BD ambient_color_factor;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "ambient_color_factor", &ambient_color_factor, NULL) &&
        ambient_color_factor == material->ambient_color_factor)
      pass ("MATERIAL.ambient_color_factor [BD]");
    else
      {
        fail ("MATERIAL.ambient_color_factor [BD] %g != %g", material->ambient_color_factor, ambient_color_factor); error++;
      }
  }
  {
    BITCODE_BS ambient_color_flag;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "ambient_color_flag", &ambient_color_flag, NULL) &&
        ambient_color_flag == material->ambient_color_flag)
      pass ("MATERIAL.ambient_color_flag [BS]");
    else
      {
        fail ("MATERIAL.ambient_color_flag [BS] %d != %d", material->ambient_color_flag, ambient_color_flag); error++;
      }
  }
  {
    BITCODE_BS bumpmap_autotransform;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "bumpmap_autotransform", &bumpmap_autotransform, NULL) &&
        bumpmap_autotransform == material->bumpmap_autotransform)
      pass ("MATERIAL.bumpmap_autotransform [BS]");
    else
      {
        fail ("MATERIAL.bumpmap_autotransform [BS] %d != %d", material->bumpmap_autotransform, bumpmap_autotransform); error++;
      }
  }
  {
    BITCODE_BD bumpmap_blendfactor;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "bumpmap_blendfactor", &bumpmap_blendfactor, NULL) &&
        bumpmap_blendfactor == material->bumpmap_blendfactor)
      pass ("MATERIAL.bumpmap_blendfactor [BD]");
    else
      {
        fail ("MATERIAL.bumpmap_blendfactor [BD] %g != %g", material->bumpmap_blendfactor, bumpmap_blendfactor); error++;
      }
  }
  {
    BITCODE_T bumpmap_filename;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "bumpmap_filename", &bumpmap_filename, NULL)
        && !memcmp(&bumpmap_filename, &material->bumpmap_filename, sizeof(material->bumpmap_filename)))
      pass ("MATERIAL.bumpmap_filename");
    else
      {
        fail ("MATERIAL.bumpmap_filename"); error++;
      }
  }
  {
    BITCODE_BS bumpmap_projection;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "bumpmap_projection", &bumpmap_projection, NULL) &&
        bumpmap_projection == material->bumpmap_projection)
      pass ("MATERIAL.bumpmap_projection [BS]");
    else
      {
        fail ("MATERIAL.bumpmap_projection [BS] %d != %d", material->bumpmap_projection, bumpmap_projection); error++;
      }
  }
  {
    BITCODE_BS bumpmap_source;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "bumpmap_source", &bumpmap_source, NULL) &&
        bumpmap_source == material->bumpmap_source)
      pass ("MATERIAL.bumpmap_source [BS]");
    else
      {
        fail ("MATERIAL.bumpmap_source [BS] %d != %d", material->bumpmap_source, bumpmap_source); error++;
      }
  }
  {
    BITCODE_BS bumpmap_tiling;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "bumpmap_tiling", &bumpmap_tiling, NULL) &&
        bumpmap_tiling == material->bumpmap_tiling)
      pass ("MATERIAL.bumpmap_tiling [BS]");
    else
      {
        fail ("MATERIAL.bumpmap_tiling [BS] %d != %d", material->bumpmap_tiling, bumpmap_tiling); error++;
      }
  }
  {
    BITCODE_BD* bumpmap_transmatrix;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "bumpmap_transmatrix", &bumpmap_transmatrix, NULL)
        && !memcmp(&bumpmap_transmatrix, &material->bumpmap_transmatrix, sizeof(material->bumpmap_transmatrix)))
      pass ("MATERIAL.bumpmap_transmatrix");
    else
      {
        fail ("MATERIAL.bumpmap_transmatrix"); error++;
      }
  }
  {
    BITCODE_BL channel_flags;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "channel_flags", &channel_flags, NULL) &&
        channel_flags == material->channel_flags)
      pass ("MATERIAL.channel_flags [BL]");
    else
      {
        fail ("MATERIAL.channel_flags [BL] %u != %u", material->channel_flags, channel_flags); error++;
      }
  }
  {
    BITCODE_BD color_bleed_scale;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "color_bleed_scale", &color_bleed_scale, NULL) &&
        color_bleed_scale == material->color_bleed_scale)
      pass ("MATERIAL.color_bleed_scale [BD]");
    else
      {
        fail ("MATERIAL.color_bleed_scale [BD] %g != %g", material->color_bleed_scale, color_bleed_scale); error++;
      }
  }
  {
    BITCODE_T desc;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "desc", &desc, NULL)
        && !memcmp(&desc, &material->desc, sizeof(material->desc)))
      pass ("MATERIAL.desc");
    else
      {
        fail ("MATERIAL.desc"); error++;
      }
  }
  {
    BITCODE_CMC diffuse_color;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "diffuse_color", &diffuse_color, NULL)
        && !memcmp(&diffuse_color, &material->diffuse_color, sizeof(material->diffuse_color)))
      pass ("MATERIAL.diffuse_color");
    else
      {
        fail ("MATERIAL.diffuse_color"); error++;
      }
  }
  {
    BITCODE_BD diffuse_color_factor;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "diffuse_color_factor", &diffuse_color_factor, NULL) &&
        diffuse_color_factor == material->diffuse_color_factor)
      pass ("MATERIAL.diffuse_color_factor [BD]");
    else
      {
        fail ("MATERIAL.diffuse_color_factor [BD] %g != %g", material->diffuse_color_factor, diffuse_color_factor); error++;
      }
  }
  {
    BITCODE_BS diffuse_color_flag;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "diffuse_color_flag", &diffuse_color_flag, NULL) &&
        diffuse_color_flag == material->diffuse_color_flag)
      pass ("MATERIAL.diffuse_color_flag [BS]");
    else
      {
        fail ("MATERIAL.diffuse_color_flag [BS] %d != %d", material->diffuse_color_flag, diffuse_color_flag); error++;
      }
  }
  {
    BITCODE_BS diffusemap_autotransform;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "diffusemap_autotransform", &diffusemap_autotransform, NULL) &&
        diffusemap_autotransform == material->diffusemap_autotransform)
      pass ("MATERIAL.diffusemap_autotransform [BS]");
    else
      {
        fail ("MATERIAL.diffusemap_autotransform [BS] %d != %d", material->diffusemap_autotransform, diffusemap_autotransform); error++;
      }
  }
  {
    BITCODE_BD diffusemap_blendfactor;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "diffusemap_blendfactor", &diffusemap_blendfactor, NULL) &&
        diffusemap_blendfactor == material->diffusemap_blendfactor)
      pass ("MATERIAL.diffusemap_blendfactor [BD]");
    else
      {
        fail ("MATERIAL.diffusemap_blendfactor [BD] %g != %g", material->diffusemap_blendfactor, diffusemap_blendfactor); error++;
      }
  }
  {
    BITCODE_T diffusemap_filename;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "diffusemap_filename", &diffusemap_filename, NULL)
        && !memcmp(&diffusemap_filename, &material->diffusemap_filename, sizeof(material->diffusemap_filename)))
      pass ("MATERIAL.diffusemap_filename");
    else
      {
        fail ("MATERIAL.diffusemap_filename"); error++;
      }
  }
  {
    BITCODE_BS diffusemap_projection;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "diffusemap_projection", &diffusemap_projection, NULL) &&
        diffusemap_projection == material->diffusemap_projection)
      pass ("MATERIAL.diffusemap_projection [BS]");
    else
      {
        fail ("MATERIAL.diffusemap_projection [BS] %d != %d", material->diffusemap_projection, diffusemap_projection); error++;
      }
  }
  {
    BITCODE_BS diffusemap_source;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "diffusemap_source", &diffusemap_source, NULL) &&
        diffusemap_source == material->diffusemap_source)
      pass ("MATERIAL.diffusemap_source [BS]");
    else
      {
        fail ("MATERIAL.diffusemap_source [BS] %d != %d", material->diffusemap_source, diffusemap_source); error++;
      }
  }
  {
    BITCODE_BS diffusemap_tiling;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "diffusemap_tiling", &diffusemap_tiling, NULL) &&
        diffusemap_tiling == material->diffusemap_tiling)
      pass ("MATERIAL.diffusemap_tiling [BS]");
    else
      {
        fail ("MATERIAL.diffusemap_tiling [BS] %d != %d", material->diffusemap_tiling, diffusemap_tiling); error++;
      }
  }
  {
    BITCODE_BD* diffusemap_transmatrix;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "diffusemap_transmatrix", &diffusemap_transmatrix, NULL)
        && !memcmp(&diffusemap_transmatrix, &material->diffusemap_transmatrix, sizeof(material->diffusemap_transmatrix)))
      pass ("MATERIAL.diffusemap_transmatrix");
    else
      {
        fail ("MATERIAL.diffusemap_transmatrix"); error++;
      }
  }
  {
    BITCODE_BS final_gather_mode;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "final_gather_mode", &final_gather_mode, NULL) &&
        final_gather_mode == material->final_gather_mode)
      pass ("MATERIAL.final_gather_mode [BS]");
    else
      {
        fail ("MATERIAL.final_gather_mode [BS] %d != %d", material->final_gather_mode, final_gather_mode); error++;
      }
  }
  {
    BITCODE_T genprocname;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "genprocname", &genprocname, NULL)
        && !memcmp(&genprocname, &material->genprocname, sizeof(material->genprocname)))
      pass ("MATERIAL.genprocname");
    else
      {
        fail ("MATERIAL.genprocname"); error++;
      }
  }
  {
    BITCODE_B genproctableend;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "genproctableend", &genproctableend, NULL) &&
        genproctableend == material->genproctableend)
      pass ("MATERIAL.genproctableend [B]");
    else
      {
        fail ("MATERIAL.genproctableend [B] " FORMAT_B " != " FORMAT_B "", material->genproctableend, genproctableend); error++;
      }
  }
  {
    BITCODE_B genprocvalbool;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "genprocvalbool", &genprocvalbool, NULL) &&
        genprocvalbool == material->genprocvalbool)
      pass ("MATERIAL.genprocvalbool [B]");
    else
      {
        fail ("MATERIAL.genprocvalbool [B] " FORMAT_B " != " FORMAT_B "", material->genprocvalbool, genprocvalbool); error++;
      }
  }
  {
    BITCODE_CMC genprocvalcolorindex;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "genprocvalcolorindex", &genprocvalcolorindex, NULL)
        && !memcmp(&genprocvalcolorindex, &material->genprocvalcolorindex, sizeof(material->genprocvalcolorindex)))
      pass ("MATERIAL.genprocvalcolorindex");
    else
      {
        fail ("MATERIAL.genprocvalcolorindex"); error++;
      }
  }
  {
    BITCODE_T genprocvalcolorname;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "genprocvalcolorname", &genprocvalcolorname, NULL)
        && !memcmp(&genprocvalcolorname, &material->genprocvalcolorname, sizeof(material->genprocvalcolorname)))
      pass ("MATERIAL.genprocvalcolorname");
    else
      {
        fail ("MATERIAL.genprocvalcolorname"); error++;
      }
  }
  {
    BITCODE_BS genprocvalcolorrgb;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "genprocvalcolorrgb", &genprocvalcolorrgb, NULL) &&
        genprocvalcolorrgb == material->genprocvalcolorrgb)
      pass ("MATERIAL.genprocvalcolorrgb [BS]");
    else
      {
        fail ("MATERIAL.genprocvalcolorrgb [BS] %d != %d", material->genprocvalcolorrgb, genprocvalcolorrgb); error++;
      }
  }
  {
    BITCODE_BS genprocvalint;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "genprocvalint", &genprocvalint, NULL) &&
        genprocvalint == material->genprocvalint)
      pass ("MATERIAL.genprocvalint [BS]");
    else
      {
        fail ("MATERIAL.genprocvalint [BS] %d != %d", material->genprocvalint, genprocvalint); error++;
      }
  }
  {
    BITCODE_BD genprocvalreal;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "genprocvalreal", &genprocvalreal, NULL) &&
        genprocvalreal == material->genprocvalreal)
      pass ("MATERIAL.genprocvalreal [BD]");
    else
      {
        fail ("MATERIAL.genprocvalreal [BD] %g != %g", material->genprocvalreal, genprocvalreal); error++;
      }
  }
  {
    BITCODE_T genprocvaltext;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "genprocvaltext", &genprocvaltext, NULL)
        && !memcmp(&genprocvaltext, &material->genprocvaltext, sizeof(material->genprocvaltext)))
      pass ("MATERIAL.genprocvaltext");
    else
      {
        fail ("MATERIAL.genprocvaltext"); error++;
      }
  }
  {
    BITCODE_BS global_illumination_mode;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "global_illumination_mode", &global_illumination_mode, NULL) &&
        global_illumination_mode == material->global_illumination_mode)
      pass ("MATERIAL.global_illumination_mode [BS]");
    else
      {
        fail ("MATERIAL.global_illumination_mode [BS] %d != %d", material->global_illumination_mode, global_illumination_mode); error++;
      }
  }
  {
    BITCODE_BL illumination_model;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "illumination_model", &illumination_model, NULL) &&
        illumination_model == material->illumination_model)
      pass ("MATERIAL.illumination_model [BL]");
    else
      {
        fail ("MATERIAL.illumination_model [BL] %u != %u", material->illumination_model, illumination_model); error++;
      }
  }
  {
    BITCODE_BD indirect_dump_scale;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "indirect_dump_scale", &indirect_dump_scale, NULL) &&
        indirect_dump_scale == material->indirect_dump_scale)
      pass ("MATERIAL.indirect_dump_scale [BD]");
    else
      {
        fail ("MATERIAL.indirect_dump_scale [BD] %g != %g", material->indirect_dump_scale, indirect_dump_scale); error++;
      }
  }
  {
    BITCODE_BD luminance;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "luminance", &luminance, NULL) &&
        luminance == material->luminance)
      pass ("MATERIAL.luminance [BD]");
    else
      {
        fail ("MATERIAL.luminance [BD] %g != %g", material->luminance, luminance); error++;
      }
  }
  {
    BITCODE_BS luminance_mode;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "luminance_mode", &luminance_mode, NULL) &&
        luminance_mode == material->luminance_mode)
      pass ("MATERIAL.luminance_mode [BS]");
    else
      {
        fail ("MATERIAL.luminance_mode [BS] %d != %d", material->luminance_mode, luminance_mode); error++;
      }
  }
  {
    BITCODE_BS map_utile;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "map_utile", &map_utile, NULL) &&
        map_utile == material->map_utile)
      pass ("MATERIAL.map_utile [BS]");
    else
      {
        fail ("MATERIAL.map_utile [BS] %d != %d", material->map_utile, map_utile); error++;
      }
  }
  {
    BITCODE_B materials_anonymous;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "materials_anonymous", &materials_anonymous, NULL) &&
        materials_anonymous == material->materials_anonymous)
      pass ("MATERIAL.materials_anonymous [B]");
    else
      {
        fail ("MATERIAL.materials_anonymous [B] " FORMAT_B " != " FORMAT_B "", material->materials_anonymous, materials_anonymous); error++;
      }
  }
  {
    BITCODE_T name;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "name", &name, NULL)
        && !memcmp(&name, &material->name, sizeof(material->name)))
      pass ("MATERIAL.name");
    else
      {
        fail ("MATERIAL.name"); error++;
      }
  }
  {
    BITCODE_BS normalmap_autotransform;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "normalmap_autotransform", &normalmap_autotransform, NULL) &&
        normalmap_autotransform == material->normalmap_autotransform)
      pass ("MATERIAL.normalmap_autotransform [BS]");
    else
      {
        fail ("MATERIAL.normalmap_autotransform [BS] %d != %d", material->normalmap_autotransform, normalmap_autotransform); error++;
      }
  }
  {
    BITCODE_BD normalmap_blendfactor;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "normalmap_blendfactor", &normalmap_blendfactor, NULL) &&
        normalmap_blendfactor == material->normalmap_blendfactor)
      pass ("MATERIAL.normalmap_blendfactor [BD]");
    else
      {
        fail ("MATERIAL.normalmap_blendfactor [BD] %g != %g", material->normalmap_blendfactor, normalmap_blendfactor); error++;
      }
  }
  {
    BITCODE_T normalmap_filename;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "normalmap_filename", &normalmap_filename, NULL)
        && !memcmp(&normalmap_filename, &material->normalmap_filename, sizeof(material->normalmap_filename)))
      pass ("MATERIAL.normalmap_filename");
    else
      {
        fail ("MATERIAL.normalmap_filename"); error++;
      }
  }
  {
    BITCODE_BS normalmap_method;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "normalmap_method", &normalmap_method, NULL) &&
        normalmap_method == material->normalmap_method)
      pass ("MATERIAL.normalmap_method [BS]");
    else
      {
        fail ("MATERIAL.normalmap_method [BS] %d != %d", material->normalmap_method, normalmap_method); error++;
      }
  }
  {
    BITCODE_BS normalmap_projection;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "normalmap_projection", &normalmap_projection, NULL) &&
        normalmap_projection == material->normalmap_projection)
      pass ("MATERIAL.normalmap_projection [BS]");
    else
      {
        fail ("MATERIAL.normalmap_projection [BS] %d != %d", material->normalmap_projection, normalmap_projection); error++;
      }
  }
  {
    BITCODE_BS normalmap_source;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "normalmap_source", &normalmap_source, NULL) &&
        normalmap_source == material->normalmap_source)
      pass ("MATERIAL.normalmap_source [BS]");
    else
      {
        fail ("MATERIAL.normalmap_source [BS] %d != %d", material->normalmap_source, normalmap_source); error++;
      }
  }
  {
    BITCODE_BD normalmap_strength;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "normalmap_strength", &normalmap_strength, NULL) &&
        normalmap_strength == material->normalmap_strength)
      pass ("MATERIAL.normalmap_strength [BD]");
    else
      {
        fail ("MATERIAL.normalmap_strength [BD] %g != %g", material->normalmap_strength, normalmap_strength); error++;
      }
  }
  {
    BITCODE_BS normalmap_tiling;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "normalmap_tiling", &normalmap_tiling, NULL) &&
        normalmap_tiling == material->normalmap_tiling)
      pass ("MATERIAL.normalmap_tiling [BS]");
    else
      {
        fail ("MATERIAL.normalmap_tiling [BS] %d != %d", material->normalmap_tiling, normalmap_tiling); error++;
      }
  }
  {
    BITCODE_BD* normalmap_transmatrix;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "normalmap_transmatrix", &normalmap_transmatrix, NULL)
        && !memcmp(&normalmap_transmatrix, &material->normalmap_transmatrix, sizeof(material->normalmap_transmatrix)))
      pass ("MATERIAL.normalmap_transmatrix");
    else
      {
        fail ("MATERIAL.normalmap_transmatrix"); error++;
      }
  }
  {
    BITCODE_BD opacity_percent;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "opacity_percent", &opacity_percent, NULL) &&
        opacity_percent == material->opacity_percent)
      pass ("MATERIAL.opacity_percent [BD]");
    else
      {
        fail ("MATERIAL.opacity_percent [BD] %g != %g", material->opacity_percent, opacity_percent); error++;
      }
  }
  {
    BITCODE_BS opacitymap_autotransform;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "opacitymap_autotransform", &opacitymap_autotransform, NULL) &&
        opacitymap_autotransform == material->opacitymap_autotransform)
      pass ("MATERIAL.opacitymap_autotransform [BS]");
    else
      {
        fail ("MATERIAL.opacitymap_autotransform [BS] %d != %d", material->opacitymap_autotransform, opacitymap_autotransform); error++;
      }
  }
  {
    BITCODE_BD opacitymap_blendfactor;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "opacitymap_blendfactor", &opacitymap_blendfactor, NULL) &&
        opacitymap_blendfactor == material->opacitymap_blendfactor)
      pass ("MATERIAL.opacitymap_blendfactor [BD]");
    else
      {
        fail ("MATERIAL.opacitymap_blendfactor [BD] %g != %g", material->opacitymap_blendfactor, opacitymap_blendfactor); error++;
      }
  }
  {
    BITCODE_T opacitymap_filename;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "opacitymap_filename", &opacitymap_filename, NULL)
        && !memcmp(&opacitymap_filename, &material->opacitymap_filename, sizeof(material->opacitymap_filename)))
      pass ("MATERIAL.opacitymap_filename");
    else
      {
        fail ("MATERIAL.opacitymap_filename"); error++;
      }
  }
  {
    BITCODE_BS opacitymap_projection;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "opacitymap_projection", &opacitymap_projection, NULL) &&
        opacitymap_projection == material->opacitymap_projection)
      pass ("MATERIAL.opacitymap_projection [BS]");
    else
      {
        fail ("MATERIAL.opacitymap_projection [BS] %d != %d", material->opacitymap_projection, opacitymap_projection); error++;
      }
  }
  {
    BITCODE_BS opacitymap_source;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "opacitymap_source", &opacitymap_source, NULL) &&
        opacitymap_source == material->opacitymap_source)
      pass ("MATERIAL.opacitymap_source [BS]");
    else
      {
        fail ("MATERIAL.opacitymap_source [BS] %d != %d", material->opacitymap_source, opacitymap_source); error++;
      }
  }
  {
    BITCODE_BS opacitymap_tiling;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "opacitymap_tiling", &opacitymap_tiling, NULL) &&
        opacitymap_tiling == material->opacitymap_tiling)
      pass ("MATERIAL.opacitymap_tiling [BS]");
    else
      {
        fail ("MATERIAL.opacitymap_tiling [BS] %d != %d", material->opacitymap_tiling, opacitymap_tiling); error++;
      }
  }
  {
    BITCODE_BD* opacitymap_transmatrix;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "opacitymap_transmatrix", &opacitymap_transmatrix, NULL)
        && !memcmp(&opacitymap_transmatrix, &material->opacitymap_transmatrix, sizeof(material->opacitymap_transmatrix)))
      pass ("MATERIAL.opacitymap_transmatrix");
    else
      {
        fail ("MATERIAL.opacitymap_transmatrix"); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "ownerhandle", &ownerhandle, NULL) &&
        ownerhandle == material->ownerhandle)
      pass ("MATERIAL.ownerhandle [H]");
    else
      {
        fail ("MATERIAL.ownerhandle [H] %p != %p", material->ownerhandle, ownerhandle); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "parent", &parent, NULL)
        && !memcmp(&parent, &material->parent, sizeof(material->parent)))
      pass ("MATERIAL.parent");
    else
      {
        fail ("MATERIAL.parent"); error++;
      }
  }
  {
    BITCODE_BD reflectance_scale;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "reflectance_scale", &reflectance_scale, NULL) &&
        reflectance_scale == material->reflectance_scale)
      pass ("MATERIAL.reflectance_scale [BD]");
    else
      {
        fail ("MATERIAL.reflectance_scale [BD] %g != %g", material->reflectance_scale, reflectance_scale); error++;
      }
  }
  {
    BITCODE_BS reflectionmap_autotransform;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "reflectionmap_autotransform", &reflectionmap_autotransform, NULL) &&
        reflectionmap_autotransform == material->reflectionmap_autotransform)
      pass ("MATERIAL.reflectionmap_autotransform [BS]");
    else
      {
        fail ("MATERIAL.reflectionmap_autotransform [BS] %d != %d", material->reflectionmap_autotransform, reflectionmap_autotransform); error++;
      }
  }
  {
    BITCODE_BD reflectionmap_blendfactor;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "reflectionmap_blendfactor", &reflectionmap_blendfactor, NULL) &&
        reflectionmap_blendfactor == material->reflectionmap_blendfactor)
      pass ("MATERIAL.reflectionmap_blendfactor [BD]");
    else
      {
        fail ("MATERIAL.reflectionmap_blendfactor [BD] %g != %g", material->reflectionmap_blendfactor, reflectionmap_blendfactor); error++;
      }
  }
  {
    BITCODE_T reflectionmap_filename;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "reflectionmap_filename", &reflectionmap_filename, NULL)
        && !memcmp(&reflectionmap_filename, &material->reflectionmap_filename, sizeof(material->reflectionmap_filename)))
      pass ("MATERIAL.reflectionmap_filename");
    else
      {
        fail ("MATERIAL.reflectionmap_filename"); error++;
      }
  }
  {
    BITCODE_BS reflectionmap_projection;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "reflectionmap_projection", &reflectionmap_projection, NULL) &&
        reflectionmap_projection == material->reflectionmap_projection)
      pass ("MATERIAL.reflectionmap_projection [BS]");
    else
      {
        fail ("MATERIAL.reflectionmap_projection [BS] %d != %d", material->reflectionmap_projection, reflectionmap_projection); error++;
      }
  }
  {
    BITCODE_BS reflectionmap_source;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "reflectionmap_source", &reflectionmap_source, NULL) &&
        reflectionmap_source == material->reflectionmap_source)
      pass ("MATERIAL.reflectionmap_source [BS]");
    else
      {
        fail ("MATERIAL.reflectionmap_source [BS] %d != %d", material->reflectionmap_source, reflectionmap_source); error++;
      }
  }
  {
    BITCODE_BS reflectionmap_tiling;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "reflectionmap_tiling", &reflectionmap_tiling, NULL) &&
        reflectionmap_tiling == material->reflectionmap_tiling)
      pass ("MATERIAL.reflectionmap_tiling [BS]");
    else
      {
        fail ("MATERIAL.reflectionmap_tiling [BS] %d != %d", material->reflectionmap_tiling, reflectionmap_tiling); error++;
      }
  }
  {
    BITCODE_BD* reflectionmap_transmatrix;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "reflectionmap_transmatrix", &reflectionmap_transmatrix, NULL)
        && !memcmp(&reflectionmap_transmatrix, &material->reflectionmap_transmatrix, sizeof(material->reflectionmap_transmatrix)))
      pass ("MATERIAL.reflectionmap_transmatrix");
    else
      {
        fail ("MATERIAL.reflectionmap_transmatrix"); error++;
      }
  }
  {
    BITCODE_BD reflectivity;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "reflectivity", &reflectivity, NULL) &&
        reflectivity == material->reflectivity)
      pass ("MATERIAL.reflectivity [BD]");
    else
      {
        fail ("MATERIAL.reflectivity [BD] %g != %g", material->reflectivity, reflectivity); error++;
      }
  }
  {
    BITCODE_BD refraction_index;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "refraction_index", &refraction_index, NULL) &&
        refraction_index == material->refraction_index)
      pass ("MATERIAL.refraction_index [BD]");
    else
      {
        fail ("MATERIAL.refraction_index [BD] %g != %g", material->refraction_index, refraction_index); error++;
      }
  }
  {
    BITCODE_BS refractionmap_autotransform;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "refractionmap_autotransform", &refractionmap_autotransform, NULL) &&
        refractionmap_autotransform == material->refractionmap_autotransform)
      pass ("MATERIAL.refractionmap_autotransform [BS]");
    else
      {
        fail ("MATERIAL.refractionmap_autotransform [BS] %d != %d", material->refractionmap_autotransform, refractionmap_autotransform); error++;
      }
  }
  {
    BITCODE_BD refractionmap_blendfactor;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "refractionmap_blendfactor", &refractionmap_blendfactor, NULL) &&
        refractionmap_blendfactor == material->refractionmap_blendfactor)
      pass ("MATERIAL.refractionmap_blendfactor [BD]");
    else
      {
        fail ("MATERIAL.refractionmap_blendfactor [BD] %g != %g", material->refractionmap_blendfactor, refractionmap_blendfactor); error++;
      }
  }
  {
    BITCODE_T refractionmap_filename;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "refractionmap_filename", &refractionmap_filename, NULL)
        && !memcmp(&refractionmap_filename, &material->refractionmap_filename, sizeof(material->refractionmap_filename)))
      pass ("MATERIAL.refractionmap_filename");
    else
      {
        fail ("MATERIAL.refractionmap_filename"); error++;
      }
  }
  {
    BITCODE_BS refractionmap_projection;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "refractionmap_projection", &refractionmap_projection, NULL) &&
        refractionmap_projection == material->refractionmap_projection)
      pass ("MATERIAL.refractionmap_projection [BS]");
    else
      {
        fail ("MATERIAL.refractionmap_projection [BS] %d != %d", material->refractionmap_projection, refractionmap_projection); error++;
      }
  }
  {
    BITCODE_BS refractionmap_source;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "refractionmap_source", &refractionmap_source, NULL) &&
        refractionmap_source == material->refractionmap_source)
      pass ("MATERIAL.refractionmap_source [BS]");
    else
      {
        fail ("MATERIAL.refractionmap_source [BS] %d != %d", material->refractionmap_source, refractionmap_source); error++;
      }
  }
  {
    BITCODE_BS refractionmap_tiling;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "refractionmap_tiling", &refractionmap_tiling, NULL) &&
        refractionmap_tiling == material->refractionmap_tiling)
      pass ("MATERIAL.refractionmap_tiling [BS]");
    else
      {
        fail ("MATERIAL.refractionmap_tiling [BS] %d != %d", material->refractionmap_tiling, refractionmap_tiling); error++;
      }
  }
  {
    BITCODE_BD* refractionmap_transmatrix;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "refractionmap_transmatrix", &refractionmap_transmatrix, NULL)
        && !memcmp(&refractionmap_transmatrix, &material->refractionmap_transmatrix, sizeof(material->refractionmap_transmatrix)))
      pass ("MATERIAL.refractionmap_transmatrix");
    else
      {
        fail ("MATERIAL.refractionmap_transmatrix"); error++;
      }
  }
  {
    BITCODE_BL self_illumination;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "self_illumination", &self_illumination, NULL) &&
        self_illumination == material->self_illumination)
      pass ("MATERIAL.self_illumination [BL]");
    else
      {
        fail ("MATERIAL.self_illumination [BL] %u != %u", material->self_illumination, self_illumination); error++;
      }
  }
  {
    BITCODE_CMC specular_color;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "specular_color", &specular_color, NULL)
        && !memcmp(&specular_color, &material->specular_color, sizeof(material->specular_color)))
      pass ("MATERIAL.specular_color");
    else
      {
        fail ("MATERIAL.specular_color"); error++;
      }
  }
  {
    BITCODE_BD specular_color_factor;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "specular_color_factor", &specular_color_factor, NULL) &&
        specular_color_factor == material->specular_color_factor)
      pass ("MATERIAL.specular_color_factor [BD]");
    else
      {
        fail ("MATERIAL.specular_color_factor [BD] %g != %g", material->specular_color_factor, specular_color_factor); error++;
      }
  }
  {
    BITCODE_BS specular_color_flag;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "specular_color_flag", &specular_color_flag, NULL) &&
        specular_color_flag == material->specular_color_flag)
      pass ("MATERIAL.specular_color_flag [BS]");
    else
      {
        fail ("MATERIAL.specular_color_flag [BS] %d != %d", material->specular_color_flag, specular_color_flag); error++;
      }
  }
  {
    BITCODE_BD specular_gloss_factor;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "specular_gloss_factor", &specular_gloss_factor, NULL) &&
        specular_gloss_factor == material->specular_gloss_factor)
      pass ("MATERIAL.specular_gloss_factor [BD]");
    else
      {
        fail ("MATERIAL.specular_gloss_factor [BD] %g != %g", material->specular_gloss_factor, specular_gloss_factor); error++;
      }
  }
  {
    BITCODE_BS specularmap_autotransform;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "specularmap_autotransform", &specularmap_autotransform, NULL) &&
        specularmap_autotransform == material->specularmap_autotransform)
      pass ("MATERIAL.specularmap_autotransform [BS]");
    else
      {
        fail ("MATERIAL.specularmap_autotransform [BS] %d != %d", material->specularmap_autotransform, specularmap_autotransform); error++;
      }
  }
  {
    BITCODE_BD specularmap_blendfactor;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "specularmap_blendfactor", &specularmap_blendfactor, NULL) &&
        specularmap_blendfactor == material->specularmap_blendfactor)
      pass ("MATERIAL.specularmap_blendfactor [BD]");
    else
      {
        fail ("MATERIAL.specularmap_blendfactor [BD] %g != %g", material->specularmap_blendfactor, specularmap_blendfactor); error++;
      }
  }
  {
    BITCODE_T specularmap_filename;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "specularmap_filename", &specularmap_filename, NULL)
        && !memcmp(&specularmap_filename, &material->specularmap_filename, sizeof(material->specularmap_filename)))
      pass ("MATERIAL.specularmap_filename");
    else
      {
        fail ("MATERIAL.specularmap_filename"); error++;
      }
  }
  {
    BITCODE_BS specularmap_projection;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "specularmap_projection", &specularmap_projection, NULL) &&
        specularmap_projection == material->specularmap_projection)
      pass ("MATERIAL.specularmap_projection [BS]");
    else
      {
        fail ("MATERIAL.specularmap_projection [BS] %d != %d", material->specularmap_projection, specularmap_projection); error++;
      }
  }
  {
    BITCODE_BS specularmap_source;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "specularmap_source", &specularmap_source, NULL) &&
        specularmap_source == material->specularmap_source)
      pass ("MATERIAL.specularmap_source [BS]");
    else
      {
        fail ("MATERIAL.specularmap_source [BS] %d != %d", material->specularmap_source, specularmap_source); error++;
      }
  }
  {
    BITCODE_BS specularmap_tiling;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "specularmap_tiling", &specularmap_tiling, NULL) &&
        specularmap_tiling == material->specularmap_tiling)
      pass ("MATERIAL.specularmap_tiling [BS]");
    else
      {
        fail ("MATERIAL.specularmap_tiling [BS] %d != %d", material->specularmap_tiling, specularmap_tiling); error++;
      }
  }
  {
    BITCODE_BD* specularmap_transmatrix;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "specularmap_transmatrix", &specularmap_transmatrix, NULL)
        && !memcmp(&specularmap_transmatrix, &material->specularmap_transmatrix, sizeof(material->specularmap_transmatrix)))
      pass ("MATERIAL.specularmap_transmatrix");
    else
      {
        fail ("MATERIAL.specularmap_transmatrix"); error++;
      }
  }
  {
    BITCODE_BD translucence;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "translucence", &translucence, NULL) &&
        translucence == material->translucence)
      pass ("MATERIAL.translucence [BD]");
    else
      {
        fail ("MATERIAL.translucence [BD] %g != %g", material->translucence, translucence); error++;
      }
  }
  {
    BITCODE_BD transmittance_scale;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "transmittance_scale", &transmittance_scale, NULL) &&
        transmittance_scale == material->transmittance_scale)
      pass ("MATERIAL.transmittance_scale [BD]");
    else
      {
        fail ("MATERIAL.transmittance_scale [BD] %g != %g", material->transmittance_scale, transmittance_scale); error++;
      }
  }
  {
    BITCODE_B two_sided_material;
    if (dwg_dynapi_entity_value(material, "MATERIAL", "two_sided_material", &two_sided_material, NULL) &&
        two_sided_material == material->two_sided_material)
      pass ("MATERIAL.two_sided_material [B]");
    else
      {
        fail ("MATERIAL.two_sided_material [B] " FORMAT_B " != " FORMAT_B "", material->two_sided_material, two_sided_material); error++;
      }
  }
  return error;
}
static int test_MLEADERSTYLE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_MLEADERSTYLE *mleaderstyle = obj->tio.object->tio.MLEADERSTYLE;
  {
    BITCODE_BD align_space;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "align_space", &align_space, NULL) &&
        align_space == mleaderstyle->align_space)
      pass ("MLEADERSTYLE.align_space [BD]");
    else
      {
        fail ("MLEADERSTYLE.align_space [BD] %g != %g", mleaderstyle->align_space, align_space); error++;
      }
  }
  {
    BITCODE_H arrow_head;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "arrow_head", &arrow_head, NULL) &&
        arrow_head == mleaderstyle->arrow_head)
      pass ("MLEADERSTYLE.arrow_head [H]");
    else
      {
        fail ("MLEADERSTYLE.arrow_head [H] %p != %p", mleaderstyle->arrow_head, arrow_head); error++;
      }
  }
  {
    BITCODE_BD arrow_head_size;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "arrow_head_size", &arrow_head_size, NULL) &&
        arrow_head_size == mleaderstyle->arrow_head_size)
      pass ("MLEADERSTYLE.arrow_head_size [BD]");
    else
      {
        fail ("MLEADERSTYLE.arrow_head_size [BD] %g != %g", mleaderstyle->arrow_head_size, arrow_head_size); error++;
      }
  }
  {
    BITCODE_BS attach_bottom;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "attach_bottom", &attach_bottom, NULL) &&
        attach_bottom == mleaderstyle->attach_bottom)
      pass ("MLEADERSTYLE.attach_bottom [BS]");
    else
      {
        fail ("MLEADERSTYLE.attach_bottom [BS] %d != %d", mleaderstyle->attach_bottom, attach_bottom); error++;
      }
  }
  {
    BITCODE_BS attach_dir;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "attach_dir", &attach_dir, NULL) &&
        attach_dir == mleaderstyle->attach_dir)
      pass ("MLEADERSTYLE.attach_dir [BS]");
    else
      {
        fail ("MLEADERSTYLE.attach_dir [BS] %d != %d", mleaderstyle->attach_dir, attach_dir); error++;
      }
  }
  {
    BITCODE_BS attach_left;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "attach_left", &attach_left, NULL) &&
        attach_left == mleaderstyle->attach_left)
      pass ("MLEADERSTYLE.attach_left [BS]");
    else
      {
        fail ("MLEADERSTYLE.attach_left [BS] %d != %d", mleaderstyle->attach_left, attach_left); error++;
      }
  }
  {
    BITCODE_BS attach_right;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "attach_right", &attach_right, NULL) &&
        attach_right == mleaderstyle->attach_right)
      pass ("MLEADERSTYLE.attach_right [BS]");
    else
      {
        fail ("MLEADERSTYLE.attach_right [BS] %d != %d", mleaderstyle->attach_right, attach_right); error++;
      }
  }
  {
    BITCODE_BS attach_top;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "attach_top", &attach_top, NULL) &&
        attach_top == mleaderstyle->attach_top)
      pass ("MLEADERSTYLE.attach_top [BS]");
    else
      {
        fail ("MLEADERSTYLE.attach_top [BS] %d != %d", mleaderstyle->attach_top, attach_top); error++;
      }
  }
  {
    BITCODE_H block;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "block", &block, NULL) &&
        block == mleaderstyle->block)
      pass ("MLEADERSTYLE.block [H]");
    else
      {
        fail ("MLEADERSTYLE.block [H] %p != %p", mleaderstyle->block, block); error++;
      }
  }
  {
    BITCODE_CMC block_color;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "block_color", &block_color, NULL)
        && !memcmp(&block_color, &mleaderstyle->block_color, sizeof(mleaderstyle->block_color)))
      pass ("MLEADERSTYLE.block_color");
    else
      {
        fail ("MLEADERSTYLE.block_color"); error++;
      }
  }
  {
    BITCODE_BS block_connection;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "block_connection", &block_connection, NULL) &&
        block_connection == mleaderstyle->block_connection)
      pass ("MLEADERSTYLE.block_connection [BS]");
    else
      {
        fail ("MLEADERSTYLE.block_connection [BS] %d != %d", mleaderstyle->block_connection, block_connection); error++;
      }
  }
  {
    BITCODE_BD block_rotation;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "block_rotation", &block_rotation, NULL) &&
        block_rotation == mleaderstyle->block_rotation)
      pass ("MLEADERSTYLE.block_rotation [BD]");
    else
      {
        fail ("MLEADERSTYLE.block_rotation [BD] %g != %g", mleaderstyle->block_rotation, block_rotation); error++;
      }
  }
  {
    BITCODE_3BD block_scale;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "block_scale", &block_scale, NULL)
        && !memcmp(&block_scale, &mleaderstyle->block_scale, sizeof(mleaderstyle->block_scale)))
      pass ("MLEADERSTYLE.block_scale");
    else
      {
        fail ("MLEADERSTYLE.block_scale"); error++;
      }
  }
  {
    BITCODE_BD break_size;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "break_size", &break_size, NULL) &&
        break_size == mleaderstyle->break_size)
      pass ("MLEADERSTYLE.break_size [BD]");
    else
      {
        fail ("MLEADERSTYLE.break_size [BD] %g != %g", mleaderstyle->break_size, break_size); error++;
      }
  }
  {
    BITCODE_B changed;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "changed", &changed, NULL) &&
        changed == mleaderstyle->changed)
      pass ("MLEADERSTYLE.changed [B]");
    else
      {
        fail ("MLEADERSTYLE.changed [B] " FORMAT_B " != " FORMAT_B "", mleaderstyle->changed, changed); error++;
      }
  }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "class_version", &class_version, NULL) &&
        class_version == mleaderstyle->class_version)
      pass ("MLEADERSTYLE.class_version [BS]");
    else
      {
        fail ("MLEADERSTYLE.class_version [BS] %d != %d", mleaderstyle->class_version, class_version); error++;
      }
  }
  {
    BITCODE_BS content_type;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "content_type", &content_type, NULL) &&
        content_type == mleaderstyle->content_type)
      pass ("MLEADERSTYLE.content_type [BS]");
    else
      {
        fail ("MLEADERSTYLE.content_type [BS] %d != %d", mleaderstyle->content_type, content_type); error++;
      }
  }
  {
    BITCODE_TV description;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "description", &description, NULL)
        && !strcmp((char*)&description, (char*)&mleaderstyle->description))
      pass ("MLEADERSTYLE.description");
    else
      {
        fail ("MLEADERSTYLE.description"); error++;
      }
  }
  {
    BITCODE_BD first_seg_angle;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "first_seg_angle", &first_seg_angle, NULL) &&
        first_seg_angle == mleaderstyle->first_seg_angle)
      pass ("MLEADERSTYLE.first_seg_angle [BD]");
    else
      {
        fail ("MLEADERSTYLE.first_seg_angle [BD] %g != %g", mleaderstyle->first_seg_angle, first_seg_angle); error++;
      }
  }
  {
    BITCODE_B has_dogleg;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "has_dogleg", &has_dogleg, NULL) &&
        has_dogleg == mleaderstyle->has_dogleg)
      pass ("MLEADERSTYLE.has_dogleg [B]");
    else
      {
        fail ("MLEADERSTYLE.has_dogleg [B] " FORMAT_B " != " FORMAT_B "", mleaderstyle->has_dogleg, has_dogleg); error++;
      }
  }
  {
    BITCODE_B has_landing;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "has_landing", &has_landing, NULL) &&
        has_landing == mleaderstyle->has_landing)
      pass ("MLEADERSTYLE.has_landing [B]");
    else
      {
        fail ("MLEADERSTYLE.has_landing [B] " FORMAT_B " != " FORMAT_B "", mleaderstyle->has_landing, has_landing); error++;
      }
  }
  {
    BITCODE_B is_annotative;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "is_annotative", &is_annotative, NULL) &&
        is_annotative == mleaderstyle->is_annotative)
      pass ("MLEADERSTYLE.is_annotative [B]");
    else
      {
        fail ("MLEADERSTYLE.is_annotative [B] " FORMAT_B " != " FORMAT_B "", mleaderstyle->is_annotative, is_annotative); error++;
      }
  }
  {
    BITCODE_B is_new_format;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "is_new_format", &is_new_format, NULL) &&
        is_new_format == mleaderstyle->is_new_format)
      pass ("MLEADERSTYLE.is_new_format [B]");
    else
      {
        fail ("MLEADERSTYLE.is_new_format [B] " FORMAT_B " != " FORMAT_B "", mleaderstyle->is_new_format, is_new_format); error++;
      }
  }
  {
    BITCODE_BD landing_dist;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "landing_dist", &landing_dist, NULL) &&
        landing_dist == mleaderstyle->landing_dist)
      pass ("MLEADERSTYLE.landing_dist [BD]");
    else
      {
        fail ("MLEADERSTYLE.landing_dist [BD] %g != %g", mleaderstyle->landing_dist, landing_dist); error++;
      }
  }
  {
    BITCODE_BD landing_gap;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "landing_gap", &landing_gap, NULL) &&
        landing_gap == mleaderstyle->landing_gap)
      pass ("MLEADERSTYLE.landing_gap [BD]");
    else
      {
        fail ("MLEADERSTYLE.landing_gap [BD] %g != %g", mleaderstyle->landing_gap, landing_gap); error++;
      }
  }
  {
    BITCODE_BS leader_order;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "leader_order", &leader_order, NULL) &&
        leader_order == mleaderstyle->leader_order)
      pass ("MLEADERSTYLE.leader_order [BS]");
    else
      {
        fail ("MLEADERSTYLE.leader_order [BS] %d != %d", mleaderstyle->leader_order, leader_order); error++;
      }
  }
  {
    BITCODE_CMC line_color;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "line_color", &line_color, NULL)
        && !memcmp(&line_color, &mleaderstyle->line_color, sizeof(mleaderstyle->line_color)))
      pass ("MLEADERSTYLE.line_color");
    else
      {
        fail ("MLEADERSTYLE.line_color"); error++;
      }
  }
  {
    BITCODE_H line_type;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "line_type", &line_type, NULL) &&
        line_type == mleaderstyle->line_type)
      pass ("MLEADERSTYLE.line_type [H]");
    else
      {
        fail ("MLEADERSTYLE.line_type [H] %p != %p", mleaderstyle->line_type, line_type); error++;
      }
  }
  {
    BITCODE_BL linewt;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "linewt", &linewt, NULL) &&
        linewt == mleaderstyle->linewt)
      pass ("MLEADERSTYLE.linewt [BL]");
    else
      {
        fail ("MLEADERSTYLE.linewt [BL] %u != %u", mleaderstyle->linewt, linewt); error++;
      }
  }
  {
    BITCODE_BL max_points;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "max_points", &max_points, NULL) &&
        max_points == mleaderstyle->max_points)
      pass ("MLEADERSTYLE.max_points [BL]");
    else
      {
        fail ("MLEADERSTYLE.max_points [BL] %u != %u", mleaderstyle->max_points, max_points); error++;
      }
  }
  {
    BITCODE_BS mleader_order;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "mleader_order", &mleader_order, NULL) &&
        mleader_order == mleaderstyle->mleader_order)
      pass ("MLEADERSTYLE.mleader_order [BS]");
    else
      {
        fail ("MLEADERSTYLE.mleader_order [BS] %d != %d", mleaderstyle->mleader_order, mleader_order); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "parent", &parent, NULL)
        && !memcmp(&parent, &mleaderstyle->parent, sizeof(mleaderstyle->parent)))
      pass ("MLEADERSTYLE.parent");
    else
      {
        fail ("MLEADERSTYLE.parent"); error++;
      }
  }
  {
    BITCODE_BD scale;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "scale", &scale, NULL) &&
        scale == mleaderstyle->scale)
      pass ("MLEADERSTYLE.scale [BD]");
    else
      {
        fail ("MLEADERSTYLE.scale [BD] %g != %g", mleaderstyle->scale, scale); error++;
      }
  }
  {
    BITCODE_BD second_seg_angle;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "second_seg_angle", &second_seg_angle, NULL) &&
        second_seg_angle == mleaderstyle->second_seg_angle)
      pass ("MLEADERSTYLE.second_seg_angle [BD]");
    else
      {
        fail ("MLEADERSTYLE.second_seg_angle [BD] %g != %g", mleaderstyle->second_seg_angle, second_seg_angle); error++;
      }
  }
  {
    BITCODE_BS text_align_type;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "text_align_type", &text_align_type, NULL) &&
        text_align_type == mleaderstyle->text_align_type)
      pass ("MLEADERSTYLE.text_align_type [BS]");
    else
      {
        fail ("MLEADERSTYLE.text_align_type [BS] %d != %d", mleaderstyle->text_align_type, text_align_type); error++;
      }
  }
  {
    BITCODE_B text_always_left;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "text_always_left", &text_always_left, NULL) &&
        text_always_left == mleaderstyle->text_always_left)
      pass ("MLEADERSTYLE.text_always_left [B]");
    else
      {
        fail ("MLEADERSTYLE.text_always_left [B] " FORMAT_B " != " FORMAT_B "", mleaderstyle->text_always_left, text_always_left); error++;
      }
  }
  {
    BITCODE_BS text_angle_type;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "text_angle_type", &text_angle_type, NULL) &&
        text_angle_type == mleaderstyle->text_angle_type)
      pass ("MLEADERSTYLE.text_angle_type [BS]");
    else
      {
        fail ("MLEADERSTYLE.text_angle_type [BS] %d != %d", mleaderstyle->text_angle_type, text_angle_type); error++;
      }
  }
  {
    BITCODE_CMC text_color;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "text_color", &text_color, NULL)
        && !memcmp(&text_color, &mleaderstyle->text_color, sizeof(mleaderstyle->text_color)))
      pass ("MLEADERSTYLE.text_color");
    else
      {
        fail ("MLEADERSTYLE.text_color"); error++;
      }
  }
  {
    BITCODE_TV text_default;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "text_default", &text_default, NULL)
        && !strcmp((char*)&text_default, (char*)&mleaderstyle->text_default))
      pass ("MLEADERSTYLE.text_default");
    else
      {
        fail ("MLEADERSTYLE.text_default"); error++;
      }
  }
  {
    BITCODE_B text_extended;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "text_extended", &text_extended, NULL) &&
        text_extended == mleaderstyle->text_extended)
      pass ("MLEADERSTYLE.text_extended [B]");
    else
      {
        fail ("MLEADERSTYLE.text_extended [B] " FORMAT_B " != " FORMAT_B "", mleaderstyle->text_extended, text_extended); error++;
      }
  }
  {
    BITCODE_B text_frame;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "text_frame", &text_frame, NULL) &&
        text_frame == mleaderstyle->text_frame)
      pass ("MLEADERSTYLE.text_frame [B]");
    else
      {
        fail ("MLEADERSTYLE.text_frame [B] " FORMAT_B " != " FORMAT_B "", mleaderstyle->text_frame, text_frame); error++;
      }
  }
  {
    BITCODE_BD text_height;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "text_height", &text_height, NULL) &&
        text_height == mleaderstyle->text_height)
      pass ("MLEADERSTYLE.text_height [BD]");
    else
      {
        fail ("MLEADERSTYLE.text_height [BD] %g != %g", mleaderstyle->text_height, text_height); error++;
      }
  }
  {
    BITCODE_H text_style;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "text_style", &text_style, NULL) &&
        text_style == mleaderstyle->text_style)
      pass ("MLEADERSTYLE.text_style [H]");
    else
      {
        fail ("MLEADERSTYLE.text_style [H] %p != %p", mleaderstyle->text_style, text_style); error++;
      }
  }
  {
    BITCODE_BS type;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "type", &type, NULL) &&
        type == mleaderstyle->type)
      pass ("MLEADERSTYLE.type [BS]");
    else
      {
        fail ("MLEADERSTYLE.type [BS] %d != %d", mleaderstyle->type, type); error++;
      }
  }
  {
    BITCODE_B use_block_rotation;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "use_block_rotation", &use_block_rotation, NULL) &&
        use_block_rotation == mleaderstyle->use_block_rotation)
      pass ("MLEADERSTYLE.use_block_rotation [B]");
    else
      {
        fail ("MLEADERSTYLE.use_block_rotation [B] " FORMAT_B " != " FORMAT_B "", mleaderstyle->use_block_rotation, use_block_rotation); error++;
      }
  }
  {
    BITCODE_B use_block_scale;
    if (dwg_dynapi_entity_value(mleaderstyle, "MLEADERSTYLE", "use_block_scale", &use_block_scale, NULL) &&
        use_block_scale == mleaderstyle->use_block_scale)
      pass ("MLEADERSTYLE.use_block_scale [B]");
    else
      {
        fail ("MLEADERSTYLE.use_block_scale [B] " FORMAT_B " != " FORMAT_B "", mleaderstyle->use_block_scale, use_block_scale); error++;
      }
  }
  return error;
}
static int test_MLINESTYLE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_MLINESTYLE *mlinestyle = obj->tio.object->tio.MLINESTYLE;
  {
    BITCODE_TV desc;
    if (dwg_dynapi_entity_value(mlinestyle, "MLINESTYLE", "desc", &desc, NULL)
        && !strcmp((char*)&desc, (char*)&mlinestyle->desc))
      pass ("MLINESTYLE.desc");
    else
      {
        fail ("MLINESTYLE.desc"); error++;
      }
  }
  {
    BITCODE_BD end_angle;
    if (dwg_dynapi_entity_value(mlinestyle, "MLINESTYLE", "end_angle", &end_angle, NULL) &&
        end_angle == mlinestyle->end_angle)
      pass ("MLINESTYLE.end_angle [BD]");
    else
      {
        fail ("MLINESTYLE.end_angle [BD] %g != %g", mlinestyle->end_angle, end_angle); error++;
      }
  }
  {
    BITCODE_CMC fill_color;
    if (dwg_dynapi_entity_value(mlinestyle, "MLINESTYLE", "fill_color", &fill_color, NULL)
        && !memcmp(&fill_color, &mlinestyle->fill_color, sizeof(mlinestyle->fill_color)))
      pass ("MLINESTYLE.fill_color");
    else
      {
        fail ("MLINESTYLE.fill_color"); error++;
      }
  }
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value(mlinestyle, "MLINESTYLE", "flag", &flag, NULL) &&
        flag == mlinestyle->flag)
      pass ("MLINESTYLE.flag [BS]");
    else
      {
        fail ("MLINESTYLE.flag [BS] %d != %d", mlinestyle->flag, flag); error++;
      }
  }
  {
    Dwg_MLINESTYLE_line* lines;
    if (dwg_dynapi_entity_value(mlinestyle, "MLINESTYLE", "lines", &lines, NULL)
        && !memcmp(&lines, &mlinestyle->lines, sizeof(mlinestyle->lines)))
      pass ("MLINESTYLE.lines");
    else
      {
        fail ("MLINESTYLE.lines"); error++;
      }
  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value(mlinestyle, "MLINESTYLE", "name", &name, NULL)
        && !strcmp((char*)&name, (char*)&mlinestyle->name))
      pass ("MLINESTYLE.name");
    else
      {
        fail ("MLINESTYLE.name"); error++;
      }
  }
  {
    BITCODE_RC num_lines;
    if (dwg_dynapi_entity_value(mlinestyle, "MLINESTYLE", "num_lines", &num_lines, NULL) &&
        num_lines == mlinestyle->num_lines)
      pass ("MLINESTYLE.num_lines [RC]");
    else
      {
        fail ("MLINESTYLE.num_lines [RC] %c != %c", mlinestyle->num_lines, num_lines); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(mlinestyle, "MLINESTYLE", "ownerhandle", &ownerhandle, NULL) &&
        ownerhandle == mlinestyle->ownerhandle)
      pass ("MLINESTYLE.ownerhandle [H]");
    else
      {
        fail ("MLINESTYLE.ownerhandle [H] %p != %p", mlinestyle->ownerhandle, ownerhandle); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(mlinestyle, "MLINESTYLE", "parent", &parent, NULL)
        && !memcmp(&parent, &mlinestyle->parent, sizeof(mlinestyle->parent)))
      pass ("MLINESTYLE.parent");
    else
      {
        fail ("MLINESTYLE.parent"); error++;
      }
  }
  {
    BITCODE_BD start_angle;
    if (dwg_dynapi_entity_value(mlinestyle, "MLINESTYLE", "start_angle", &start_angle, NULL) &&
        start_angle == mlinestyle->start_angle)
      pass ("MLINESTYLE.start_angle [BD]");
    else
      {
        fail ("MLINESTYLE.start_angle [BD] %g != %g", mlinestyle->start_angle, start_angle); error++;
      }
  }
  return error;
}
static int test_OBJECTCONTEXTDATA (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_OBJECTCONTEXTDATA *objectcontextdata = obj->tio.object->tio.OBJECTCONTEXTDATA;
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value(objectcontextdata, "OBJECTCONTEXTDATA", "class_version", &class_version, NULL) &&
        class_version == objectcontextdata->class_version)
      pass ("OBJECTCONTEXTDATA.class_version [BS]");
    else
      {
        fail ("OBJECTCONTEXTDATA.class_version [BS] %d != %d", objectcontextdata->class_version, class_version); error++;
      }
  }
  {
    BITCODE_B defaultflag;
    if (dwg_dynapi_entity_value(objectcontextdata, "OBJECTCONTEXTDATA", "defaultflag", &defaultflag, NULL) &&
        defaultflag == objectcontextdata->defaultflag)
      pass ("OBJECTCONTEXTDATA.defaultflag [B]");
    else
      {
        fail ("OBJECTCONTEXTDATA.defaultflag [B] " FORMAT_B " != " FORMAT_B "", objectcontextdata->defaultflag, defaultflag); error++;
      }
  }
  {
    BITCODE_B has_file;
    if (dwg_dynapi_entity_value(objectcontextdata, "OBJECTCONTEXTDATA", "has_file", &has_file, NULL) &&
        has_file == objectcontextdata->has_file)
      pass ("OBJECTCONTEXTDATA.has_file [B]");
    else
      {
        fail ("OBJECTCONTEXTDATA.has_file [B] " FORMAT_B " != " FORMAT_B "", objectcontextdata->has_file, has_file); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(objectcontextdata, "OBJECTCONTEXTDATA", "parent", &parent, NULL)
        && !memcmp(&parent, &objectcontextdata->parent, sizeof(objectcontextdata->parent)))
      pass ("OBJECTCONTEXTDATA.parent");
    else
      {
        fail ("OBJECTCONTEXTDATA.parent"); error++;
      }
  }
  return error;
}
static int test_OBJECT_PTR (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_OBJECT_PTR *object_ptr = obj->tio.object->tio.OBJECT_PTR;
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(object_ptr, "OBJECT_PTR", "parent", &parent, NULL)
        && !memcmp(&parent, &object_ptr->parent, sizeof(object_ptr->parent)))
      pass ("OBJECT_PTR.parent");
    else
      {
        fail ("OBJECT_PTR.parent"); error++;
      }
  }
  return error;
}
static int test_PERSSUBENTMANAGER (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_PERSSUBENTMANAGER *perssubentmanager = obj->tio.object->tio.PERSSUBENTMANAGER;
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value(perssubentmanager, "PERSSUBENTMANAGER", "class_version", &class_version, NULL) &&
        class_version == perssubentmanager->class_version)
      pass ("PERSSUBENTMANAGER.class_version [BL]");
    else
      {
        fail ("PERSSUBENTMANAGER.class_version [BL] %u != %u", perssubentmanager->class_version, class_version); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(perssubentmanager, "PERSSUBENTMANAGER", "ownerhandle", &ownerhandle, NULL) &&
        ownerhandle == perssubentmanager->ownerhandle)
      pass ("PERSSUBENTMANAGER.ownerhandle [H]");
    else
      {
        fail ("PERSSUBENTMANAGER.ownerhandle [H] %p != %p", perssubentmanager->ownerhandle, ownerhandle); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(perssubentmanager, "PERSSUBENTMANAGER", "parent", &parent, NULL)
        && !memcmp(&parent, &perssubentmanager->parent, sizeof(perssubentmanager->parent)))
      pass ("PERSSUBENTMANAGER.parent");
    else
      {
        fail ("PERSSUBENTMANAGER.parent"); error++;
      }
  }
  {
    BITCODE_BL unknown_bl1;
    if (dwg_dynapi_entity_value(perssubentmanager, "PERSSUBENTMANAGER", "unknown_bl1", &unknown_bl1, NULL) &&
        unknown_bl1 == perssubentmanager->unknown_bl1)
      pass ("PERSSUBENTMANAGER.unknown_bl1 [BL]");
    else
      {
        fail ("PERSSUBENTMANAGER.unknown_bl1 [BL] %u != %u", perssubentmanager->unknown_bl1, unknown_bl1); error++;
      }
  }
  {
    BITCODE_BL unknown_bl2;
    if (dwg_dynapi_entity_value(perssubentmanager, "PERSSUBENTMANAGER", "unknown_bl2", &unknown_bl2, NULL) &&
        unknown_bl2 == perssubentmanager->unknown_bl2)
      pass ("PERSSUBENTMANAGER.unknown_bl2 [BL]");
    else
      {
        fail ("PERSSUBENTMANAGER.unknown_bl2 [BL] %u != %u", perssubentmanager->unknown_bl2, unknown_bl2); error++;
      }
  }
  {
    BITCODE_BL unknown_bl3;
    if (dwg_dynapi_entity_value(perssubentmanager, "PERSSUBENTMANAGER", "unknown_bl3", &unknown_bl3, NULL) &&
        unknown_bl3 == perssubentmanager->unknown_bl3)
      pass ("PERSSUBENTMANAGER.unknown_bl3 [BL]");
    else
      {
        fail ("PERSSUBENTMANAGER.unknown_bl3 [BL] %u != %u", perssubentmanager->unknown_bl3, unknown_bl3); error++;
      }
  }
  {
    BITCODE_BL unknown_bl4;
    if (dwg_dynapi_entity_value(perssubentmanager, "PERSSUBENTMANAGER", "unknown_bl4", &unknown_bl4, NULL) &&
        unknown_bl4 == perssubentmanager->unknown_bl4)
      pass ("PERSSUBENTMANAGER.unknown_bl4 [BL]");
    else
      {
        fail ("PERSSUBENTMANAGER.unknown_bl4 [BL] %u != %u", perssubentmanager->unknown_bl4, unknown_bl4); error++;
      }
  }
  {
    BITCODE_BL unknown_bl5;
    if (dwg_dynapi_entity_value(perssubentmanager, "PERSSUBENTMANAGER", "unknown_bl5", &unknown_bl5, NULL) &&
        unknown_bl5 == perssubentmanager->unknown_bl5)
      pass ("PERSSUBENTMANAGER.unknown_bl5 [BL]");
    else
      {
        fail ("PERSSUBENTMANAGER.unknown_bl5 [BL] %u != %u", perssubentmanager->unknown_bl5, unknown_bl5); error++;
      }
  }
  {
    BITCODE_BL unknown_bl6;
    if (dwg_dynapi_entity_value(perssubentmanager, "PERSSUBENTMANAGER", "unknown_bl6", &unknown_bl6, NULL) &&
        unknown_bl6 == perssubentmanager->unknown_bl6)
      pass ("PERSSUBENTMANAGER.unknown_bl6 [BL]");
    else
      {
        fail ("PERSSUBENTMANAGER.unknown_bl6 [BL] %u != %u", perssubentmanager->unknown_bl6, unknown_bl6); error++;
      }
  }
  return error;
}
static int test_PLACEHOLDER (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_PLACEHOLDER *placeholder = obj->tio.object->tio.PLACEHOLDER;
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(placeholder, "PLACEHOLDER", "ownerhandle", &ownerhandle, NULL) &&
        ownerhandle == placeholder->ownerhandle)
      pass ("PLACEHOLDER.ownerhandle [H]");
    else
      {
        fail ("PLACEHOLDER.ownerhandle [H] %p != %p", placeholder->ownerhandle, ownerhandle); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(placeholder, "PLACEHOLDER", "parent", &parent, NULL)
        && !memcmp(&parent, &placeholder->parent, sizeof(placeholder->parent)))
      pass ("PLACEHOLDER.parent");
    else
      {
        fail ("PLACEHOLDER.parent"); error++;
      }
  }
  return error;
}
static int test_PLOTSETTINGS (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_PLOTSETTINGS *plotsettings = obj->tio.object->tio.PLOTSETTINGS;
  {
    BITCODE_BD bottom_margin;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "bottom_margin", &bottom_margin, NULL) &&
        bottom_margin == plotsettings->bottom_margin)
      pass ("PLOTSETTINGS.bottom_margin [BD]");
    else
      {
        fail ("PLOTSETTINGS.bottom_margin [BD] %g != %g", plotsettings->bottom_margin, bottom_margin); error++;
      }
  }
  {
    BITCODE_BD den_custom_print_scale;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "den_custom_print_scale", &den_custom_print_scale, NULL) &&
        den_custom_print_scale == plotsettings->den_custom_print_scale)
      pass ("PLOTSETTINGS.den_custom_print_scale [BD]");
    else
      {
        fail ("PLOTSETTINGS.den_custom_print_scale [BD] %g != %g", plotsettings->den_custom_print_scale, den_custom_print_scale); error++;
      }
  }
  {
    BITCODE_BD left_margin;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "left_margin", &left_margin, NULL) &&
        left_margin == plotsettings->left_margin)
      pass ("PLOTSETTINGS.left_margin [BD]");
    else
      {
        fail ("PLOTSETTINGS.left_margin [BD] %g != %g", plotsettings->left_margin, left_margin); error++;
      }
  }
  {
    BITCODE_BD num_custom_print_scale;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "num_custom_print_scale", &num_custom_print_scale, NULL) &&
        num_custom_print_scale == plotsettings->num_custom_print_scale)
      pass ("PLOTSETTINGS.num_custom_print_scale [BD]");
    else
      {
        fail ("PLOTSETTINGS.num_custom_print_scale [BD] %g != %g", plotsettings->num_custom_print_scale, num_custom_print_scale); error++;
      }
  }
  {
    BITCODE_T page_setup_name;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "page_setup_name", &page_setup_name, NULL)
        && !memcmp(&page_setup_name, &plotsettings->page_setup_name, sizeof(plotsettings->page_setup_name)))
      pass ("PLOTSETTINGS.page_setup_name");
    else
      {
        fail ("PLOTSETTINGS.page_setup_name"); error++;
      }
  }
  {
    BITCODE_BD paper_height;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "paper_height", &paper_height, NULL) &&
        paper_height == plotsettings->paper_height)
      pass ("PLOTSETTINGS.paper_height [BD]");
    else
      {
        fail ("PLOTSETTINGS.paper_height [BD] %g != %g", plotsettings->paper_height, paper_height); error++;
      }
  }
  {
    BITCODE_2BD paper_image_origin;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "paper_image_origin", &paper_image_origin, NULL)
        && !memcmp(&paper_image_origin, &plotsettings->paper_image_origin, sizeof(plotsettings->paper_image_origin)))
      pass ("PLOTSETTINGS.paper_image_origin");
    else
      {
        fail ("PLOTSETTINGS.paper_image_origin"); error++;
      }
  }
  {
    BITCODE_T paper_size;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "paper_size", &paper_size, NULL)
        && !memcmp(&paper_size, &plotsettings->paper_size, sizeof(plotsettings->paper_size)))
      pass ("PLOTSETTINGS.paper_size");
    else
      {
        fail ("PLOTSETTINGS.paper_size"); error++;
      }
  }
  {
    BITCODE_BD paper_width;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "paper_width", &paper_width, NULL) &&
        paper_width == plotsettings->paper_width)
      pass ("PLOTSETTINGS.paper_width [BD]");
    else
      {
        fail ("PLOTSETTINGS.paper_width [BD] %g != %g", plotsettings->paper_width, paper_width); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "parent", &parent, NULL)
        && !memcmp(&parent, &plotsettings->parent, sizeof(plotsettings->parent)))
      pass ("PLOTSETTINGS.parent");
    else
      {
        fail ("PLOTSETTINGS.parent"); error++;
      }
  }
  {
    BITCODE_BS plot_layout;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "plot_layout", &plot_layout, NULL) &&
        plot_layout == plotsettings->plot_layout)
      pass ("PLOTSETTINGS.plot_layout [BS]");
    else
      {
        fail ("PLOTSETTINGS.plot_layout [BS] %d != %d", plotsettings->plot_layout, plot_layout); error++;
      }
  }
  {
    BITCODE_2BD plot_origin;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "plot_origin", &plot_origin, NULL)
        && !memcmp(&plot_origin, &plotsettings->plot_origin, sizeof(plotsettings->plot_origin)))
      pass ("PLOTSETTINGS.plot_origin");
    else
      {
        fail ("PLOTSETTINGS.plot_origin"); error++;
      }
  }
  {
    BITCODE_BS plot_paper_units;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "plot_paper_units", &plot_paper_units, NULL) &&
        plot_paper_units == plotsettings->plot_paper_units)
      pass ("PLOTSETTINGS.plot_paper_units [BS]");
    else
      {
        fail ("PLOTSETTINGS.plot_paper_units [BS] %d != %d", plotsettings->plot_paper_units, plot_paper_units); error++;
      }
  }
  {
    BITCODE_BS plot_rotation;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "plot_rotation", &plot_rotation, NULL) &&
        plot_rotation == plotsettings->plot_rotation)
      pass ("PLOTSETTINGS.plot_rotation [BS]");
    else
      {
        fail ("PLOTSETTINGS.plot_rotation [BS] %d != %d", plotsettings->plot_rotation, plot_rotation); error++;
      }
  }
  {
    BITCODE_BS plot_type;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "plot_type", &plot_type, NULL) &&
        plot_type == plotsettings->plot_type)
      pass ("PLOTSETTINGS.plot_type [BS]");
    else
      {
        fail ("PLOTSETTINGS.plot_type [BS] %d != %d", plotsettings->plot_type, plot_type); error++;
      }
  }
  {
    BITCODE_2BD plot_window_ll;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "plot_window_ll", &plot_window_ll, NULL)
        && !memcmp(&plot_window_ll, &plotsettings->plot_window_ll, sizeof(plotsettings->plot_window_ll)))
      pass ("PLOTSETTINGS.plot_window_ll");
    else
      {
        fail ("PLOTSETTINGS.plot_window_ll"); error++;
      }
  }
  {
    BITCODE_2BD plot_window_ur;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "plot_window_ur", &plot_window_ur, NULL)
        && !memcmp(&plot_window_ur, &plotsettings->plot_window_ur, sizeof(plotsettings->plot_window_ur)))
      pass ("PLOTSETTINGS.plot_window_ur");
    else
      {
        fail ("PLOTSETTINGS.plot_window_ur"); error++;
      }
  }
  {
    BITCODE_H plotview;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "plotview", &plotview, NULL) &&
        plotview == plotsettings->plotview)
      pass ("PLOTSETTINGS.plotview [H]");
    else
      {
        fail ("PLOTSETTINGS.plotview [H] %p != %p", plotsettings->plotview, plotview); error++;
      }
  }
  {
    BITCODE_T printer_cfg_file;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "printer_cfg_file", &printer_cfg_file, NULL)
        && !memcmp(&printer_cfg_file, &plotsettings->printer_cfg_file, sizeof(plotsettings->printer_cfg_file)))
      pass ("PLOTSETTINGS.printer_cfg_file");
    else
      {
        fail ("PLOTSETTINGS.printer_cfg_file"); error++;
      }
  }
  {
    BITCODE_BD right_margin;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "right_margin", &right_margin, NULL) &&
        right_margin == plotsettings->right_margin)
      pass ("PLOTSETTINGS.right_margin [BD]");
    else
      {
        fail ("PLOTSETTINGS.right_margin [BD] %g != %g", plotsettings->right_margin, right_margin); error++;
      }
  }
  {
    BITCODE_BS shade_plot_custom_dpi;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "shade_plot_custom_dpi", &shade_plot_custom_dpi, NULL) &&
        shade_plot_custom_dpi == plotsettings->shade_plot_custom_dpi)
      pass ("PLOTSETTINGS.shade_plot_custom_dpi [BS]");
    else
      {
        fail ("PLOTSETTINGS.shade_plot_custom_dpi [BS] %d != %d", plotsettings->shade_plot_custom_dpi, shade_plot_custom_dpi); error++;
      }
  }
  {
    BITCODE_H  shade_plot_id;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "shade_plot_id", &shade_plot_id, NULL) &&
        shade_plot_id == plotsettings->shade_plot_id)
      pass ("PLOTSETTINGS.shade_plot_id [H ]");
    else
      {
        fail ("PLOTSETTINGS.shade_plot_id [H ] %p != %p", plotsettings->shade_plot_id, shade_plot_id); error++;
      }
  }
  {
    BITCODE_BS shade_plot_mode;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "shade_plot_mode", &shade_plot_mode, NULL) &&
        shade_plot_mode == plotsettings->shade_plot_mode)
      pass ("PLOTSETTINGS.shade_plot_mode [BS]");
    else
      {
        fail ("PLOTSETTINGS.shade_plot_mode [BS] %d != %d", plotsettings->shade_plot_mode, shade_plot_mode); error++;
      }
  }
  {
    BITCODE_BS shade_plot_res_level;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "shade_plot_res_level", &shade_plot_res_level, NULL) &&
        shade_plot_res_level == plotsettings->shade_plot_res_level)
      pass ("PLOTSETTINGS.shade_plot_res_level [BS]");
    else
      {
        fail ("PLOTSETTINGS.shade_plot_res_level [BS] %d != %d", plotsettings->shade_plot_res_level, shade_plot_res_level); error++;
      }
  }
  {
    BITCODE_BD std_scale_factor;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "std_scale_factor", &std_scale_factor, NULL) &&
        std_scale_factor == plotsettings->std_scale_factor)
      pass ("PLOTSETTINGS.std_scale_factor [BD]");
    else
      {
        fail ("PLOTSETTINGS.std_scale_factor [BD] %g != %g", plotsettings->std_scale_factor, std_scale_factor); error++;
      }
  }
  {
    BITCODE_BS std_scale_type;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "std_scale_type", &std_scale_type, NULL) &&
        std_scale_type == plotsettings->std_scale_type)
      pass ("PLOTSETTINGS.std_scale_type [BS]");
    else
      {
        fail ("PLOTSETTINGS.std_scale_type [BS] %d != %d", plotsettings->std_scale_type, std_scale_type); error++;
      }
  }
  {
    BITCODE_H stylesheet;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "stylesheet", &stylesheet, NULL) &&
        stylesheet == plotsettings->stylesheet)
      pass ("PLOTSETTINGS.stylesheet [H]");
    else
      {
        fail ("PLOTSETTINGS.stylesheet [H] %p != %p", plotsettings->stylesheet, stylesheet); error++;
      }
  }
  {
    BITCODE_BD top_margin;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "top_margin", &top_margin, NULL) &&
        top_margin == plotsettings->top_margin)
      pass ("PLOTSETTINGS.top_margin [BD]");
    else
      {
        fail ("PLOTSETTINGS.top_margin [BD] %g != %g", plotsettings->top_margin, top_margin); error++;
      }
  }
  {
    BITCODE_B use_std_scale;
    if (dwg_dynapi_entity_value(plotsettings, "PLOTSETTINGS", "use_std_scale", &use_std_scale, NULL) &&
        use_std_scale == plotsettings->use_std_scale)
      pass ("PLOTSETTINGS.use_std_scale [B]");
    else
      {
        fail ("PLOTSETTINGS.use_std_scale [B] " FORMAT_B " != " FORMAT_B "", plotsettings->use_std_scale, use_std_scale); error++;
      }
  }
  return error;
}
static int test_PROXY_OBJECT (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_PROXY_OBJECT *proxy_object = obj->tio.object->tio.PROXY_OBJECT;
  {
    BITCODE_BL class_id;
    if (dwg_dynapi_entity_value(proxy_object, "PROXY_OBJECT", "class_id", &class_id, NULL) &&
        class_id == proxy_object->class_id)
      pass ("PROXY_OBJECT.class_id [BL]");
    else
      {
        fail ("PROXY_OBJECT.class_id [BL] %u != %u", proxy_object->class_id, class_id); error++;
      }
  }
  {
    BITCODE_TV data;
    if (dwg_dynapi_entity_value(proxy_object, "PROXY_OBJECT", "data", &data, NULL)
        && !strcmp((char*)&data, (char*)&proxy_object->data))
      pass ("PROXY_OBJECT.data");
    else
      {
        fail ("PROXY_OBJECT.data"); error++;
      }
  }
  {
    BITCODE_B from_dxf;
    if (dwg_dynapi_entity_value(proxy_object, "PROXY_OBJECT", "from_dxf", &from_dxf, NULL) &&
        from_dxf == proxy_object->from_dxf)
      pass ("PROXY_OBJECT.from_dxf [B]");
    else
      {
        fail ("PROXY_OBJECT.from_dxf [B] " FORMAT_B " != " FORMAT_B "", proxy_object->from_dxf, from_dxf); error++;
      }
  }
  {
    BITCODE_BL maint_version;
    if (dwg_dynapi_entity_value(proxy_object, "PROXY_OBJECT", "maint_version", &maint_version, NULL) &&
        maint_version == proxy_object->maint_version)
      pass ("PROXY_OBJECT.maint_version [BL]");
    else
      {
        fail ("PROXY_OBJECT.maint_version [BL] %u != %u", proxy_object->maint_version, maint_version); error++;
      }
  }
  {
    BITCODE_H* objid_object_handles;
    if (dwg_dynapi_entity_value(proxy_object, "PROXY_OBJECT", "objid_object_handles", &objid_object_handles, NULL)
        && !memcmp(&objid_object_handles, &proxy_object->objid_object_handles, sizeof(proxy_object->objid_object_handles)))
      pass ("PROXY_OBJECT.objid_object_handles");
    else
      {
        fail ("PROXY_OBJECT.objid_object_handles"); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(proxy_object, "PROXY_OBJECT", "ownerhandle", &ownerhandle, NULL) &&
        ownerhandle == proxy_object->ownerhandle)
      pass ("PROXY_OBJECT.ownerhandle [H]");
    else
      {
        fail ("PROXY_OBJECT.ownerhandle [H] %p != %p", proxy_object->ownerhandle, ownerhandle); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(proxy_object, "PROXY_OBJECT", "parent", &parent, NULL)
        && !memcmp(&parent, &proxy_object->parent, sizeof(proxy_object->parent)))
      pass ("PROXY_OBJECT.parent");
    else
      {
        fail ("PROXY_OBJECT.parent"); error++;
      }
  }
  {
    BITCODE_BL version;
    if (dwg_dynapi_entity_value(proxy_object, "PROXY_OBJECT", "version", &version, NULL) &&
        version == proxy_object->version)
      pass ("PROXY_OBJECT.version [BL]");
    else
      {
        fail ("PROXY_OBJECT.version [BL] %u != %u", proxy_object->version, version); error++;
      }
  }
  return error;
}
static int test_RASTERVARIABLES (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_RASTERVARIABLES *rastervariables = obj->tio.object->tio.RASTERVARIABLES;
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value(rastervariables, "RASTERVARIABLES", "class_version", &class_version, NULL) &&
        class_version == rastervariables->class_version)
      pass ("RASTERVARIABLES.class_version [BL]");
    else
      {
        fail ("RASTERVARIABLES.class_version [BL] %u != %u", rastervariables->class_version, class_version); error++;
      }
  }
  {
    BITCODE_BS display_frame;
    if (dwg_dynapi_entity_value(rastervariables, "RASTERVARIABLES", "display_frame", &display_frame, NULL) &&
        display_frame == rastervariables->display_frame)
      pass ("RASTERVARIABLES.display_frame [BS]");
    else
      {
        fail ("RASTERVARIABLES.display_frame [BS] %d != %d", rastervariables->display_frame, display_frame); error++;
      }
  }
  {
    BITCODE_BS display_quality;
    if (dwg_dynapi_entity_value(rastervariables, "RASTERVARIABLES", "display_quality", &display_quality, NULL) &&
        display_quality == rastervariables->display_quality)
      pass ("RASTERVARIABLES.display_quality [BS]");
    else
      {
        fail ("RASTERVARIABLES.display_quality [BS] %d != %d", rastervariables->display_quality, display_quality); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(rastervariables, "RASTERVARIABLES", "ownerhandle", &ownerhandle, NULL) &&
        ownerhandle == rastervariables->ownerhandle)
      pass ("RASTERVARIABLES.ownerhandle [H]");
    else
      {
        fail ("RASTERVARIABLES.ownerhandle [H] %p != %p", rastervariables->ownerhandle, ownerhandle); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(rastervariables, "RASTERVARIABLES", "parent", &parent, NULL)
        && !memcmp(&parent, &rastervariables->parent, sizeof(rastervariables->parent)))
      pass ("RASTERVARIABLES.parent");
    else
      {
        fail ("RASTERVARIABLES.parent"); error++;
      }
  }
  {
    BITCODE_BS units;
    if (dwg_dynapi_entity_value(rastervariables, "RASTERVARIABLES", "units", &units, NULL) &&
        units == rastervariables->units)
      pass ("RASTERVARIABLES.units [BS]");
    else
      {
        fail ("RASTERVARIABLES.units [BS] %d != %d", rastervariables->units, units); error++;
      }
  }
  return error;
}
static int test_SCALE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_SCALE *scale = obj->tio.object->tio.SCALE;
  {
    BITCODE_BD drawing_units;
    if (dwg_dynapi_entity_value(scale, "SCALE", "drawing_units", &drawing_units, NULL) &&
        drawing_units == scale->drawing_units)
      pass ("SCALE.drawing_units [BD]");
    else
      {
        fail ("SCALE.drawing_units [BD] %g != %g", scale->drawing_units, drawing_units); error++;
      }
  }
  {
    BITCODE_BS flag;
    if (dwg_dynapi_entity_value(scale, "SCALE", "flag", &flag, NULL) &&
        flag == scale->flag)
      pass ("SCALE.flag [BS]");
    else
      {
        fail ("SCALE.flag [BS] %d != %d", scale->flag, flag); error++;
      }
  }
  {
    BITCODE_B has_unit_scale;
    if (dwg_dynapi_entity_value(scale, "SCALE", "has_unit_scale", &has_unit_scale, NULL) &&
        has_unit_scale == scale->has_unit_scale)
      pass ("SCALE.has_unit_scale [B]");
    else
      {
        fail ("SCALE.has_unit_scale [B] " FORMAT_B " != " FORMAT_B "", scale->has_unit_scale, has_unit_scale); error++;
      }
  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value(scale, "SCALE", "name", &name, NULL)
        && !strcmp((char*)&name, (char*)&scale->name))
      pass ("SCALE.name");
    else
      {
        fail ("SCALE.name"); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(scale, "SCALE", "ownerhandle", &ownerhandle, NULL) &&
        ownerhandle == scale->ownerhandle)
      pass ("SCALE.ownerhandle [H]");
    else
      {
        fail ("SCALE.ownerhandle [H] %p != %p", scale->ownerhandle, ownerhandle); error++;
      }
  }
  {
    BITCODE_BD paper_units;
    if (dwg_dynapi_entity_value(scale, "SCALE", "paper_units", &paper_units, NULL) &&
        paper_units == scale->paper_units)
      pass ("SCALE.paper_units [BD]");
    else
      {
        fail ("SCALE.paper_units [BD] %g != %g", scale->paper_units, paper_units); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(scale, "SCALE", "parent", &parent, NULL)
        && !memcmp(&parent, &scale->parent, sizeof(scale->parent)))
      pass ("SCALE.parent");
    else
      {
        fail ("SCALE.parent"); error++;
      }
  }
  return error;
}
static int test_SORTENTSTABLE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_SORTENTSTABLE *sortentstable = obj->tio.object->tio.SORTENTSTABLE;
  {
    BITCODE_H* ents;
    if (dwg_dynapi_entity_value(sortentstable, "SORTENTSTABLE", "ents", &ents, NULL)
        && !memcmp(&ents, &sortentstable->ents, sizeof(sortentstable->ents)))
      pass ("SORTENTSTABLE.ents");
    else
      {
        fail ("SORTENTSTABLE.ents"); error++;
      }
  }
  {
    BITCODE_BL num_ents;
    if (dwg_dynapi_entity_value(sortentstable, "SORTENTSTABLE", "num_ents", &num_ents, NULL) &&
        num_ents == sortentstable->num_ents)
      pass ("SORTENTSTABLE.num_ents [BL]");
    else
      {
        fail ("SORTENTSTABLE.num_ents [BL] %u != %u", sortentstable->num_ents, num_ents); error++;
      }
  }
  {
    BITCODE_H owner_dict;
    if (dwg_dynapi_entity_value(sortentstable, "SORTENTSTABLE", "owner_dict", &owner_dict, NULL) &&
        owner_dict == sortentstable->owner_dict)
      pass ("SORTENTSTABLE.owner_dict [H]");
    else
      {
        fail ("SORTENTSTABLE.owner_dict [H] %p != %p", sortentstable->owner_dict, owner_dict); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(sortentstable, "SORTENTSTABLE", "ownerhandle", &ownerhandle, NULL) &&
        ownerhandle == sortentstable->ownerhandle)
      pass ("SORTENTSTABLE.ownerhandle [H]");
    else
      {
        fail ("SORTENTSTABLE.ownerhandle [H] %p != %p", sortentstable->ownerhandle, ownerhandle); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(sortentstable, "SORTENTSTABLE", "parent", &parent, NULL)
        && !memcmp(&parent, &sortentstable->parent, sizeof(sortentstable->parent)))
      pass ("SORTENTSTABLE.parent");
    else
      {
        fail ("SORTENTSTABLE.parent"); error++;
      }
  }
  {
    BITCODE_H* sort_handles;
    if (dwg_dynapi_entity_value(sortentstable, "SORTENTSTABLE", "sort_handles", &sort_handles, NULL)
        && !memcmp(&sort_handles, &sortentstable->sort_handles, sizeof(sortentstable->sort_handles)))
      pass ("SORTENTSTABLE.sort_handles");
    else
      {
        fail ("SORTENTSTABLE.sort_handles"); error++;
      }
  }
  return error;
}
static int test_SPATIAL_FILTER (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_SPATIAL_FILTER *spatial_filter = obj->tio.object->tio.SPATIAL_FILTER;
  {
    BITCODE_BD back_clip_dist;
    if (dwg_dynapi_entity_value(spatial_filter, "SPATIAL_FILTER", "back_clip_dist", &back_clip_dist, NULL) &&
        back_clip_dist == spatial_filter->back_clip_dist)
      pass ("SPATIAL_FILTER.back_clip_dist [BD]");
    else
      {
        fail ("SPATIAL_FILTER.back_clip_dist [BD] %g != %g", spatial_filter->back_clip_dist, back_clip_dist); error++;
      }
  }
  {
    BITCODE_BS back_clip_on;
    if (dwg_dynapi_entity_value(spatial_filter, "SPATIAL_FILTER", "back_clip_on", &back_clip_on, NULL) &&
        back_clip_on == spatial_filter->back_clip_on)
      pass ("SPATIAL_FILTER.back_clip_on [BS]");
    else
      {
        fail ("SPATIAL_FILTER.back_clip_on [BS] %d != %d", spatial_filter->back_clip_on, back_clip_on); error++;
      }
  }
  {
    BITCODE_3BD clip_bound_origin;
    if (dwg_dynapi_entity_value(spatial_filter, "SPATIAL_FILTER", "clip_bound_origin", &clip_bound_origin, NULL)
        && !memcmp(&clip_bound_origin, &spatial_filter->clip_bound_origin, sizeof(spatial_filter->clip_bound_origin)))
      pass ("SPATIAL_FILTER.clip_bound_origin");
    else
      {
        fail ("SPATIAL_FILTER.clip_bound_origin"); error++;
      }
  }
  {
    BITCODE_BD* clip_bound_transform;
    if (dwg_dynapi_entity_value(spatial_filter, "SPATIAL_FILTER", "clip_bound_transform", &clip_bound_transform, NULL)
        && !memcmp(&clip_bound_transform, &spatial_filter->clip_bound_transform, sizeof(spatial_filter->clip_bound_transform)))
      pass ("SPATIAL_FILTER.clip_bound_transform");
    else
      {
        fail ("SPATIAL_FILTER.clip_bound_transform"); error++;
      }
  }
  {
    BITCODE_BS display_boundary;
    if (dwg_dynapi_entity_value(spatial_filter, "SPATIAL_FILTER", "display_boundary", &display_boundary, NULL) &&
        display_boundary == spatial_filter->display_boundary)
      pass ("SPATIAL_FILTER.display_boundary [BS]");
    else
      {
        fail ("SPATIAL_FILTER.display_boundary [BS] %d != %d", spatial_filter->display_boundary, display_boundary); error++;
      }
  }
  {
    BITCODE_3BD extrusion;
    if (dwg_dynapi_entity_value(spatial_filter, "SPATIAL_FILTER", "extrusion", &extrusion, NULL)
        && !memcmp(&extrusion, &spatial_filter->extrusion, sizeof(spatial_filter->extrusion)))
      pass ("SPATIAL_FILTER.extrusion");
    else
      {
        fail ("SPATIAL_FILTER.extrusion"); error++;
      }
  }
  {
    BITCODE_BD front_clip_dist;
    if (dwg_dynapi_entity_value(spatial_filter, "SPATIAL_FILTER", "front_clip_dist", &front_clip_dist, NULL) &&
        front_clip_dist == spatial_filter->front_clip_dist)
      pass ("SPATIAL_FILTER.front_clip_dist [BD]");
    else
      {
        fail ("SPATIAL_FILTER.front_clip_dist [BD] %g != %g", spatial_filter->front_clip_dist, front_clip_dist); error++;
      }
  }
  {
    BITCODE_BS front_clip_on;
    if (dwg_dynapi_entity_value(spatial_filter, "SPATIAL_FILTER", "front_clip_on", &front_clip_on, NULL) &&
        front_clip_on == spatial_filter->front_clip_on)
      pass ("SPATIAL_FILTER.front_clip_on [BS]");
    else
      {
        fail ("SPATIAL_FILTER.front_clip_on [BS] %d != %d", spatial_filter->front_clip_on, front_clip_on); error++;
      }
  }
  {
    BITCODE_BD* inverse_block_transform;
    if (dwg_dynapi_entity_value(spatial_filter, "SPATIAL_FILTER", "inverse_block_transform", &inverse_block_transform, NULL)
        && !memcmp(&inverse_block_transform, &spatial_filter->inverse_block_transform, sizeof(spatial_filter->inverse_block_transform)))
      pass ("SPATIAL_FILTER.inverse_block_transform");
    else
      {
        fail ("SPATIAL_FILTER.inverse_block_transform"); error++;
      }
  }
  {
    BITCODE_BS num_points;
    if (dwg_dynapi_entity_value(spatial_filter, "SPATIAL_FILTER", "num_points", &num_points, NULL) &&
        num_points == spatial_filter->num_points)
      pass ("SPATIAL_FILTER.num_points [BS]");
    else
      {
        fail ("SPATIAL_FILTER.num_points [BS] %d != %d", spatial_filter->num_points, num_points); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(spatial_filter, "SPATIAL_FILTER", "ownerhandle", &ownerhandle, NULL) &&
        ownerhandle == spatial_filter->ownerhandle)
      pass ("SPATIAL_FILTER.ownerhandle [H]");
    else
      {
        fail ("SPATIAL_FILTER.ownerhandle [H] %p != %p", spatial_filter->ownerhandle, ownerhandle); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(spatial_filter, "SPATIAL_FILTER", "parent", &parent, NULL)
        && !memcmp(&parent, &spatial_filter->parent, sizeof(spatial_filter->parent)))
      pass ("SPATIAL_FILTER.parent");
    else
      {
        fail ("SPATIAL_FILTER.parent"); error++;
      }
  }
  {
    BITCODE_2RD* points;
    if (dwg_dynapi_entity_value(spatial_filter, "SPATIAL_FILTER", "points", &points, NULL)
        && !memcmp(&points, &spatial_filter->points, sizeof(spatial_filter->points)))
      pass ("SPATIAL_FILTER.points");
    else
      {
        fail ("SPATIAL_FILTER.points"); error++;
      }
  }
  return error;
}
static int test_SPATIAL_INDEX (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_SPATIAL_INDEX *spatial_index = obj->tio.object->tio.SPATIAL_INDEX;
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(spatial_index, "SPATIAL_INDEX", "ownerhandle", &ownerhandle, NULL) &&
        ownerhandle == spatial_index->ownerhandle)
      pass ("SPATIAL_INDEX.ownerhandle [H]");
    else
      {
        fail ("SPATIAL_INDEX.ownerhandle [H] %p != %p", spatial_index->ownerhandle, ownerhandle); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(spatial_index, "SPATIAL_INDEX", "parent", &parent, NULL)
        && !memcmp(&parent, &spatial_index->parent, sizeof(spatial_index->parent)))
      pass ("SPATIAL_INDEX.parent");
    else
      {
        fail ("SPATIAL_INDEX.parent"); error++;
      }
  }
  {
    BITCODE_BL timestamp1;
    if (dwg_dynapi_entity_value(spatial_index, "SPATIAL_INDEX", "timestamp1", &timestamp1, NULL) &&
        timestamp1 == spatial_index->timestamp1)
      pass ("SPATIAL_INDEX.timestamp1 [BL]");
    else
      {
        fail ("SPATIAL_INDEX.timestamp1 [BL] %u != %u", spatial_index->timestamp1, timestamp1); error++;
      }
  }
  {
    BITCODE_BL timestamp2;
    if (dwg_dynapi_entity_value(spatial_index, "SPATIAL_INDEX", "timestamp2", &timestamp2, NULL) &&
        timestamp2 == spatial_index->timestamp2)
      pass ("SPATIAL_INDEX.timestamp2 [BL]");
    else
      {
        fail ("SPATIAL_INDEX.timestamp2 [BL] %u != %u", spatial_index->timestamp2, timestamp2); error++;
      }
  }
  {
    BITCODE_TV unknown;
    if (dwg_dynapi_entity_value(spatial_index, "SPATIAL_INDEX", "unknown", &unknown, NULL)
        && !strcmp((char*)&unknown, (char*)&spatial_index->unknown))
      pass ("SPATIAL_INDEX.unknown");
    else
      {
        fail ("SPATIAL_INDEX.unknown"); error++;
      }
  }
  return error;
}
static int test_STYLE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_STYLE *style = obj->tio.object->tio.STYLE;
  {
    BITCODE_TV bigfont_name;
    if (dwg_dynapi_entity_value(style, "STYLE", "bigfont_name", &bigfont_name, NULL)
        && !strcmp((char*)&bigfont_name, (char*)&style->bigfont_name))
      pass ("STYLE.bigfont_name");
    else
      {
        fail ("STYLE.bigfont_name"); error++;
      }
  }
  {
    BITCODE_BD fixed_height;
    if (dwg_dynapi_entity_value(style, "STYLE", "fixed_height", &fixed_height, NULL) &&
        fixed_height == style->fixed_height)
      pass ("STYLE.fixed_height [BD]");
    else
      {
        fail ("STYLE.fixed_height [BD] %g != %g", style->fixed_height, fixed_height); error++;
      }
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value(style, "STYLE", "flag", &flag, NULL) &&
        flag == style->flag)
      pass ("STYLE.flag [RC]");
    else
      {
        fail ("STYLE.flag [RC] %c != %c", style->flag, flag); error++;
      }
  }
  {
    BITCODE_TV font_name;
    if (dwg_dynapi_entity_value(style, "STYLE", "font_name", &font_name, NULL)
        && !strcmp((char*)&font_name, (char*)&style->font_name))
      pass ("STYLE.font_name");
    else
      {
        fail ("STYLE.font_name"); error++;
      }
  }
  {
    BITCODE_RC generation;
    if (dwg_dynapi_entity_value(style, "STYLE", "generation", &generation, NULL) &&
        generation == style->generation)
      pass ("STYLE.generation [RC]");
    else
      {
        fail ("STYLE.generation [RC] %c != %c", style->generation, generation); error++;
      }
  }
  {
    BITCODE_BD last_height;
    if (dwg_dynapi_entity_value(style, "STYLE", "last_height", &last_height, NULL) &&
        last_height == style->last_height)
      pass ("STYLE.last_height [BD]");
    else
      {
        fail ("STYLE.last_height [BD] %g != %g", style->last_height, last_height); error++;
      }
  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value(style, "STYLE", "name", &name, NULL)
        && !strcmp((char*)&name, (char*)&style->name))
      pass ("STYLE.name");
    else
      {
        fail ("STYLE.name"); error++;
      }
  }
  {
    BITCODE_H null_handle;
    if (dwg_dynapi_entity_value(style, "STYLE", "null_handle", &null_handle, NULL) &&
        null_handle == style->null_handle)
      pass ("STYLE.null_handle [H]");
    else
      {
        fail ("STYLE.null_handle [H] %p != %p", style->null_handle, null_handle); error++;
      }
  }
  {
    BITCODE_BD oblique_ang;
    if (dwg_dynapi_entity_value(style, "STYLE", "oblique_ang", &oblique_ang, NULL) &&
        oblique_ang == style->oblique_ang)
      pass ("STYLE.oblique_ang [BD]");
    else
      {
        fail ("STYLE.oblique_ang [BD] %g != %g", style->oblique_ang, oblique_ang); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(style, "STYLE", "parent", &parent, NULL)
        && !memcmp(&parent, &style->parent, sizeof(style->parent)))
      pass ("STYLE.parent");
    else
      {
        fail ("STYLE.parent"); error++;
      }
  }
  {
    BITCODE_B shape_file;
    if (dwg_dynapi_entity_value(style, "STYLE", "shape_file", &shape_file, NULL) &&
        shape_file == style->shape_file)
      pass ("STYLE.shape_file [B]");
    else
      {
        fail ("STYLE.shape_file [B] " FORMAT_B " != " FORMAT_B "", style->shape_file, shape_file); error++;
      }
  }
  {
    BITCODE_H style_control;
    if (dwg_dynapi_entity_value(style, "STYLE", "style_control", &style_control, NULL) &&
        style_control == style->style_control)
      pass ("STYLE.style_control [H]");
    else
      {
        fail ("STYLE.style_control [H] %p != %p", style->style_control, style_control); error++;
      }
  }
  {
    BITCODE_RS used;
    if (dwg_dynapi_entity_value(style, "STYLE", "used", &used, NULL) &&
        used == style->used)
      pass ("STYLE.used [RS]");
    else
      {
        fail ("STYLE.used [RS] " FORMAT_RS " != " FORMAT_RS "", style->used, used); error++;
      }
  }
  {
    BITCODE_B vertical;
    if (dwg_dynapi_entity_value(style, "STYLE", "vertical", &vertical, NULL) &&
        vertical == style->vertical)
      pass ("STYLE.vertical [B]");
    else
      {
        fail ("STYLE.vertical [B] " FORMAT_B " != " FORMAT_B "", style->vertical, vertical); error++;
      }
  }
  {
    BITCODE_BD width_factor;
    if (dwg_dynapi_entity_value(style, "STYLE", "width_factor", &width_factor, NULL) &&
        width_factor == style->width_factor)
      pass ("STYLE.width_factor [BD]");
    else
      {
        fail ("STYLE.width_factor [BD] %g != %g", style->width_factor, width_factor); error++;
      }
  }
  {
    BITCODE_B xrefdep;
    if (dwg_dynapi_entity_value(style, "STYLE", "xrefdep", &xrefdep, NULL) &&
        xrefdep == style->xrefdep)
      pass ("STYLE.xrefdep [B]");
    else
      {
        fail ("STYLE.xrefdep [B] " FORMAT_B " != " FORMAT_B "", style->xrefdep, xrefdep); error++;
      }
  }
  {
    BITCODE_BS xrefindex_plus1;
    if (dwg_dynapi_entity_value(style, "STYLE", "xrefindex_plus1", &xrefindex_plus1, NULL) &&
        xrefindex_plus1 == style->xrefindex_plus1)
      pass ("STYLE.xrefindex_plus1 [BS]");
    else
      {
        fail ("STYLE.xrefindex_plus1 [BS] %d != %d", style->xrefindex_plus1, xrefindex_plus1); error++;
      }
  }
  {
    BITCODE_B xrefref;
    if (dwg_dynapi_entity_value(style, "STYLE", "xrefref", &xrefref, NULL) &&
        xrefref == style->xrefref)
      pass ("STYLE.xrefref [B]");
    else
      {
        fail ("STYLE.xrefref [B] " FORMAT_B " != " FORMAT_B "", style->xrefref, xrefref); error++;
      }
  }
  return error;
}
static int test_STYLE_CONTROL (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_STYLE_CONTROL *style_control = obj->tio.object->tio.STYLE_CONTROL;
  {
    Dwg_Object_Ref* null_handle;
    if (dwg_dynapi_entity_value(style_control, "STYLE_CONTROL", "null_handle", &null_handle, NULL)
        && !memcmp(&null_handle, &style_control->null_handle, sizeof(style_control->null_handle)))
      pass ("STYLE_CONTROL.null_handle");
    else
      {
        fail ("STYLE_CONTROL.null_handle"); error++;
      }
  }
  {
    BITCODE_BS num_entries;
    if (dwg_dynapi_entity_value(style_control, "STYLE_CONTROL", "num_entries", &num_entries, NULL) &&
        num_entries == style_control->num_entries)
      pass ("STYLE_CONTROL.num_entries [BS]");
    else
      {
        fail ("STYLE_CONTROL.num_entries [BS] %d != %d", style_control->num_entries, num_entries); error++;
      }
  }
  {
    BITCODE_BL objid;
    if (dwg_dynapi_entity_value(style_control, "STYLE_CONTROL", "objid", &objid, NULL) &&
        objid == style_control->objid)
      pass ("STYLE_CONTROL.objid [BL]");
    else
      {
        fail ("STYLE_CONTROL.objid [BL] %u != %u", style_control->objid, objid); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(style_control, "STYLE_CONTROL", "parent", &parent, NULL)
        && !memcmp(&parent, &style_control->parent, sizeof(style_control->parent)))
      pass ("STYLE_CONTROL.parent");
    else
      {
        fail ("STYLE_CONTROL.parent"); error++;
      }
  }
  {
    Dwg_Object_Ref* reactors;
    if (dwg_dynapi_entity_value(style_control, "STYLE_CONTROL", "reactors", &reactors, NULL)
        && !memcmp(&reactors, &style_control->reactors, sizeof(style_control->reactors)))
      pass ("STYLE_CONTROL.reactors");
    else
      {
        fail ("STYLE_CONTROL.reactors"); error++;
      }
  }
  {
    Dwg_Object_Ref* styles;
    if (dwg_dynapi_entity_value(style_control, "STYLE_CONTROL", "styles", &styles, NULL)
        && !memcmp(&styles, &style_control->styles, sizeof(style_control->styles)))
      pass ("STYLE_CONTROL.styles");
    else
      {
        fail ("STYLE_CONTROL.styles"); error++;
      }
  }
  {
    Dwg_Object_Ref* xdicobjhandle;
    if (dwg_dynapi_entity_value(style_control, "STYLE_CONTROL", "xdicobjhandle", &xdicobjhandle, NULL)
        && !memcmp(&xdicobjhandle, &style_control->xdicobjhandle, sizeof(style_control->xdicobjhandle)))
      pass ("STYLE_CONTROL.xdicobjhandle");
    else
      {
        fail ("STYLE_CONTROL.xdicobjhandle"); error++;
      }
  }
  return error;
}
static int test_SUN (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_SUN *sun = obj->tio.object->tio.SUN;
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value(sun, "SUN", "class_version", &class_version, NULL) &&
        class_version == sun->class_version)
      pass ("SUN.class_version [BL]");
    else
      {
        fail ("SUN.class_version [BL] %u != %u", sun->class_version, class_version); error++;
      }
  }
  {
    BITCODE_CMC color;
    if (dwg_dynapi_entity_value(sun, "SUN", "color", &color, NULL)
        && !memcmp(&color, &sun->color, sizeof(sun->color)))
      pass ("SUN.color");
    else
      {
        fail ("SUN.color"); error++;
      }
  }
  {
    BITCODE_B has_shadow;
    if (dwg_dynapi_entity_value(sun, "SUN", "has_shadow", &has_shadow, NULL) &&
        has_shadow == sun->has_shadow)
      pass ("SUN.has_shadow [B]");
    else
      {
        fail ("SUN.has_shadow [B] " FORMAT_B " != " FORMAT_B "", sun->has_shadow, has_shadow); error++;
      }
  }
  {
    BITCODE_BD intensity;
    if (dwg_dynapi_entity_value(sun, "SUN", "intensity", &intensity, NULL) &&
        intensity == sun->intensity)
      pass ("SUN.intensity [BD]");
    else
      {
        fail ("SUN.intensity [BD] %g != %g", sun->intensity, intensity); error++;
      }
  }
  {
    BITCODE_B is_dst;
    if (dwg_dynapi_entity_value(sun, "SUN", "is_dst", &is_dst, NULL) &&
        is_dst == sun->is_dst)
      pass ("SUN.is_dst [B]");
    else
      {
        fail ("SUN.is_dst [B] " FORMAT_B " != " FORMAT_B "", sun->is_dst, is_dst); error++;
      }
  }
  {
    BITCODE_B is_on;
    if (dwg_dynapi_entity_value(sun, "SUN", "is_on", &is_on, NULL) &&
        is_on == sun->is_on)
      pass ("SUN.is_on [B]");
    else
      {
        fail ("SUN.is_on [B] " FORMAT_B " != " FORMAT_B "", sun->is_on, is_on); error++;
      }
  }
  {
    BITCODE_BL julian_day;
    if (dwg_dynapi_entity_value(sun, "SUN", "julian_day", &julian_day, NULL) &&
        julian_day == sun->julian_day)
      pass ("SUN.julian_day [BL]");
    else
      {
        fail ("SUN.julian_day [BL] %u != %u", sun->julian_day, julian_day); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(sun, "SUN", "ownerhandle", &ownerhandle, NULL) &&
        ownerhandle == sun->ownerhandle)
      pass ("SUN.ownerhandle [H]");
    else
      {
        fail ("SUN.ownerhandle [H] %p != %p", sun->ownerhandle, ownerhandle); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(sun, "SUN", "parent", &parent, NULL)
        && !memcmp(&parent, &sun->parent, sizeof(sun->parent)))
      pass ("SUN.parent");
    else
      {
        fail ("SUN.parent"); error++;
      }
  }
  {
    BITCODE_BS shadow_mapsize;
    if (dwg_dynapi_entity_value(sun, "SUN", "shadow_mapsize", &shadow_mapsize, NULL) &&
        shadow_mapsize == sun->shadow_mapsize)
      pass ("SUN.shadow_mapsize [BS]");
    else
      {
        fail ("SUN.shadow_mapsize [BS] %d != %d", sun->shadow_mapsize, shadow_mapsize); error++;
      }
  }
  {
    BITCODE_BS shadow_softness;
    if (dwg_dynapi_entity_value(sun, "SUN", "shadow_softness", &shadow_softness, NULL) &&
        shadow_softness == sun->shadow_softness)
      pass ("SUN.shadow_softness [BS]");
    else
      {
        fail ("SUN.shadow_softness [BS] %d != %d", sun->shadow_softness, shadow_softness); error++;
      }
  }
  {
    BITCODE_BS shadow_type;
    if (dwg_dynapi_entity_value(sun, "SUN", "shadow_type", &shadow_type, NULL) &&
        shadow_type == sun->shadow_type)
      pass ("SUN.shadow_type [BS]");
    else
      {
        fail ("SUN.shadow_type [BS] %d != %d", sun->shadow_type, shadow_type); error++;
      }
  }
  {
    BITCODE_H skyparams;
    if (dwg_dynapi_entity_value(sun, "SUN", "skyparams", &skyparams, NULL) &&
        skyparams == sun->skyparams)
      pass ("SUN.skyparams [H]");
    else
      {
        fail ("SUN.skyparams [H] %p != %p", sun->skyparams, skyparams); error++;
      }
  }
  {
    BITCODE_BL time;
    if (dwg_dynapi_entity_value(sun, "SUN", "time", &time, NULL) &&
        time == sun->time)
      pass ("SUN.time [BL]");
    else
      {
        fail ("SUN.time [BL] %u != %u", sun->time, time); error++;
      }
  }
  {
    BITCODE_BS unknown;
    if (dwg_dynapi_entity_value(sun, "SUN", "unknown", &unknown, NULL) &&
        unknown == sun->unknown)
      pass ("SUN.unknown [BS]");
    else
      {
        fail ("SUN.unknown [BS] %d != %d", sun->unknown, unknown); error++;
      }
  }
  return error;
}
static int test_SUNSTUDY (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_SUNSTUDY *sunstudy = obj->tio.object->tio.SUNSTUDY;
  {
    BITCODE_BL class_version;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "class_version", &class_version, NULL) &&
        class_version == sunstudy->class_version)
      pass ("SUNSTUDY.class_version [BL]");
    else
      {
        fail ("SUNSTUDY.class_version [BL] %u != %u", sunstudy->class_version, class_version); error++;
      }
  }
  {
    Dwg_SUNSTUDY_Dates* dates;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "dates", &dates, NULL)
        && !memcmp(&dates, &sunstudy->dates, sizeof(sunstudy->dates)))
      pass ("SUNSTUDY.dates");
    else
      {
        fail ("SUNSTUDY.dates"); error++;
      }
  }
  {
    BITCODE_T desc;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "desc", &desc, NULL)
        && !memcmp(&desc, &sunstudy->desc, sizeof(sunstudy->desc)))
      pass ("SUNSTUDY.desc");
    else
      {
        fail ("SUNSTUDY.desc"); error++;
      }
  }
  {
    BITCODE_BL end_time;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "end_time", &end_time, NULL) &&
        end_time == sunstudy->end_time)
      pass ("SUNSTUDY.end_time [BL]");
    else
      {
        fail ("SUNSTUDY.end_time [BL] %u != %u", sunstudy->end_time, end_time); error++;
      }
  }
  {
    BITCODE_B* hours;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "hours", &hours, NULL)
        && !memcmp(&hours, &sunstudy->hours, sizeof(sunstudy->hours)))
      pass ("SUNSTUDY.hours");
    else
      {
        fail ("SUNSTUDY.hours"); error++;
      }
  }
  {
    BITCODE_BL interval;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "interval", &interval, NULL) &&
        interval == sunstudy->interval)
      pass ("SUNSTUDY.interval [BL]");
    else
      {
        fail ("SUNSTUDY.interval [BL] %u != %u", sunstudy->interval, interval); error++;
      }
  }
  {
    BITCODE_B label_viewports;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "label_viewports", &label_viewports, NULL) &&
        label_viewports == sunstudy->label_viewports)
      pass ("SUNSTUDY.label_viewports [B]");
    else
      {
        fail ("SUNSTUDY.label_viewports [B] " FORMAT_B " != " FORMAT_B "", sunstudy->label_viewports, label_viewports); error++;
      }
  }
  {
    BITCODE_B lock_viewports;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "lock_viewports", &lock_viewports, NULL) &&
        lock_viewports == sunstudy->lock_viewports)
      pass ("SUNSTUDY.lock_viewports [B]");
    else
      {
        fail ("SUNSTUDY.lock_viewports [B] " FORMAT_B " != " FORMAT_B "", sunstudy->lock_viewports, lock_viewports); error++;
      }
  }
  {
    BITCODE_BL num_dates;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "num_dates", &num_dates, NULL) &&
        num_dates == sunstudy->num_dates)
      pass ("SUNSTUDY.num_dates [BL]");
    else
      {
        fail ("SUNSTUDY.num_dates [BL] %u != %u", sunstudy->num_dates, num_dates); error++;
      }
  }
  {
    BITCODE_BL num_hours;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "num_hours", &num_hours, NULL) &&
        num_hours == sunstudy->num_hours)
      pass ("SUNSTUDY.num_hours [BL]");
    else
      {
        fail ("SUNSTUDY.num_hours [BL] %u != %u", sunstudy->num_hours, num_hours); error++;
      }
  }
  {
    BITCODE_BL numcols;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "numcols", &numcols, NULL) &&
        numcols == sunstudy->numcols)
      pass ("SUNSTUDY.numcols [BL]");
    else
      {
        fail ("SUNSTUDY.numcols [BL] %u != %u", sunstudy->numcols, numcols); error++;
      }
  }
  {
    BITCODE_BL numrows;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "numrows", &numrows, NULL) &&
        numrows == sunstudy->numrows)
      pass ("SUNSTUDY.numrows [BL]");
    else
      {
        fail ("SUNSTUDY.numrows [BL] %u != %u", sunstudy->numrows, numrows); error++;
      }
  }
  {
    BITCODE_BL numvports;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "numvports", &numvports, NULL) &&
        numvports == sunstudy->numvports)
      pass ("SUNSTUDY.numvports [BL]");
    else
      {
        fail ("SUNSTUDY.numvports [BL] %u != %u", sunstudy->numvports, numvports); error++;
      }
  }
  {
    BITCODE_BL output_type;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "output_type", &output_type, NULL) &&
        output_type == sunstudy->output_type)
      pass ("SUNSTUDY.output_type [BL]");
    else
      {
        fail ("SUNSTUDY.output_type [BL] %u != %u", sunstudy->output_type, output_type); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "ownerhandle", &ownerhandle, NULL) &&
        ownerhandle == sunstudy->ownerhandle)
      pass ("SUNSTUDY.ownerhandle [H]");
    else
      {
        fail ("SUNSTUDY.ownerhandle [H] %p != %p", sunstudy->ownerhandle, ownerhandle); error++;
      }
  }
  {
    BITCODE_H page_setup_wizard;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "page_setup_wizard", &page_setup_wizard, NULL) &&
        page_setup_wizard == sunstudy->page_setup_wizard)
      pass ("SUNSTUDY.page_setup_wizard [H]");
    else
      {
        fail ("SUNSTUDY.page_setup_wizard [H] %p != %p", sunstudy->page_setup_wizard, page_setup_wizard); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "parent", &parent, NULL)
        && !memcmp(&parent, &sunstudy->parent, sizeof(sunstudy->parent)))
      pass ("SUNSTUDY.parent");
    else
      {
        fail ("SUNSTUDY.parent"); error++;
      }
  }
  {
    BITCODE_B select_dates_from_calendar;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "select_dates_from_calendar", &select_dates_from_calendar, NULL) &&
        select_dates_from_calendar == sunstudy->select_dates_from_calendar)
      pass ("SUNSTUDY.select_dates_from_calendar [B]");
    else
      {
        fail ("SUNSTUDY.select_dates_from_calendar [B] " FORMAT_B " != " FORMAT_B "", sunstudy->select_dates_from_calendar, select_dates_from_calendar); error++;
      }
  }
  {
    BITCODE_B select_range_of_dates;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "select_range_of_dates", &select_range_of_dates, NULL) &&
        select_range_of_dates == sunstudy->select_range_of_dates)
      pass ("SUNSTUDY.select_range_of_dates [B]");
    else
      {
        fail ("SUNSTUDY.select_range_of_dates [B] " FORMAT_B " != " FORMAT_B "", sunstudy->select_range_of_dates, select_range_of_dates); error++;
      }
  }
  {
    BITCODE_T setup_name;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "setup_name", &setup_name, NULL)
        && !memcmp(&setup_name, &sunstudy->setup_name, sizeof(sunstudy->setup_name)))
      pass ("SUNSTUDY.setup_name");
    else
      {
        fail ("SUNSTUDY.setup_name"); error++;
      }
  }
  {
    BITCODE_BL shade_plot_type;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "shade_plot_type", &shade_plot_type, NULL) &&
        shade_plot_type == sunstudy->shade_plot_type)
      pass ("SUNSTUDY.shade_plot_type [BL]");
    else
      {
        fail ("SUNSTUDY.shade_plot_type [BL] %u != %u", sunstudy->shade_plot_type, shade_plot_type); error++;
      }
  }
  {
    BITCODE_T sheet_set_name;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "sheet_set_name", &sheet_set_name, NULL)
        && !memcmp(&sheet_set_name, &sunstudy->sheet_set_name, sizeof(sunstudy->sheet_set_name)))
      pass ("SUNSTUDY.sheet_set_name");
    else
      {
        fail ("SUNSTUDY.sheet_set_name"); error++;
      }
  }
  {
    BITCODE_T sheet_subset_name;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "sheet_subset_name", &sheet_subset_name, NULL)
        && !memcmp(&sheet_subset_name, &sunstudy->sheet_subset_name, sizeof(sunstudy->sheet_subset_name)))
      pass ("SUNSTUDY.sheet_subset_name");
    else
      {
        fail ("SUNSTUDY.sheet_subset_name"); error++;
      }
  }
  {
    BITCODE_BD spacing;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "spacing", &spacing, NULL) &&
        spacing == sunstudy->spacing)
      pass ("SUNSTUDY.spacing [BD]");
    else
      {
        fail ("SUNSTUDY.spacing [BD] %g != %g", sunstudy->spacing, spacing); error++;
      }
  }
  {
    BITCODE_BL start_time;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "start_time", &start_time, NULL) &&
        start_time == sunstudy->start_time)
      pass ("SUNSTUDY.start_time [BL]");
    else
      {
        fail ("SUNSTUDY.start_time [BL] %u != %u", sunstudy->start_time, start_time); error++;
      }
  }
  {
    BITCODE_H text_style;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "text_style", &text_style, NULL) &&
        text_style == sunstudy->text_style)
      pass ("SUNSTUDY.text_style [H]");
    else
      {
        fail ("SUNSTUDY.text_style [H] %p != %p", sunstudy->text_style, text_style); error++;
      }
  }
  {
    BITCODE_B use_subset;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "use_subset", &use_subset, NULL) &&
        use_subset == sunstudy->use_subset)
      pass ("SUNSTUDY.use_subset [B]");
    else
      {
        fail ("SUNSTUDY.use_subset [B] " FORMAT_B " != " FORMAT_B "", sunstudy->use_subset, use_subset); error++;
      }
  }
  {
    BITCODE_H view;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "view", &view, NULL) &&
        view == sunstudy->view)
      pass ("SUNSTUDY.view [H]");
    else
      {
        fail ("SUNSTUDY.view [H] %p != %p", sunstudy->view, view); error++;
      }
  }
  {
    BITCODE_H visual_style;
    if (dwg_dynapi_entity_value(sunstudy, "SUNSTUDY", "visual_style", &visual_style, NULL) &&
        visual_style == sunstudy->visual_style)
      pass ("SUNSTUDY.visual_style [H]");
    else
      {
        fail ("SUNSTUDY.visual_style [H] %p != %p", sunstudy->visual_style, visual_style); error++;
      }
  }
  return error;
}
static int test_TABLECONTENT (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_TABLECONTENT *tablecontent = obj->tio.object->tio.TABLECONTENT;
  {
    Dwg_FormattedTableData fdata;
    if (dwg_dynapi_entity_value(tablecontent, "TABLECONTENT", "fdata", &fdata, NULL)
        && !memcmp(&fdata, &tablecontent->fdata, sizeof(tablecontent->fdata)))
      pass ("TABLECONTENT.fdata");
    else
      {
        fail ("TABLECONTENT.fdata"); error++;
      }
  }
  {
    Dwg_LinkedData ldata;
    if (dwg_dynapi_entity_value(tablecontent, "TABLECONTENT", "ldata", &ldata, NULL)
        && !memcmp(&ldata, &tablecontent->ldata, sizeof(tablecontent->ldata)))
      pass ("TABLECONTENT.ldata");
    else
      {
        fail ("TABLECONTENT.ldata"); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(tablecontent, "TABLECONTENT", "parent", &parent, NULL)
        && !memcmp(&parent, &tablecontent->parent, sizeof(tablecontent->parent)))
      pass ("TABLECONTENT.parent");
    else
      {
        fail ("TABLECONTENT.parent"); error++;
      }
  }
  {
    BITCODE_H table_style;
    if (dwg_dynapi_entity_value(tablecontent, "TABLECONTENT", "table_style", &table_style, NULL) &&
        table_style == tablecontent->table_style)
      pass ("TABLECONTENT.table_style [H]");
    else
      {
        fail ("TABLECONTENT.table_style [H] %p != %p", tablecontent->table_style, table_style); error++;
      }
  }
  {
    Dwg_LinkedTableData tdata;
    if (dwg_dynapi_entity_value(tablecontent, "TABLECONTENT", "tdata", &tdata, NULL)
        && !memcmp(&tdata, &tablecontent->tdata, sizeof(tablecontent->tdata)))
      pass ("TABLECONTENT.tdata");
    else
      {
        fail ("TABLECONTENT.tdata"); error++;
      }
  }
  return error;
}
static int test_TABLEGEOMETRY (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_TABLEGEOMETRY *tablegeometry = obj->tio.object->tio.TABLEGEOMETRY;
  {
    Dwg_TABLEGEOMETRY_Cell* cells;
    if (dwg_dynapi_entity_value(tablegeometry, "TABLEGEOMETRY", "cells", &cells, NULL)
        && !memcmp(&cells, &tablegeometry->cells, sizeof(tablegeometry->cells)))
      pass ("TABLEGEOMETRY.cells");
    else
      {
        fail ("TABLEGEOMETRY.cells"); error++;
      }
  }
  {
    BITCODE_BL num_cells;
    if (dwg_dynapi_entity_value(tablegeometry, "TABLEGEOMETRY", "num_cells", &num_cells, NULL) &&
        num_cells == tablegeometry->num_cells)
      pass ("TABLEGEOMETRY.num_cells [BL]");
    else
      {
        fail ("TABLEGEOMETRY.num_cells [BL] %u != %u", tablegeometry->num_cells, num_cells); error++;
      }
  }
  {
    BITCODE_BL num_cols;
    if (dwg_dynapi_entity_value(tablegeometry, "TABLEGEOMETRY", "num_cols", &num_cols, NULL) &&
        num_cols == tablegeometry->num_cols)
      pass ("TABLEGEOMETRY.num_cols [BL]");
    else
      {
        fail ("TABLEGEOMETRY.num_cols [BL] %u != %u", tablegeometry->num_cols, num_cols); error++;
      }
  }
  {
    BITCODE_BL num_rows;
    if (dwg_dynapi_entity_value(tablegeometry, "TABLEGEOMETRY", "num_rows", &num_rows, NULL) &&
        num_rows == tablegeometry->num_rows)
      pass ("TABLEGEOMETRY.num_rows [BL]");
    else
      {
        fail ("TABLEGEOMETRY.num_rows [BL] %u != %u", tablegeometry->num_rows, num_rows); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(tablegeometry, "TABLEGEOMETRY", "parent", &parent, NULL)
        && !memcmp(&parent, &tablegeometry->parent, sizeof(tablegeometry->parent)))
      pass ("TABLEGEOMETRY.parent");
    else
      {
        fail ("TABLEGEOMETRY.parent"); error++;
      }
  }
  return error;
}
static int test_TABLESTYLE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_TABLESTYLE *tablestyle = obj->tio.object->tio.TABLESTYLE;
  {
    Dwg_TABLESTYLE_Cell* cells;
    if (dwg_dynapi_entity_value(tablestyle, "TABLESTYLE", "cells", &cells, NULL)
        && !memcmp(&cells, &tablestyle->cells, sizeof(tablestyle->cells)))
      pass ("TABLESTYLE.cells");
    else
      {
        fail ("TABLESTYLE.cells"); error++;
      }
  }
  {
    BITCODE_BS class_version;
    if (dwg_dynapi_entity_value(tablestyle, "TABLESTYLE", "class_version", &class_version, NULL) &&
        class_version == tablestyle->class_version)
      pass ("TABLESTYLE.class_version [BS]");
    else
      {
        fail ("TABLESTYLE.class_version [BS] %d != %d", tablestyle->class_version, class_version); error++;
      }
  }
  {
    BITCODE_BL flags;
    if (dwg_dynapi_entity_value(tablestyle, "TABLESTYLE", "flags", &flags, NULL) &&
        flags == tablestyle->flags)
      pass ("TABLESTYLE.flags [BL]");
    else
      {
        fail ("TABLESTYLE.flags [BL] %u != %u", tablestyle->flags, flags); error++;
      }
  }
  {
    BITCODE_BS flow_direction;
    if (dwg_dynapi_entity_value(tablestyle, "TABLESTYLE", "flow_direction", &flow_direction, NULL) &&
        flow_direction == tablestyle->flow_direction)
      pass ("TABLESTYLE.flow_direction [BS]");
    else
      {
        fail ("TABLESTYLE.flow_direction [BS] %d != %d", tablestyle->flow_direction, flow_direction); error++;
      }
  }
  {
    BITCODE_B header_suppressed;
    if (dwg_dynapi_entity_value(tablestyle, "TABLESTYLE", "header_suppressed", &header_suppressed, NULL) &&
        header_suppressed == tablestyle->header_suppressed)
      pass ("TABLESTYLE.header_suppressed [B]");
    else
      {
        fail ("TABLESTYLE.header_suppressed [B] " FORMAT_B " != " FORMAT_B "", tablestyle->header_suppressed, header_suppressed); error++;
      }
  }
  {
    BITCODE_BD horiz_cell_margin;
    if (dwg_dynapi_entity_value(tablestyle, "TABLESTYLE", "horiz_cell_margin", &horiz_cell_margin, NULL) &&
        horiz_cell_margin == tablestyle->horiz_cell_margin)
      pass ("TABLESTYLE.horiz_cell_margin [BD]");
    else
      {
        fail ("TABLESTYLE.horiz_cell_margin [BD] %g != %g", tablestyle->horiz_cell_margin, horiz_cell_margin); error++;
      }
  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value(tablestyle, "TABLESTYLE", "name", &name, NULL)
        && !strcmp((char*)&name, (char*)&tablestyle->name))
      pass ("TABLESTYLE.name");
    else
      {
        fail ("TABLESTYLE.name"); error++;
      }
  }
  {
    BITCODE_BL num_cells;
    if (dwg_dynapi_entity_value(tablestyle, "TABLESTYLE", "num_cells", &num_cells, NULL) &&
        num_cells == tablestyle->num_cells)
      pass ("TABLESTYLE.num_cells [BL]");
    else
      {
        fail ("TABLESTYLE.num_cells [BL] %u != %u", tablestyle->num_cells, num_cells); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(tablestyle, "TABLESTYLE", "parent", &parent, NULL)
        && !memcmp(&parent, &tablestyle->parent, sizeof(tablestyle->parent)))
      pass ("TABLESTYLE.parent");
    else
      {
        fail ("TABLESTYLE.parent"); error++;
      }
  }
  {
    BITCODE_B title_suppressed;
    if (dwg_dynapi_entity_value(tablestyle, "TABLESTYLE", "title_suppressed", &title_suppressed, NULL) &&
        title_suppressed == tablestyle->title_suppressed)
      pass ("TABLESTYLE.title_suppressed [B]");
    else
      {
        fail ("TABLESTYLE.title_suppressed [B] " FORMAT_B " != " FORMAT_B "", tablestyle->title_suppressed, title_suppressed); error++;
      }
  }
  {
    BITCODE_BD vert_cell_margin;
    if (dwg_dynapi_entity_value(tablestyle, "TABLESTYLE", "vert_cell_margin", &vert_cell_margin, NULL) &&
        vert_cell_margin == tablestyle->vert_cell_margin)
      pass ("TABLESTYLE.vert_cell_margin [BD]");
    else
      {
        fail ("TABLESTYLE.vert_cell_margin [BD] %g != %g", tablestyle->vert_cell_margin, vert_cell_margin); error++;
      }
  }
  return error;
}
static int test_UCS (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_UCS *ucs = obj->tio.object->tio.UCS;
  {
    BITCODE_H base_ucs_handle;
    if (dwg_dynapi_entity_value(ucs, "UCS", "base_ucs_handle", &base_ucs_handle, NULL) &&
        base_ucs_handle == ucs->base_ucs_handle)
      pass ("UCS.base_ucs_handle [H]");
    else
      {
        fail ("UCS.base_ucs_handle [H] %p != %p", ucs->base_ucs_handle, base_ucs_handle); error++;
      }
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value(ucs, "UCS", "elevation", &elevation, NULL) &&
        elevation == ucs->elevation)
      pass ("UCS.elevation [BD]");
    else
      {
        fail ("UCS.elevation [BD] %g != %g", ucs->elevation, elevation); error++;
      }
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value(ucs, "UCS", "flag", &flag, NULL) &&
        flag == ucs->flag)
      pass ("UCS.flag [RC]");
    else
      {
        fail ("UCS.flag [RC] %c != %c", ucs->flag, flag); error++;
      }
  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value(ucs, "UCS", "name", &name, NULL)
        && !strcmp((char*)&name, (char*)&ucs->name))
      pass ("UCS.name");
    else
      {
        fail ("UCS.name"); error++;
      }
  }
  {
    BITCODE_H null_handle;
    if (dwg_dynapi_entity_value(ucs, "UCS", "null_handle", &null_handle, NULL) &&
        null_handle == ucs->null_handle)
      pass ("UCS.null_handle [H]");
    else
      {
        fail ("UCS.null_handle [H] %p != %p", ucs->null_handle, null_handle); error++;
      }
  }
  {
    BITCODE_3BD origin;
    if (dwg_dynapi_entity_value(ucs, "UCS", "origin", &origin, NULL)
        && !memcmp(&origin, &ucs->origin, sizeof(ucs->origin)))
      pass ("UCS.origin");
    else
      {
        fail ("UCS.origin"); error++;
      }
  }
  {
    BITCODE_BS orthographic_type;
    if (dwg_dynapi_entity_value(ucs, "UCS", "orthographic_type", &orthographic_type, NULL) &&
        orthographic_type == ucs->orthographic_type)
      pass ("UCS.orthographic_type [BS]");
    else
      {
        fail ("UCS.orthographic_type [BS] %d != %d", ucs->orthographic_type, orthographic_type); error++;
      }
  }
  {
    BITCODE_BS orthographic_view_type;
    if (dwg_dynapi_entity_value(ucs, "UCS", "orthographic_view_type", &orthographic_view_type, NULL) &&
        orthographic_view_type == ucs->orthographic_view_type)
      pass ("UCS.orthographic_view_type [BS]");
    else
      {
        fail ("UCS.orthographic_view_type [BS] %d != %d", ucs->orthographic_view_type, orthographic_view_type); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(ucs, "UCS", "parent", &parent, NULL)
        && !memcmp(&parent, &ucs->parent, sizeof(ucs->parent)))
      pass ("UCS.parent");
    else
      {
        fail ("UCS.parent"); error++;
      }
  }
  {
    BITCODE_H ucs_control;
    if (dwg_dynapi_entity_value(ucs, "UCS", "ucs_control", &ucs_control, NULL) &&
        ucs_control == ucs->ucs_control)
      pass ("UCS.ucs_control [H]");
    else
      {
        fail ("UCS.ucs_control [H] %p != %p", ucs->ucs_control, ucs_control); error++;
      }
  }
  {
    BITCODE_H unknown;
    if (dwg_dynapi_entity_value(ucs, "UCS", "unknown", &unknown, NULL) &&
        unknown == ucs->unknown)
      pass ("UCS.unknown [H]");
    else
      {
        fail ("UCS.unknown [H] %p != %p", ucs->unknown, unknown); error++;
      }
  }
  {
    BITCODE_RS used;
    if (dwg_dynapi_entity_value(ucs, "UCS", "used", &used, NULL) &&
        used == ucs->used)
      pass ("UCS.used [RS]");
    else
      {
        fail ("UCS.used [RS] " FORMAT_RS " != " FORMAT_RS "", ucs->used, used); error++;
      }
  }
  {
    BITCODE_3BD x_direction;
    if (dwg_dynapi_entity_value(ucs, "UCS", "x_direction", &x_direction, NULL)
        && !memcmp(&x_direction, &ucs->x_direction, sizeof(ucs->x_direction)))
      pass ("UCS.x_direction");
    else
      {
        fail ("UCS.x_direction"); error++;
      }
  }
  {
    BITCODE_B xrefdep;
    if (dwg_dynapi_entity_value(ucs, "UCS", "xrefdep", &xrefdep, NULL) &&
        xrefdep == ucs->xrefdep)
      pass ("UCS.xrefdep [B]");
    else
      {
        fail ("UCS.xrefdep [B] " FORMAT_B " != " FORMAT_B "", ucs->xrefdep, xrefdep); error++;
      }
  }
  {
    BITCODE_BS xrefindex_plus1;
    if (dwg_dynapi_entity_value(ucs, "UCS", "xrefindex_plus1", &xrefindex_plus1, NULL) &&
        xrefindex_plus1 == ucs->xrefindex_plus1)
      pass ("UCS.xrefindex_plus1 [BS]");
    else
      {
        fail ("UCS.xrefindex_plus1 [BS] %d != %d", ucs->xrefindex_plus1, xrefindex_plus1); error++;
      }
  }
  {
    BITCODE_B xrefref;
    if (dwg_dynapi_entity_value(ucs, "UCS", "xrefref", &xrefref, NULL) &&
        xrefref == ucs->xrefref)
      pass ("UCS.xrefref [B]");
    else
      {
        fail ("UCS.xrefref [B] " FORMAT_B " != " FORMAT_B "", ucs->xrefref, xrefref); error++;
      }
  }
  {
    BITCODE_3BD y_direction;
    if (dwg_dynapi_entity_value(ucs, "UCS", "y_direction", &y_direction, NULL)
        && !memcmp(&y_direction, &ucs->y_direction, sizeof(ucs->y_direction)))
      pass ("UCS.y_direction");
    else
      {
        fail ("UCS.y_direction"); error++;
      }
  }
  return error;
}
static int test_UCS_CONTROL (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_UCS_CONTROL *ucs_control = obj->tio.object->tio.UCS_CONTROL;
  {
    Dwg_Object_Ref* null_handle;
    if (dwg_dynapi_entity_value(ucs_control, "UCS_CONTROL", "null_handle", &null_handle, NULL)
        && !memcmp(&null_handle, &ucs_control->null_handle, sizeof(ucs_control->null_handle)))
      pass ("UCS_CONTROL.null_handle");
    else
      {
        fail ("UCS_CONTROL.null_handle"); error++;
      }
  }
  {
    BITCODE_BS num_entries;
    if (dwg_dynapi_entity_value(ucs_control, "UCS_CONTROL", "num_entries", &num_entries, NULL) &&
        num_entries == ucs_control->num_entries)
      pass ("UCS_CONTROL.num_entries [BS]");
    else
      {
        fail ("UCS_CONTROL.num_entries [BS] %d != %d", ucs_control->num_entries, num_entries); error++;
      }
  }
  {
    BITCODE_BL objid;
    if (dwg_dynapi_entity_value(ucs_control, "UCS_CONTROL", "objid", &objid, NULL) &&
        objid == ucs_control->objid)
      pass ("UCS_CONTROL.objid [BL]");
    else
      {
        fail ("UCS_CONTROL.objid [BL] %u != %u", ucs_control->objid, objid); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(ucs_control, "UCS_CONTROL", "parent", &parent, NULL)
        && !memcmp(&parent, &ucs_control->parent, sizeof(ucs_control->parent)))
      pass ("UCS_CONTROL.parent");
    else
      {
        fail ("UCS_CONTROL.parent"); error++;
      }
  }
  {
    Dwg_Object_Ref* reactors;
    if (dwg_dynapi_entity_value(ucs_control, "UCS_CONTROL", "reactors", &reactors, NULL)
        && !memcmp(&reactors, &ucs_control->reactors, sizeof(ucs_control->reactors)))
      pass ("UCS_CONTROL.reactors");
    else
      {
        fail ("UCS_CONTROL.reactors"); error++;
      }
  }
  {
    Dwg_Object_Ref* ucs;
    if (dwg_dynapi_entity_value(ucs_control, "UCS_CONTROL", "ucs", &ucs, NULL)
        && !memcmp(&ucs, &ucs_control->ucs, sizeof(ucs_control->ucs)))
      pass ("UCS_CONTROL.ucs");
    else
      {
        fail ("UCS_CONTROL.ucs"); error++;
      }
  }
  {
    Dwg_Object_Ref* xdicobjhandle;
    if (dwg_dynapi_entity_value(ucs_control, "UCS_CONTROL", "xdicobjhandle", &xdicobjhandle, NULL)
        && !memcmp(&xdicobjhandle, &ucs_control->xdicobjhandle, sizeof(ucs_control->xdicobjhandle)))
      pass ("UCS_CONTROL.xdicobjhandle");
    else
      {
        fail ("UCS_CONTROL.xdicobjhandle"); error++;
      }
  }
  return error;
}
static int test_UNDERLAYDEFINITION (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_UNDERLAYDEFINITION *underlaydefinition = obj->tio.object->tio.UNDERLAYDEFINITION;
  {
    BITCODE_TV filename;
    if (dwg_dynapi_entity_value(underlaydefinition, "UNDERLAYDEFINITION", "filename", &filename, NULL)
        && !strcmp((char*)&filename, (char*)&underlaydefinition->filename))
      pass ("UNDERLAYDEFINITION.filename");
    else
      {
        fail ("UNDERLAYDEFINITION.filename"); error++;
      }
  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value(underlaydefinition, "UNDERLAYDEFINITION", "name", &name, NULL)
        && !strcmp((char*)&name, (char*)&underlaydefinition->name))
      pass ("UNDERLAYDEFINITION.name");
    else
      {
        fail ("UNDERLAYDEFINITION.name"); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(underlaydefinition, "UNDERLAYDEFINITION", "ownerhandle", &ownerhandle, NULL) &&
        ownerhandle == underlaydefinition->ownerhandle)
      pass ("UNDERLAYDEFINITION.ownerhandle [H]");
    else
      {
        fail ("UNDERLAYDEFINITION.ownerhandle [H] %p != %p", underlaydefinition->ownerhandle, ownerhandle); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(underlaydefinition, "UNDERLAYDEFINITION", "parent", &parent, NULL)
        && !memcmp(&parent, &underlaydefinition->parent, sizeof(underlaydefinition->parent)))
      pass ("UNDERLAYDEFINITION.parent");
    else
      {
        fail ("UNDERLAYDEFINITION.parent"); error++;
      }
  }
  return error;
}
static int test_UNKNOWN_OBJ (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_UNKNOWN_OBJ *unknown_obj = obj->tio.object->tio.UNKNOWN_OBJ;
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(unknown_obj, "UNKNOWN_OBJ", "parent", &parent, NULL)
        && !memcmp(&parent, &unknown_obj->parent, sizeof(unknown_obj->parent)))
      pass ("UNKNOWN_OBJ.parent");
    else
      {
        fail ("UNKNOWN_OBJ.parent"); error++;
      }
  }
  return error;
}
static int test_VBA_PROJECT (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_VBA_PROJECT *vba_project = obj->tio.object->tio.VBA_PROJECT;
  {
    BITCODE_TF bytes;
    if (dwg_dynapi_entity_value(vba_project, "VBA_PROJECT", "bytes", &bytes, NULL) &&
        bytes == vba_project->bytes)
      pass ("VBA_PROJECT.bytes [TF]");
    else
      {
        fail ("VBA_PROJECT.bytes [TF] " FORMAT_TF " != " FORMAT_TF "", vba_project->bytes, bytes); error++;
      }
  }
  {
    BITCODE_RL num_bytes;
    if (dwg_dynapi_entity_value(vba_project, "VBA_PROJECT", "num_bytes", &num_bytes, NULL) &&
        num_bytes == vba_project->num_bytes)
      pass ("VBA_PROJECT.num_bytes [RL]");
    else
      {
        fail ("VBA_PROJECT.num_bytes [RL] " FORMAT_RL " != " FORMAT_RL "", vba_project->num_bytes, num_bytes); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(vba_project, "VBA_PROJECT", "ownerhandle", &ownerhandle, NULL) &&
        ownerhandle == vba_project->ownerhandle)
      pass ("VBA_PROJECT.ownerhandle [H]");
    else
      {
        fail ("VBA_PROJECT.ownerhandle [H] %p != %p", vba_project->ownerhandle, ownerhandle); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(vba_project, "VBA_PROJECT", "parent", &parent, NULL)
        && !memcmp(&parent, &vba_project->parent, sizeof(vba_project->parent)))
      pass ("VBA_PROJECT.parent");
    else
      {
        fail ("VBA_PROJECT.parent"); error++;
      }
  }
  return error;
}
static int test_VIEW (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_VIEW *view = obj->tio.object->tio.VIEW;
  {
    BITCODE_4BITS VIEWMODE;
    if (dwg_dynapi_entity_value(view, "VIEW", "VIEWMODE", &VIEWMODE, NULL) &&
        VIEWMODE == view->VIEWMODE)
      pass ("VIEW.VIEWMODE [4BITS]");
    else
      {
        fail ("VIEW.VIEWMODE [4BITS] " FORMAT_4BITS " != " FORMAT_4BITS "", view->VIEWMODE, VIEWMODE); error++;
      }
  }
  {
    BITCODE_CMC ambient_color;
    if (dwg_dynapi_entity_value(view, "VIEW", "ambient_color", &ambient_color, NULL)
        && !memcmp(&ambient_color, &view->ambient_color, sizeof(view->ambient_color)))
      pass ("VIEW.ambient_color");
    else
      {
        fail ("VIEW.ambient_color"); error++;
      }
  }
  {
    BITCODE_B associated_ucs;
    if (dwg_dynapi_entity_value(view, "VIEW", "associated_ucs", &associated_ucs, NULL) &&
        associated_ucs == view->associated_ucs)
      pass ("VIEW.associated_ucs [B]");
    else
      {
        fail ("VIEW.associated_ucs [B] " FORMAT_B " != " FORMAT_B "", view->associated_ucs, associated_ucs); error++;
      }
  }
  {
    BITCODE_BD back_clip;
    if (dwg_dynapi_entity_value(view, "VIEW", "back_clip", &back_clip, NULL) &&
        back_clip == view->back_clip)
      pass ("VIEW.back_clip [BD]");
    else
      {
        fail ("VIEW.back_clip [BD] %g != %g", view->back_clip, back_clip); error++;
      }
  }
  {
    BITCODE_H background_handle;
    if (dwg_dynapi_entity_value(view, "VIEW", "background_handle", &background_handle, NULL) &&
        background_handle == view->background_handle)
      pass ("VIEW.background_handle [H]");
    else
      {
        fail ("VIEW.background_handle [H] %p != %p", view->background_handle, background_handle); error++;
      }
  }
  {
    BITCODE_H base_ucs_handle;
    if (dwg_dynapi_entity_value(view, "VIEW", "base_ucs_handle", &base_ucs_handle, NULL) &&
        base_ucs_handle == view->base_ucs_handle)
      pass ("VIEW.base_ucs_handle [H]");
    else
      {
        fail ("VIEW.base_ucs_handle [H] %p != %p", view->base_ucs_handle, base_ucs_handle); error++;
      }
  }
  {
    BITCODE_BD brightness;
    if (dwg_dynapi_entity_value(view, "VIEW", "brightness", &brightness, NULL) &&
        brightness == view->brightness)
      pass ("VIEW.brightness [BD]");
    else
      {
        fail ("VIEW.brightness [BD] %g != %g", view->brightness, brightness); error++;
      }
  }
  {
    BITCODE_B camera_plottable;
    if (dwg_dynapi_entity_value(view, "VIEW", "camera_plottable", &camera_plottable, NULL) &&
        camera_plottable == view->camera_plottable)
      pass ("VIEW.camera_plottable [B]");
    else
      {
        fail ("VIEW.camera_plottable [B] " FORMAT_B " != " FORMAT_B "", view->camera_plottable, camera_plottable); error++;
      }
  }
  {
    BITCODE_2RD center;
    if (dwg_dynapi_entity_value(view, "VIEW", "center", &center, NULL)
        && !memcmp(&center, &view->center, sizeof(view->center)))
      pass ("VIEW.center");
    else
      {
        fail ("VIEW.center"); error++;
      }
  }
  {
    BITCODE_BD contrast;
    if (dwg_dynapi_entity_value(view, "VIEW", "contrast", &contrast, NULL) &&
        contrast == view->contrast)
      pass ("VIEW.contrast [BD]");
    else
      {
        fail ("VIEW.contrast [BD] %g != %g", view->contrast, contrast); error++;
      }
  }
  {
    BITCODE_RC default_lightning_type;
    if (dwg_dynapi_entity_value(view, "VIEW", "default_lightning_type", &default_lightning_type, NULL) &&
        default_lightning_type == view->default_lightning_type)
      pass ("VIEW.default_lightning_type [RC]");
    else
      {
        fail ("VIEW.default_lightning_type [RC] %c != %c", view->default_lightning_type, default_lightning_type); error++;
      }
  }
  {
    BITCODE_3BD direction;
    if (dwg_dynapi_entity_value(view, "VIEW", "direction", &direction, NULL)
        && !memcmp(&direction, &view->direction, sizeof(view->direction)))
      pass ("VIEW.direction");
    else
      {
        fail ("VIEW.direction"); error++;
      }
  }
  {
    BITCODE_BD elevation;
    if (dwg_dynapi_entity_value(view, "VIEW", "elevation", &elevation, NULL) &&
        elevation == view->elevation)
      pass ("VIEW.elevation [BD]");
    else
      {
        fail ("VIEW.elevation [BD] %g != %g", view->elevation, elevation); error++;
      }
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value(view, "VIEW", "flag", &flag, NULL) &&
        flag == view->flag)
      pass ("VIEW.flag [RC]");
    else
      {
        fail ("VIEW.flag [RC] %c != %c", view->flag, flag); error++;
      }
  }
  {
    BITCODE_BD front_clip;
    if (dwg_dynapi_entity_value(view, "VIEW", "front_clip", &front_clip, NULL) &&
        front_clip == view->front_clip)
      pass ("VIEW.front_clip [BD]");
    else
      {
        fail ("VIEW.front_clip [BD] %g != %g", view->front_clip, front_clip); error++;
      }
  }
  {
    BITCODE_BD height;
    if (dwg_dynapi_entity_value(view, "VIEW", "height", &height, NULL) &&
        height == view->height)
      pass ("VIEW.height [BD]");
    else
      {
        fail ("VIEW.height [BD] %g != %g", view->height, height); error++;
      }
  }
  {
    BITCODE_BD lens_length;
    if (dwg_dynapi_entity_value(view, "VIEW", "lens_length", &lens_length, NULL) &&
        lens_length == view->lens_length)
      pass ("VIEW.lens_length [BD]");
    else
      {
        fail ("VIEW.lens_length [BD] %g != %g", view->lens_length, lens_length); error++;
      }
  }
  {
    BITCODE_H live_section_handle;
    if (dwg_dynapi_entity_value(view, "VIEW", "live_section_handle", &live_section_handle, NULL) &&
        live_section_handle == view->live_section_handle)
      pass ("VIEW.live_section_handle [H]");
    else
      {
        fail ("VIEW.live_section_handle [H] %p != %p", view->live_section_handle, live_section_handle); error++;
      }
  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value(view, "VIEW", "name", &name, NULL)
        && !strcmp((char*)&name, (char*)&view->name))
      pass ("VIEW.name");
    else
      {
        fail ("VIEW.name"); error++;
      }
  }
  {
    BITCODE_H named_ucs_handle;
    if (dwg_dynapi_entity_value(view, "VIEW", "named_ucs_handle", &named_ucs_handle, NULL) &&
        named_ucs_handle == view->named_ucs_handle)
      pass ("VIEW.named_ucs_handle [H]");
    else
      {
        fail ("VIEW.named_ucs_handle [H] %p != %p", view->named_ucs_handle, named_ucs_handle); error++;
      }
  }
  {
    BITCODE_H null_handle;
    if (dwg_dynapi_entity_value(view, "VIEW", "null_handle", &null_handle, NULL) &&
        null_handle == view->null_handle)
      pass ("VIEW.null_handle [H]");
    else
      {
        fail ("VIEW.null_handle [H] %p != %p", view->null_handle, null_handle); error++;
      }
  }
  {
    BITCODE_3BD origin;
    if (dwg_dynapi_entity_value(view, "VIEW", "origin", &origin, NULL)
        && !memcmp(&origin, &view->origin, sizeof(view->origin)))
      pass ("VIEW.origin");
    else
      {
        fail ("VIEW.origin"); error++;
      }
  }
  {
    BITCODE_BS orthographic_view_type;
    if (dwg_dynapi_entity_value(view, "VIEW", "orthographic_view_type", &orthographic_view_type, NULL) &&
        orthographic_view_type == view->orthographic_view_type)
      pass ("VIEW.orthographic_view_type [BS]");
    else
      {
        fail ("VIEW.orthographic_view_type [BS] %d != %d", view->orthographic_view_type, orthographic_view_type); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(view, "VIEW", "parent", &parent, NULL)
        && !memcmp(&parent, &view->parent, sizeof(view->parent)))
      pass ("VIEW.parent");
    else
      {
        fail ("VIEW.parent"); error++;
      }
  }
  {
    BITCODE_B pspace_flag;
    if (dwg_dynapi_entity_value(view, "VIEW", "pspace_flag", &pspace_flag, NULL) &&
        pspace_flag == view->pspace_flag)
      pass ("VIEW.pspace_flag [B]");
    else
      {
        fail ("VIEW.pspace_flag [B] " FORMAT_B " != " FORMAT_B "", view->pspace_flag, pspace_flag); error++;
      }
  }
  {
    BITCODE_RC render_mode;
    if (dwg_dynapi_entity_value(view, "VIEW", "render_mode", &render_mode, NULL) &&
        render_mode == view->render_mode)
      pass ("VIEW.render_mode [RC]");
    else
      {
        fail ("VIEW.render_mode [RC] %c != %c", view->render_mode, render_mode); error++;
      }
  }
  {
    BITCODE_H sun_handle;
    if (dwg_dynapi_entity_value(view, "VIEW", "sun_handle", &sun_handle, NULL) &&
        sun_handle == view->sun_handle)
      pass ("VIEW.sun_handle [H]");
    else
      {
        fail ("VIEW.sun_handle [H] %p != %p", view->sun_handle, sun_handle); error++;
      }
  }
  {
    BITCODE_3BD target;
    if (dwg_dynapi_entity_value(view, "VIEW", "target", &target, NULL)
        && !memcmp(&target, &view->target, sizeof(view->target)))
      pass ("VIEW.target");
    else
      {
        fail ("VIEW.target"); error++;
      }
  }
  {
    BITCODE_BD twist_angle;
    if (dwg_dynapi_entity_value(view, "VIEW", "twist_angle", &twist_angle, NULL) &&
        twist_angle == view->twist_angle)
      pass ("VIEW.twist_angle [BD]");
    else
      {
        fail ("VIEW.twist_angle [BD] %g != %g", view->twist_angle, twist_angle); error++;
      }
  }
  {
    BITCODE_B use_default_lights;
    if (dwg_dynapi_entity_value(view, "VIEW", "use_default_lights", &use_default_lights, NULL) &&
        use_default_lights == view->use_default_lights)
      pass ("VIEW.use_default_lights [B]");
    else
      {
        fail ("VIEW.use_default_lights [B] " FORMAT_B " != " FORMAT_B "", view->use_default_lights, use_default_lights); error++;
      }
  }
  {
    BITCODE_RS used;
    if (dwg_dynapi_entity_value(view, "VIEW", "used", &used, NULL) &&
        used == view->used)
      pass ("VIEW.used [RS]");
    else
      {
        fail ("VIEW.used [RS] " FORMAT_RS " != " FORMAT_RS "", view->used, used); error++;
      }
  }
  {
    BITCODE_H view_control;
    if (dwg_dynapi_entity_value(view, "VIEW", "view_control", &view_control, NULL) &&
        view_control == view->view_control)
      pass ("VIEW.view_control [H]");
    else
      {
        fail ("VIEW.view_control [H] %p != %p", view->view_control, view_control); error++;
      }
  }
  {
    BITCODE_H visual_style_handle;
    if (dwg_dynapi_entity_value(view, "VIEW", "visual_style_handle", &visual_style_handle, NULL) &&
        visual_style_handle == view->visual_style_handle)
      pass ("VIEW.visual_style_handle [H]");
    else
      {
        fail ("VIEW.visual_style_handle [H] %p != %p", view->visual_style_handle, visual_style_handle); error++;
      }
  }
  {
    BITCODE_BD width;
    if (dwg_dynapi_entity_value(view, "VIEW", "width", &width, NULL) &&
        width == view->width)
      pass ("VIEW.width [BD]");
    else
      {
        fail ("VIEW.width [BD] %g != %g", view->width, width); error++;
      }
  }
  {
    BITCODE_3BD x_direction;
    if (dwg_dynapi_entity_value(view, "VIEW", "x_direction", &x_direction, NULL)
        && !memcmp(&x_direction, &view->x_direction, sizeof(view->x_direction)))
      pass ("VIEW.x_direction");
    else
      {
        fail ("VIEW.x_direction"); error++;
      }
  }
  {
    BITCODE_B xrefdep;
    if (dwg_dynapi_entity_value(view, "VIEW", "xrefdep", &xrefdep, NULL) &&
        xrefdep == view->xrefdep)
      pass ("VIEW.xrefdep [B]");
    else
      {
        fail ("VIEW.xrefdep [B] " FORMAT_B " != " FORMAT_B "", view->xrefdep, xrefdep); error++;
      }
  }
  {
    BITCODE_BS xrefindex_plus1;
    if (dwg_dynapi_entity_value(view, "VIEW", "xrefindex_plus1", &xrefindex_plus1, NULL) &&
        xrefindex_plus1 == view->xrefindex_plus1)
      pass ("VIEW.xrefindex_plus1 [BS]");
    else
      {
        fail ("VIEW.xrefindex_plus1 [BS] %d != %d", view->xrefindex_plus1, xrefindex_plus1); error++;
      }
  }
  {
    BITCODE_B xrefref;
    if (dwg_dynapi_entity_value(view, "VIEW", "xrefref", &xrefref, NULL) &&
        xrefref == view->xrefref)
      pass ("VIEW.xrefref [B]");
    else
      {
        fail ("VIEW.xrefref [B] " FORMAT_B " != " FORMAT_B "", view->xrefref, xrefref); error++;
      }
  }
  {
    BITCODE_3BD y_direction;
    if (dwg_dynapi_entity_value(view, "VIEW", "y_direction", &y_direction, NULL)
        && !memcmp(&y_direction, &view->y_direction, sizeof(view->y_direction)))
      pass ("VIEW.y_direction");
    else
      {
        fail ("VIEW.y_direction"); error++;
      }
  }
  return error;
}
static int test_VIEW_CONTROL (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_VIEW_CONTROL *view_control = obj->tio.object->tio.VIEW_CONTROL;
  {
    Dwg_Object_Ref* null_handle;
    if (dwg_dynapi_entity_value(view_control, "VIEW_CONTROL", "null_handle", &null_handle, NULL)
        && !memcmp(&null_handle, &view_control->null_handle, sizeof(view_control->null_handle)))
      pass ("VIEW_CONTROL.null_handle");
    else
      {
        fail ("VIEW_CONTROL.null_handle"); error++;
      }
  }
  {
    BITCODE_BS num_entries;
    if (dwg_dynapi_entity_value(view_control, "VIEW_CONTROL", "num_entries", &num_entries, NULL) &&
        num_entries == view_control->num_entries)
      pass ("VIEW_CONTROL.num_entries [BS]");
    else
      {
        fail ("VIEW_CONTROL.num_entries [BS] %d != %d", view_control->num_entries, num_entries); error++;
      }
  }
  {
    BITCODE_BL objid;
    if (dwg_dynapi_entity_value(view_control, "VIEW_CONTROL", "objid", &objid, NULL) &&
        objid == view_control->objid)
      pass ("VIEW_CONTROL.objid [BL]");
    else
      {
        fail ("VIEW_CONTROL.objid [BL] %u != %u", view_control->objid, objid); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(view_control, "VIEW_CONTROL", "parent", &parent, NULL)
        && !memcmp(&parent, &view_control->parent, sizeof(view_control->parent)))
      pass ("VIEW_CONTROL.parent");
    else
      {
        fail ("VIEW_CONTROL.parent"); error++;
      }
  }
  {
    Dwg_Object_Ref* reactors;
    if (dwg_dynapi_entity_value(view_control, "VIEW_CONTROL", "reactors", &reactors, NULL)
        && !memcmp(&reactors, &view_control->reactors, sizeof(view_control->reactors)))
      pass ("VIEW_CONTROL.reactors");
    else
      {
        fail ("VIEW_CONTROL.reactors"); error++;
      }
  }
  {
    Dwg_Object_Ref* views;
    if (dwg_dynapi_entity_value(view_control, "VIEW_CONTROL", "views", &views, NULL)
        && !memcmp(&views, &view_control->views, sizeof(view_control->views)))
      pass ("VIEW_CONTROL.views");
    else
      {
        fail ("VIEW_CONTROL.views"); error++;
      }
  }
  {
    Dwg_Object_Ref* xdicobjhandle;
    if (dwg_dynapi_entity_value(view_control, "VIEW_CONTROL", "xdicobjhandle", &xdicobjhandle, NULL)
        && !memcmp(&xdicobjhandle, &view_control->xdicobjhandle, sizeof(view_control->xdicobjhandle)))
      pass ("VIEW_CONTROL.xdicobjhandle");
    else
      {
        fail ("VIEW_CONTROL.xdicobjhandle"); error++;
      }
  }
  return error;
}
static int test_VISUALSTYLE (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_VISUALSTYLE *visualstyle = obj->tio.object->tio.VISUALSTYLE;
  {
    BITCODE_CMC color;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "color", &color, NULL)
        && !memcmp(&color, &visualstyle->color, sizeof(visualstyle->color)))
      pass ("VISUALSTYLE.color");
    else
      {
        fail ("VISUALSTYLE.color"); error++;
      }
  }
  {
    BITCODE_T desc;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "desc", &desc, NULL)
        && !memcmp(&desc, &visualstyle->desc, sizeof(visualstyle->desc)))
      pass ("VISUALSTYLE.desc");
    else
      {
        fail ("VISUALSTYLE.desc"); error++;
      }
  }
  {
    BITCODE_BD display_brightness;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "display_brightness", &display_brightness, NULL) &&
        display_brightness == visualstyle->display_brightness)
      pass ("VISUALSTYLE.display_brightness [BD]");
    else
      {
        fail ("VISUALSTYLE.display_brightness [BD] %g != %g", visualstyle->display_brightness, display_brightness); error++;
      }
  }
  {
    BITCODE_BS display_shadow_type;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "display_shadow_type", &display_shadow_type, NULL) &&
        display_shadow_type == visualstyle->display_shadow_type)
      pass ("VISUALSTYLE.display_shadow_type [BS]");
    else
      {
        fail ("VISUALSTYLE.display_shadow_type [BS] %d != %d", visualstyle->display_shadow_type, display_shadow_type); error++;
      }
  }
  {
    BITCODE_BS display_style;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "display_style", &display_style, NULL) &&
        display_style == visualstyle->display_style)
      pass ("VISUALSTYLE.display_style [BS]");
    else
      {
        fail ("VISUALSTYLE.display_style [BS] %d != %d", visualstyle->display_style, display_style); error++;
      }
  }
  {
    BITCODE_CMC edge_color;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "edge_color", &edge_color, NULL)
        && !memcmp(&edge_color, &visualstyle->edge_color, sizeof(visualstyle->edge_color)))
      pass ("VISUALSTYLE.edge_color");
    else
      {
        fail ("VISUALSTYLE.edge_color"); error++;
      }
  }
  {
    BITCODE_BD edge_crease_angle;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "edge_crease_angle", &edge_crease_angle, NULL) &&
        edge_crease_angle == visualstyle->edge_crease_angle)
      pass ("VISUALSTYLE.edge_crease_angle [BD]");
    else
      {
        fail ("VISUALSTYLE.edge_crease_angle [BD] %g != %g", visualstyle->edge_crease_angle, edge_crease_angle); error++;
      }
  }
  {
    BITCODE_BS edge_halo_gap;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "edge_halo_gap", &edge_halo_gap, NULL) &&
        edge_halo_gap == visualstyle->edge_halo_gap)
      pass ("VISUALSTYLE.edge_halo_gap [BS]");
    else
      {
        fail ("VISUALSTYLE.edge_halo_gap [BS] %d != %d", visualstyle->edge_halo_gap, edge_halo_gap); error++;
      }
  }
  {
    BITCODE_BS edge_hide_precision_flag;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "edge_hide_precision_flag", &edge_hide_precision_flag, NULL) &&
        edge_hide_precision_flag == visualstyle->edge_hide_precision_flag)
      pass ("VISUALSTYLE.edge_hide_precision_flag [BS]");
    else
      {
        fail ("VISUALSTYLE.edge_hide_precision_flag [BS] %d != %d", visualstyle->edge_hide_precision_flag, edge_hide_precision_flag); error++;
      }
  }
  {
    BITCODE_CMC edge_intersection_color;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "edge_intersection_color", &edge_intersection_color, NULL)
        && !memcmp(&edge_intersection_color, &visualstyle->edge_intersection_color, sizeof(visualstyle->edge_intersection_color)))
      pass ("VISUALSTYLE.edge_intersection_color");
    else
      {
        fail ("VISUALSTYLE.edge_intersection_color"); error++;
      }
  }
  {
    BITCODE_BS edge_intersection_line_pattern;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "edge_intersection_line_pattern", &edge_intersection_line_pattern, NULL) &&
        edge_intersection_line_pattern == visualstyle->edge_intersection_line_pattern)
      pass ("VISUALSTYLE.edge_intersection_line_pattern [BS]");
    else
      {
        fail ("VISUALSTYLE.edge_intersection_line_pattern [BS] %d != %d", visualstyle->edge_intersection_line_pattern, edge_intersection_line_pattern); error++;
      }
  }
  {
    BITCODE_BS edge_jitter;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "edge_jitter", &edge_jitter, NULL) &&
        edge_jitter == visualstyle->edge_jitter)
      pass ("VISUALSTYLE.edge_jitter [BS]");
    else
      {
        fail ("VISUALSTYLE.edge_jitter [BS] %d != %d", visualstyle->edge_jitter, edge_jitter); error++;
      }
  }
  {
    BITCODE_BS edge_model;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "edge_model", &edge_model, NULL) &&
        edge_model == visualstyle->edge_model)
      pass ("VISUALSTYLE.edge_model [BS]");
    else
      {
        fail ("VISUALSTYLE.edge_model [BS] %d != %d", visualstyle->edge_model, edge_model); error++;
      }
  }
  {
    BITCODE_BS edge_modifier;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "edge_modifier", &edge_modifier, NULL) &&
        edge_modifier == visualstyle->edge_modifier)
      pass ("VISUALSTYLE.edge_modifier [BS]");
    else
      {
        fail ("VISUALSTYLE.edge_modifier [BS] %d != %d", visualstyle->edge_modifier, edge_modifier); error++;
      }
  }
  {
    BITCODE_CMC edge_obscured_color;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "edge_obscured_color", &edge_obscured_color, NULL)
        && !memcmp(&edge_obscured_color, &visualstyle->edge_obscured_color, sizeof(visualstyle->edge_obscured_color)))
      pass ("VISUALSTYLE.edge_obscured_color");
    else
      {
        fail ("VISUALSTYLE.edge_obscured_color"); error++;
      }
  }
  {
    BITCODE_BS edge_obscured_line_pattern;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "edge_obscured_line_pattern", &edge_obscured_line_pattern, NULL) &&
        edge_obscured_line_pattern == visualstyle->edge_obscured_line_pattern)
      pass ("VISUALSTYLE.edge_obscured_line_pattern [BS]");
    else
      {
        fail ("VISUALSTYLE.edge_obscured_line_pattern [BS] %d != %d", visualstyle->edge_obscured_line_pattern, edge_obscured_line_pattern); error++;
      }
  }
  {
    BITCODE_BD edge_opacity;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "edge_opacity", &edge_opacity, NULL) &&
        edge_opacity == visualstyle->edge_opacity)
      pass ("VISUALSTYLE.edge_opacity [BD]");
    else
      {
        fail ("VISUALSTYLE.edge_opacity [BD] %g != %g", visualstyle->edge_opacity, edge_opacity); error++;
      }
  }
  {
    BITCODE_BS edge_overhang;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "edge_overhang", &edge_overhang, NULL) &&
        edge_overhang == visualstyle->edge_overhang)
      pass ("VISUALSTYLE.edge_overhang [BS]");
    else
      {
        fail ("VISUALSTYLE.edge_overhang [BS] %d != %d", visualstyle->edge_overhang, edge_overhang); error++;
      }
  }
  {
    BITCODE_CMC edge_silhouette_color;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "edge_silhouette_color", &edge_silhouette_color, NULL)
        && !memcmp(&edge_silhouette_color, &visualstyle->edge_silhouette_color, sizeof(visualstyle->edge_silhouette_color)))
      pass ("VISUALSTYLE.edge_silhouette_color");
    else
      {
        fail ("VISUALSTYLE.edge_silhouette_color"); error++;
      }
  }
  {
    BITCODE_BS edge_silhouette_width;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "edge_silhouette_width", &edge_silhouette_width, NULL) &&
        edge_silhouette_width == visualstyle->edge_silhouette_width)
      pass ("VISUALSTYLE.edge_silhouette_width [BS]");
    else
      {
        fail ("VISUALSTYLE.edge_silhouette_width [BS] %d != %d", visualstyle->edge_silhouette_width, edge_silhouette_width); error++;
      }
  }
  {
    BITCODE_BL edge_style;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "edge_style", &edge_style, NULL) &&
        edge_style == visualstyle->edge_style)
      pass ("VISUALSTYLE.edge_style [BL]");
    else
      {
        fail ("VISUALSTYLE.edge_style [BL] %u != %u", visualstyle->edge_style, edge_style); error++;
      }
  }
  {
    BITCODE_BS edge_style_apply_flag;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "edge_style_apply_flag", &edge_style_apply_flag, NULL) &&
        edge_style_apply_flag == visualstyle->edge_style_apply_flag)
      pass ("VISUALSTYLE.edge_style_apply_flag [BS]");
    else
      {
        fail ("VISUALSTYLE.edge_style_apply_flag [BS] %d != %d", visualstyle->edge_style_apply_flag, edge_style_apply_flag); error++;
      }
  }
  {
    BITCODE_BS edge_width;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "edge_width", &edge_width, NULL) &&
        edge_width == visualstyle->edge_width)
      pass ("VISUALSTYLE.edge_width [BS]");
    else
      {
        fail ("VISUALSTYLE.edge_width [BS] %d != %d", visualstyle->edge_width, edge_width); error++;
      }
  }
  {
    BITCODE_BS face_color_mode;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "face_color_mode", &face_color_mode, NULL) &&
        face_color_mode == visualstyle->face_color_mode)
      pass ("VISUALSTYLE.face_color_mode [BS]");
    else
      {
        fail ("VISUALSTYLE.face_color_mode [BS] %d != %d", visualstyle->face_color_mode, face_color_mode); error++;
      }
  }
  {
    BITCODE_BS face_lighting_model;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "face_lighting_model", &face_lighting_model, NULL) &&
        face_lighting_model == visualstyle->face_lighting_model)
      pass ("VISUALSTYLE.face_lighting_model [BS]");
    else
      {
        fail ("VISUALSTYLE.face_lighting_model [BS] %d != %d", visualstyle->face_lighting_model, face_lighting_model); error++;
      }
  }
  {
    BITCODE_BS face_lighting_quality;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "face_lighting_quality", &face_lighting_quality, NULL) &&
        face_lighting_quality == visualstyle->face_lighting_quality)
      pass ("VISUALSTYLE.face_lighting_quality [BS]");
    else
      {
        fail ("VISUALSTYLE.face_lighting_quality [BS] %d != %d", visualstyle->face_lighting_quality, face_lighting_quality); error++;
      }
  }
  {
    BITCODE_BS face_modifier;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "face_modifier", &face_modifier, NULL) &&
        face_modifier == visualstyle->face_modifier)
      pass ("VISUALSTYLE.face_modifier [BS]");
    else
      {
        fail ("VISUALSTYLE.face_modifier [BS] %d != %d", visualstyle->face_modifier, face_modifier); error++;
      }
  }
  {
    BITCODE_CMC face_mono_color;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "face_mono_color", &face_mono_color, NULL)
        && !memcmp(&face_mono_color, &visualstyle->face_mono_color, sizeof(visualstyle->face_mono_color)))
      pass ("VISUALSTYLE.face_mono_color");
    else
      {
        fail ("VISUALSTYLE.face_mono_color"); error++;
      }
  }
  {
    BITCODE_BD face_opacity;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "face_opacity", &face_opacity, NULL) &&
        face_opacity == visualstyle->face_opacity)
      pass ("VISUALSTYLE.face_opacity [BD]");
    else
      {
        fail ("VISUALSTYLE.face_opacity [BD] %g != %g", visualstyle->face_opacity, face_opacity); error++;
      }
  }
  {
    BITCODE_BD face_specular;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "face_specular", &face_specular, NULL) &&
        face_specular == visualstyle->face_specular)
      pass ("VISUALSTYLE.face_specular [BD]");
    else
      {
        fail ("VISUALSTYLE.face_specular [BD] %g != %g", visualstyle->face_specular, face_specular); error++;
      }
  }
  {
    BITCODE_BS is_internal_use_only;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "is_internal_use_only", &is_internal_use_only, NULL) &&
        is_internal_use_only == visualstyle->is_internal_use_only)
      pass ("VISUALSTYLE.is_internal_use_only [BS]");
    else
      {
        fail ("VISUALSTYLE.is_internal_use_only [BS] %d != %d", visualstyle->is_internal_use_only, is_internal_use_only); error++;
      }
  }
  {
    BITCODE_BS num_edge_isolines;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "num_edge_isolines", &num_edge_isolines, NULL) &&
        num_edge_isolines == visualstyle->num_edge_isolines)
      pass ("VISUALSTYLE.num_edge_isolines [BS]");
    else
      {
        fail ("VISUALSTYLE.num_edge_isolines [BS] %d != %d", visualstyle->num_edge_isolines, num_edge_isolines); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "ownerhandle", &ownerhandle, NULL) &&
        ownerhandle == visualstyle->ownerhandle)
      pass ("VISUALSTYLE.ownerhandle [H]");
    else
      {
        fail ("VISUALSTYLE.ownerhandle [H] %p != %p", visualstyle->ownerhandle, ownerhandle); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "parent", &parent, NULL)
        && !memcmp(&parent, &visualstyle->parent, sizeof(visualstyle->parent)))
      pass ("VISUALSTYLE.parent");
    else
      {
        fail ("VISUALSTYLE.parent"); error++;
      }
  }
  {
    BITCODE_BS type;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "type", &type, NULL) &&
        type == visualstyle->type)
      pass ("VISUALSTYLE.type [BS]");
    else
      {
        fail ("VISUALSTYLE.type [BS] %d != %d", visualstyle->type, type); error++;
      }
  }
  {
    BITCODE_BS unknown_float45;
    if (dwg_dynapi_entity_value(visualstyle, "VISUALSTYLE", "unknown_float45", &unknown_float45, NULL) &&
        unknown_float45 == visualstyle->unknown_float45)
      pass ("VISUALSTYLE.unknown_float45 [BS]");
    else
      {
        fail ("VISUALSTYLE.unknown_float45 [BS] %d != %d", visualstyle->unknown_float45, unknown_float45); error++;
      }
  }
  return error;
}
static int test_VPORT (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_VPORT *vport = obj->tio.object->tio.VPORT;
  {
    BITCODE_B FASTZOOM;
    if (dwg_dynapi_entity_value(vport, "VPORT", "FASTZOOM", &FASTZOOM, NULL) &&
        FASTZOOM == vport->FASTZOOM)
      pass ("VPORT.FASTZOOM [B]");
    else
      {
        fail ("VPORT.FASTZOOM [B] " FORMAT_B " != " FORMAT_B "", vport->FASTZOOM, FASTZOOM); error++;
      }
  }
  {
    BITCODE_B GRIDMODE;
    if (dwg_dynapi_entity_value(vport, "VPORT", "GRIDMODE", &GRIDMODE, NULL) &&
        GRIDMODE == vport->GRIDMODE)
      pass ("VPORT.GRIDMODE [B]");
    else
      {
        fail ("VPORT.GRIDMODE [B] " FORMAT_B " != " FORMAT_B "", vport->GRIDMODE, GRIDMODE); error++;
      }
  }
  {
    BITCODE_2RD GRIDUNIT;
    if (dwg_dynapi_entity_value(vport, "VPORT", "GRIDUNIT", &GRIDUNIT, NULL)
        && !memcmp(&GRIDUNIT, &vport->GRIDUNIT, sizeof(vport->GRIDUNIT)))
      pass ("VPORT.GRIDUNIT");
    else
      {
        fail ("VPORT.GRIDUNIT"); error++;
      }
  }
  {
    BITCODE_BD SNAPANG;
    if (dwg_dynapi_entity_value(vport, "VPORT", "SNAPANG", &SNAPANG, NULL) &&
        SNAPANG == vport->SNAPANG)
      pass ("VPORT.SNAPANG [BD]");
    else
      {
        fail ("VPORT.SNAPANG [BD] %g != %g", vport->SNAPANG, SNAPANG); error++;
      }
  }
  {
    BITCODE_2RD SNAPBASE;
    if (dwg_dynapi_entity_value(vport, "VPORT", "SNAPBASE", &SNAPBASE, NULL)
        && !memcmp(&SNAPBASE, &vport->SNAPBASE, sizeof(vport->SNAPBASE)))
      pass ("VPORT.SNAPBASE");
    else
      {
        fail ("VPORT.SNAPBASE"); error++;
      }
  }
  {
    BITCODE_BS SNAPISOPAIR;
    if (dwg_dynapi_entity_value(vport, "VPORT", "SNAPISOPAIR", &SNAPISOPAIR, NULL) &&
        SNAPISOPAIR == vport->SNAPISOPAIR)
      pass ("VPORT.SNAPISOPAIR [BS]");
    else
      {
        fail ("VPORT.SNAPISOPAIR [BS] %d != %d", vport->SNAPISOPAIR, SNAPISOPAIR); error++;
      }
  }
  {
    BITCODE_B SNAPMODE;
    if (dwg_dynapi_entity_value(vport, "VPORT", "SNAPMODE", &SNAPMODE, NULL) &&
        SNAPMODE == vport->SNAPMODE)
      pass ("VPORT.SNAPMODE [B]");
    else
      {
        fail ("VPORT.SNAPMODE [B] " FORMAT_B " != " FORMAT_B "", vport->SNAPMODE, SNAPMODE); error++;
      }
  }
  {
    BITCODE_B SNAPSTYLE;
    if (dwg_dynapi_entity_value(vport, "VPORT", "SNAPSTYLE", &SNAPSTYLE, NULL) &&
        SNAPSTYLE == vport->SNAPSTYLE)
      pass ("VPORT.SNAPSTYLE [B]");
    else
      {
        fail ("VPORT.SNAPSTYLE [B] " FORMAT_B " != " FORMAT_B "", vport->SNAPSTYLE, SNAPSTYLE); error++;
      }
  }
  {
    BITCODE_2RD SNAPUNIT;
    if (dwg_dynapi_entity_value(vport, "VPORT", "SNAPUNIT", &SNAPUNIT, NULL)
        && !memcmp(&SNAPUNIT, &vport->SNAPUNIT, sizeof(vport->SNAPUNIT)))
      pass ("VPORT.SNAPUNIT");
    else
      {
        fail ("VPORT.SNAPUNIT"); error++;
      }
  }
  {
    BITCODE_B UCSFOLLOW;
    if (dwg_dynapi_entity_value(vport, "VPORT", "UCSFOLLOW", &UCSFOLLOW, NULL) &&
        UCSFOLLOW == vport->UCSFOLLOW)
      pass ("VPORT.UCSFOLLOW [B]");
    else
      {
        fail ("VPORT.UCSFOLLOW [B] " FORMAT_B " != " FORMAT_B "", vport->UCSFOLLOW, UCSFOLLOW); error++;
      }
  }
  {
    BITCODE_RC UCSICON;
    if (dwg_dynapi_entity_value(vport, "VPORT", "UCSICON", &UCSICON, NULL) &&
        UCSICON == vport->UCSICON)
      pass ("VPORT.UCSICON [RC]");
    else
      {
        fail ("VPORT.UCSICON [RC] %c != %c", vport->UCSICON, UCSICON); error++;
      }
  }
  {
    BITCODE_2RD VIEWCTR;
    if (dwg_dynapi_entity_value(vport, "VPORT", "VIEWCTR", &VIEWCTR, NULL)
        && !memcmp(&VIEWCTR, &vport->VIEWCTR, sizeof(vport->VIEWCTR)))
      pass ("VPORT.VIEWCTR");
    else
      {
        fail ("VPORT.VIEWCTR"); error++;
      }
  }
  {
    BITCODE_3BD VIEWDIR;
    if (dwg_dynapi_entity_value(vport, "VPORT", "VIEWDIR", &VIEWDIR, NULL)
        && !memcmp(&VIEWDIR, &vport->VIEWDIR, sizeof(vport->VIEWDIR)))
      pass ("VPORT.VIEWDIR");
    else
      {
        fail ("VPORT.VIEWDIR"); error++;
      }
  }
  {
    BITCODE_4BITS VIEWMODE;
    if (dwg_dynapi_entity_value(vport, "VPORT", "VIEWMODE", &VIEWMODE, NULL) &&
        VIEWMODE == vport->VIEWMODE)
      pass ("VPORT.VIEWMODE [4BITS]");
    else
      {
        fail ("VPORT.VIEWMODE [4BITS] " FORMAT_4BITS " != " FORMAT_4BITS "", vport->VIEWMODE, VIEWMODE); error++;
      }
  }
  {
    BITCODE_BD VIEWSIZE;
    if (dwg_dynapi_entity_value(vport, "VPORT", "VIEWSIZE", &VIEWSIZE, NULL) &&
        VIEWSIZE == vport->VIEWSIZE)
      pass ("VPORT.VIEWSIZE [BD]");
    else
      {
        fail ("VPORT.VIEWSIZE [BD] %g != %g", vport->VIEWSIZE, VIEWSIZE); error++;
      }
  }
  {
    BITCODE_CMC ambient_color;
    if (dwg_dynapi_entity_value(vport, "VPORT", "ambient_color", &ambient_color, NULL)
        && !memcmp(&ambient_color, &vport->ambient_color, sizeof(vport->ambient_color)))
      pass ("VPORT.ambient_color");
    else
      {
        fail ("VPORT.ambient_color"); error++;
      }
  }
  {
    BITCODE_BD aspect_ratio;
    if (dwg_dynapi_entity_value(vport, "VPORT", "aspect_ratio", &aspect_ratio, NULL) &&
        aspect_ratio == vport->aspect_ratio)
      pass ("VPORT.aspect_ratio [BD]");
    else
      {
        fail ("VPORT.aspect_ratio [BD] %g != %g", vport->aspect_ratio, aspect_ratio); error++;
      }
  }
  {
    BITCODE_BD back_clip;
    if (dwg_dynapi_entity_value(vport, "VPORT", "back_clip", &back_clip, NULL) &&
        back_clip == vport->back_clip)
      pass ("VPORT.back_clip [BD]");
    else
      {
        fail ("VPORT.back_clip [BD] %g != %g", vport->back_clip, back_clip); error++;
      }
  }
  {
    BITCODE_H background_handle;
    if (dwg_dynapi_entity_value(vport, "VPORT", "background_handle", &background_handle, NULL) &&
        background_handle == vport->background_handle)
      pass ("VPORT.background_handle [H]");
    else
      {
        fail ("VPORT.background_handle [H] %p != %p", vport->background_handle, background_handle); error++;
      }
  }
  {
    BITCODE_H base_ucs_handle;
    if (dwg_dynapi_entity_value(vport, "VPORT", "base_ucs_handle", &base_ucs_handle, NULL) &&
        base_ucs_handle == vport->base_ucs_handle)
      pass ("VPORT.base_ucs_handle [H]");
    else
      {
        fail ("VPORT.base_ucs_handle [H] %p != %p", vport->base_ucs_handle, base_ucs_handle); error++;
      }
  }
  {
    BITCODE_BD brightness;
    if (dwg_dynapi_entity_value(vport, "VPORT", "brightness", &brightness, NULL) &&
        brightness == vport->brightness)
      pass ("VPORT.brightness [BD]");
    else
      {
        fail ("VPORT.brightness [BD] %g != %g", vport->brightness, brightness); error++;
      }
  }
  {
    BITCODE_BS circle_zoom;
    if (dwg_dynapi_entity_value(vport, "VPORT", "circle_zoom", &circle_zoom, NULL) &&
        circle_zoom == vport->circle_zoom)
      pass ("VPORT.circle_zoom [BS]");
    else
      {
        fail ("VPORT.circle_zoom [BS] %d != %d", vport->circle_zoom, circle_zoom); error++;
      }
  }
  {
    BITCODE_BD contrast;
    if (dwg_dynapi_entity_value(vport, "VPORT", "contrast", &contrast, NULL) &&
        contrast == vport->contrast)
      pass ("VPORT.contrast [BD]");
    else
      {
        fail ("VPORT.contrast [BD] %g != %g", vport->contrast, contrast); error++;
      }
  }
  {
    BITCODE_RC default_lightning_type;
    if (dwg_dynapi_entity_value(vport, "VPORT", "default_lightning_type", &default_lightning_type, NULL) &&
        default_lightning_type == vport->default_lightning_type)
      pass ("VPORT.default_lightning_type [RC]");
    else
      {
        fail ("VPORT.default_lightning_type [RC] %c != %c", vport->default_lightning_type, default_lightning_type); error++;
      }
  }
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value(vport, "VPORT", "flag", &flag, NULL) &&
        flag == vport->flag)
      pass ("VPORT.flag [RC]");
    else
      {
        fail ("VPORT.flag [RC] %c != %c", vport->flag, flag); error++;
      }
  }
  {
    BITCODE_BD front_clip;
    if (dwg_dynapi_entity_value(vport, "VPORT", "front_clip", &front_clip, NULL) &&
        front_clip == vport->front_clip)
      pass ("VPORT.front_clip [BD]");
    else
      {
        fail ("VPORT.front_clip [BD] %g != %g", vport->front_clip, front_clip); error++;
      }
  }
  {
    BITCODE_BS grid_flags;
    if (dwg_dynapi_entity_value(vport, "VPORT", "grid_flags", &grid_flags, NULL) &&
        grid_flags == vport->grid_flags)
      pass ("VPORT.grid_flags [BS]");
    else
      {
        fail ("VPORT.grid_flags [BS] %d != %d", vport->grid_flags, grid_flags); error++;
      }
  }
  {
    BITCODE_BS grid_major;
    if (dwg_dynapi_entity_value(vport, "VPORT", "grid_major", &grid_major, NULL) &&
        grid_major == vport->grid_major)
      pass ("VPORT.grid_major [BS]");
    else
      {
        fail ("VPORT.grid_major [BS] %d != %d", vport->grid_major, grid_major); error++;
      }
  }
  {
    BITCODE_BD lens_length;
    if (dwg_dynapi_entity_value(vport, "VPORT", "lens_length", &lens_length, NULL) &&
        lens_length == vport->lens_length)
      pass ("VPORT.lens_length [BD]");
    else
      {
        fail ("VPORT.lens_length [BD] %g != %g", vport->lens_length, lens_length); error++;
      }
  }
  {
    BITCODE_2RD lower_left;
    if (dwg_dynapi_entity_value(vport, "VPORT", "lower_left", &lower_left, NULL)
        && !memcmp(&lower_left, &vport->lower_left, sizeof(vport->lower_left)))
      pass ("VPORT.lower_left");
    else
      {
        fail ("VPORT.lower_left"); error++;
      }
  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value(vport, "VPORT", "name", &name, NULL)
        && !strcmp((char*)&name, (char*)&vport->name))
      pass ("VPORT.name");
    else
      {
        fail ("VPORT.name"); error++;
      }
  }
  {
    BITCODE_H named_ucs_handle;
    if (dwg_dynapi_entity_value(vport, "VPORT", "named_ucs_handle", &named_ucs_handle, NULL) &&
        named_ucs_handle == vport->named_ucs_handle)
      pass ("VPORT.named_ucs_handle [H]");
    else
      {
        fail ("VPORT.named_ucs_handle [H] %p != %p", vport->named_ucs_handle, named_ucs_handle); error++;
      }
  }
  {
    BITCODE_H null_handle;
    if (dwg_dynapi_entity_value(vport, "VPORT", "null_handle", &null_handle, NULL) &&
        null_handle == vport->null_handle)
      pass ("VPORT.null_handle [H]");
    else
      {
        fail ("VPORT.null_handle [H] %p != %p", vport->null_handle, null_handle); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(vport, "VPORT", "parent", &parent, NULL)
        && !memcmp(&parent, &vport->parent, sizeof(vport->parent)))
      pass ("VPORT.parent");
    else
      {
        fail ("VPORT.parent"); error++;
      }
  }
  {
    BITCODE_RC render_mode;
    if (dwg_dynapi_entity_value(vport, "VPORT", "render_mode", &render_mode, NULL) &&
        render_mode == vport->render_mode)
      pass ("VPORT.render_mode [RC]");
    else
      {
        fail ("VPORT.render_mode [RC] %c != %c", vport->render_mode, render_mode); error++;
      }
  }
  {
    BITCODE_H sun_handle;
    if (dwg_dynapi_entity_value(vport, "VPORT", "sun_handle", &sun_handle, NULL) &&
        sun_handle == vport->sun_handle)
      pass ("VPORT.sun_handle [H]");
    else
      {
        fail ("VPORT.sun_handle [H] %p != %p", vport->sun_handle, sun_handle); error++;
      }
  }
  {
    BITCODE_BD ucs_elevation;
    if (dwg_dynapi_entity_value(vport, "VPORT", "ucs_elevation", &ucs_elevation, NULL) &&
        ucs_elevation == vport->ucs_elevation)
      pass ("VPORT.ucs_elevation [BD]");
    else
      {
        fail ("VPORT.ucs_elevation [BD] %g != %g", vport->ucs_elevation, ucs_elevation); error++;
      }
  }
  {
    BITCODE_3BD ucs_origin;
    if (dwg_dynapi_entity_value(vport, "VPORT", "ucs_origin", &ucs_origin, NULL)
        && !memcmp(&ucs_origin, &vport->ucs_origin, sizeof(vport->ucs_origin)))
      pass ("VPORT.ucs_origin");
    else
      {
        fail ("VPORT.ucs_origin"); error++;
      }
  }
  {
    BITCODE_BS ucs_orthografic_type;
    if (dwg_dynapi_entity_value(vport, "VPORT", "ucs_orthografic_type", &ucs_orthografic_type, NULL) &&
        ucs_orthografic_type == vport->ucs_orthografic_type)
      pass ("VPORT.ucs_orthografic_type [BS]");
    else
      {
        fail ("VPORT.ucs_orthografic_type [BS] %d != %d", vport->ucs_orthografic_type, ucs_orthografic_type); error++;
      }
  }
  {
    BITCODE_B ucs_pre_viewport;
    if (dwg_dynapi_entity_value(vport, "VPORT", "ucs_pre_viewport", &ucs_pre_viewport, NULL) &&
        ucs_pre_viewport == vport->ucs_pre_viewport)
      pass ("VPORT.ucs_pre_viewport [B]");
    else
      {
        fail ("VPORT.ucs_pre_viewport [B] " FORMAT_B " != " FORMAT_B "", vport->ucs_pre_viewport, ucs_pre_viewport); error++;
      }
  }
  {
    BITCODE_3BD ucs_x_axis;
    if (dwg_dynapi_entity_value(vport, "VPORT", "ucs_x_axis", &ucs_x_axis, NULL)
        && !memcmp(&ucs_x_axis, &vport->ucs_x_axis, sizeof(vport->ucs_x_axis)))
      pass ("VPORT.ucs_x_axis");
    else
      {
        fail ("VPORT.ucs_x_axis"); error++;
      }
  }
  {
    BITCODE_3BD ucs_y_axis;
    if (dwg_dynapi_entity_value(vport, "VPORT", "ucs_y_axis", &ucs_y_axis, NULL)
        && !memcmp(&ucs_y_axis, &vport->ucs_y_axis, sizeof(vport->ucs_y_axis)))
      pass ("VPORT.ucs_y_axis");
    else
      {
        fail ("VPORT.ucs_y_axis"); error++;
      }
  }
  {
    BITCODE_B unknown;
    if (dwg_dynapi_entity_value(vport, "VPORT", "unknown", &unknown, NULL) &&
        unknown == vport->unknown)
      pass ("VPORT.unknown [B]");
    else
      {
        fail ("VPORT.unknown [B] " FORMAT_B " != " FORMAT_B "", vport->unknown, unknown); error++;
      }
  }
  {
    BITCODE_2RD upper_right;
    if (dwg_dynapi_entity_value(vport, "VPORT", "upper_right", &upper_right, NULL)
        && !memcmp(&upper_right, &vport->upper_right, sizeof(vport->upper_right)))
      pass ("VPORT.upper_right");
    else
      {
        fail ("VPORT.upper_right"); error++;
      }
  }
  {
    BITCODE_B use_default_lights;
    if (dwg_dynapi_entity_value(vport, "VPORT", "use_default_lights", &use_default_lights, NULL) &&
        use_default_lights == vport->use_default_lights)
      pass ("VPORT.use_default_lights [B]");
    else
      {
        fail ("VPORT.use_default_lights [B] " FORMAT_B " != " FORMAT_B "", vport->use_default_lights, use_default_lights); error++;
      }
  }
  {
    BITCODE_RS used;
    if (dwg_dynapi_entity_value(vport, "VPORT", "used", &used, NULL) &&
        used == vport->used)
      pass ("VPORT.used [RS]");
    else
      {
        fail ("VPORT.used [RS] " FORMAT_RS " != " FORMAT_RS "", vport->used, used); error++;
      }
  }
  {
    BITCODE_3BD view_target;
    if (dwg_dynapi_entity_value(vport, "VPORT", "view_target", &view_target, NULL)
        && !memcmp(&view_target, &vport->view_target, sizeof(vport->view_target)))
      pass ("VPORT.view_target");
    else
      {
        fail ("VPORT.view_target"); error++;
      }
  }
  {
    BITCODE_BD view_twist;
    if (dwg_dynapi_entity_value(vport, "VPORT", "view_twist", &view_twist, NULL) &&
        view_twist == vport->view_twist)
      pass ("VPORT.view_twist [BD]");
    else
      {
        fail ("VPORT.view_twist [BD] %g != %g", vport->view_twist, view_twist); error++;
      }
  }
  {
    BITCODE_H visual_style_handle;
    if (dwg_dynapi_entity_value(vport, "VPORT", "visual_style_handle", &visual_style_handle, NULL) &&
        visual_style_handle == vport->visual_style_handle)
      pass ("VPORT.visual_style_handle [H]");
    else
      {
        fail ("VPORT.visual_style_handle [H] %p != %p", vport->visual_style_handle, visual_style_handle); error++;
      }
  }
  {
    BITCODE_H vport_control;
    if (dwg_dynapi_entity_value(vport, "VPORT", "vport_control", &vport_control, NULL) &&
        vport_control == vport->vport_control)
      pass ("VPORT.vport_control [H]");
    else
      {
        fail ("VPORT.vport_control [H] %p != %p", vport->vport_control, vport_control); error++;
      }
  }
  {
    BITCODE_B xrefdep;
    if (dwg_dynapi_entity_value(vport, "VPORT", "xrefdep", &xrefdep, NULL) &&
        xrefdep == vport->xrefdep)
      pass ("VPORT.xrefdep [B]");
    else
      {
        fail ("VPORT.xrefdep [B] " FORMAT_B " != " FORMAT_B "", vport->xrefdep, xrefdep); error++;
      }
  }
  {
    BITCODE_BS xrefindex_plus1;
    if (dwg_dynapi_entity_value(vport, "VPORT", "xrefindex_plus1", &xrefindex_plus1, NULL) &&
        xrefindex_plus1 == vport->xrefindex_plus1)
      pass ("VPORT.xrefindex_plus1 [BS]");
    else
      {
        fail ("VPORT.xrefindex_plus1 [BS] %d != %d", vport->xrefindex_plus1, xrefindex_plus1); error++;
      }
  }
  {
    BITCODE_B xrefref;
    if (dwg_dynapi_entity_value(vport, "VPORT", "xrefref", &xrefref, NULL) &&
        xrefref == vport->xrefref)
      pass ("VPORT.xrefref [B]");
    else
      {
        fail ("VPORT.xrefref [B] " FORMAT_B " != " FORMAT_B "", vport->xrefref, xrefref); error++;
      }
  }
  return error;
}
static int test_VPORT_CONTROL (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_VPORT_CONTROL *vport_control = obj->tio.object->tio.VPORT_CONTROL;
  {
    Dwg_Object_Ref* null_handle;
    if (dwg_dynapi_entity_value(vport_control, "VPORT_CONTROL", "null_handle", &null_handle, NULL)
        && !memcmp(&null_handle, &vport_control->null_handle, sizeof(vport_control->null_handle)))
      pass ("VPORT_CONTROL.null_handle");
    else
      {
        fail ("VPORT_CONTROL.null_handle"); error++;
      }
  }
  {
    BITCODE_BS num_entries;
    if (dwg_dynapi_entity_value(vport_control, "VPORT_CONTROL", "num_entries", &num_entries, NULL) &&
        num_entries == vport_control->num_entries)
      pass ("VPORT_CONTROL.num_entries [BS]");
    else
      {
        fail ("VPORT_CONTROL.num_entries [BS] %d != %d", vport_control->num_entries, num_entries); error++;
      }
  }
  {
    BITCODE_BL objid;
    if (dwg_dynapi_entity_value(vport_control, "VPORT_CONTROL", "objid", &objid, NULL) &&
        objid == vport_control->objid)
      pass ("VPORT_CONTROL.objid [BL]");
    else
      {
        fail ("VPORT_CONTROL.objid [BL] %u != %u", vport_control->objid, objid); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(vport_control, "VPORT_CONTROL", "parent", &parent, NULL)
        && !memcmp(&parent, &vport_control->parent, sizeof(vport_control->parent)))
      pass ("VPORT_CONTROL.parent");
    else
      {
        fail ("VPORT_CONTROL.parent"); error++;
      }
  }
  {
    Dwg_Object_Ref* reactors;
    if (dwg_dynapi_entity_value(vport_control, "VPORT_CONTROL", "reactors", &reactors, NULL)
        && !memcmp(&reactors, &vport_control->reactors, sizeof(vport_control->reactors)))
      pass ("VPORT_CONTROL.reactors");
    else
      {
        fail ("VPORT_CONTROL.reactors"); error++;
      }
  }
  {
    Dwg_Object_Ref* vports;
    if (dwg_dynapi_entity_value(vport_control, "VPORT_CONTROL", "vports", &vports, NULL)
        && !memcmp(&vports, &vport_control->vports, sizeof(vport_control->vports)))
      pass ("VPORT_CONTROL.vports");
    else
      {
        fail ("VPORT_CONTROL.vports"); error++;
      }
  }
  {
    Dwg_Object_Ref* xdicobjhandle;
    if (dwg_dynapi_entity_value(vport_control, "VPORT_CONTROL", "xdicobjhandle", &xdicobjhandle, NULL)
        && !memcmp(&xdicobjhandle, &vport_control->xdicobjhandle, sizeof(vport_control->xdicobjhandle)))
      pass ("VPORT_CONTROL.xdicobjhandle");
    else
      {
        fail ("VPORT_CONTROL.xdicobjhandle"); error++;
      }
  }
  return error;
}
static int test_VPORT_ENTITY_CONTROL (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_VPORT_ENTITY_CONTROL *vport_entity_control = obj->tio.object->tio.VPORT_ENTITY_CONTROL;
  {
    Dwg_Object_Ref* null_handle;
    if (dwg_dynapi_entity_value(vport_entity_control, "VPORT_ENTITY_CONTROL", "null_handle", &null_handle, NULL)
        && !memcmp(&null_handle, &vport_entity_control->null_handle, sizeof(vport_entity_control->null_handle)))
      pass ("VPORT_ENTITY_CONTROL.null_handle");
    else
      {
        fail ("VPORT_ENTITY_CONTROL.null_handle"); error++;
      }
  }
  {
    BITCODE_BS num_entries;
    if (dwg_dynapi_entity_value(vport_entity_control, "VPORT_ENTITY_CONTROL", "num_entries", &num_entries, NULL) &&
        num_entries == vport_entity_control->num_entries)
      pass ("VPORT_ENTITY_CONTROL.num_entries [BS]");
    else
      {
        fail ("VPORT_ENTITY_CONTROL.num_entries [BS] %d != %d", vport_entity_control->num_entries, num_entries); error++;
      }
  }
  {
    BITCODE_BL objid;
    if (dwg_dynapi_entity_value(vport_entity_control, "VPORT_ENTITY_CONTROL", "objid", &objid, NULL) &&
        objid == vport_entity_control->objid)
      pass ("VPORT_ENTITY_CONTROL.objid [BL]");
    else
      {
        fail ("VPORT_ENTITY_CONTROL.objid [BL] %u != %u", vport_entity_control->objid, objid); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(vport_entity_control, "VPORT_ENTITY_CONTROL", "parent", &parent, NULL)
        && !memcmp(&parent, &vport_entity_control->parent, sizeof(vport_entity_control->parent)))
      pass ("VPORT_ENTITY_CONTROL.parent");
    else
      {
        fail ("VPORT_ENTITY_CONTROL.parent"); error++;
      }
  }
  {
    Dwg_Object_Ref* reactors;
    if (dwg_dynapi_entity_value(vport_entity_control, "VPORT_ENTITY_CONTROL", "reactors", &reactors, NULL)
        && !memcmp(&reactors, &vport_entity_control->reactors, sizeof(vport_entity_control->reactors)))
      pass ("VPORT_ENTITY_CONTROL.reactors");
    else
      {
        fail ("VPORT_ENTITY_CONTROL.reactors"); error++;
      }
  }
  {
    Dwg_Object_Ref* vport_entity_headers;
    if (dwg_dynapi_entity_value(vport_entity_control, "VPORT_ENTITY_CONTROL", "vport_entity_headers", &vport_entity_headers, NULL)
        && !memcmp(&vport_entity_headers, &vport_entity_control->vport_entity_headers, sizeof(vport_entity_control->vport_entity_headers)))
      pass ("VPORT_ENTITY_CONTROL.vport_entity_headers");
    else
      {
        fail ("VPORT_ENTITY_CONTROL.vport_entity_headers"); error++;
      }
  }
  {
    Dwg_Object_Ref* xdicobjhandle;
    if (dwg_dynapi_entity_value(vport_entity_control, "VPORT_ENTITY_CONTROL", "xdicobjhandle", &xdicobjhandle, NULL)
        && !memcmp(&xdicobjhandle, &vport_entity_control->xdicobjhandle, sizeof(vport_entity_control->xdicobjhandle)))
      pass ("VPORT_ENTITY_CONTROL.xdicobjhandle");
    else
      {
        fail ("VPORT_ENTITY_CONTROL.xdicobjhandle"); error++;
      }
  }
  return error;
}
static int test_VPORT_ENTITY_HEADER (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_VPORT_ENTITY_HEADER *vport_entity_header = obj->tio.object->tio.VPORT_ENTITY_HEADER;
  {
    BITCODE_RC flag;
    if (dwg_dynapi_entity_value(vport_entity_header, "VPORT_ENTITY_HEADER", "flag", &flag, NULL) &&
        flag == vport_entity_header->flag)
      pass ("VPORT_ENTITY_HEADER.flag [RC]");
    else
      {
        fail ("VPORT_ENTITY_HEADER.flag [RC] %c != %c", vport_entity_header->flag, flag); error++;
      }
  }
  {
    BITCODE_B flag1;
    if (dwg_dynapi_entity_value(vport_entity_header, "VPORT_ENTITY_HEADER", "flag1", &flag1, NULL) &&
        flag1 == vport_entity_header->flag1)
      pass ("VPORT_ENTITY_HEADER.flag1 [B]");
    else
      {
        fail ("VPORT_ENTITY_HEADER.flag1 [B] " FORMAT_B " != " FORMAT_B "", vport_entity_header->flag1, flag1); error++;
      }
  }
  {
    BITCODE_TV name;
    if (dwg_dynapi_entity_value(vport_entity_header, "VPORT_ENTITY_HEADER", "name", &name, NULL)
        && !strcmp((char*)&name, (char*)&vport_entity_header->name))
      pass ("VPORT_ENTITY_HEADER.name");
    else
      {
        fail ("VPORT_ENTITY_HEADER.name"); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(vport_entity_header, "VPORT_ENTITY_HEADER", "parent", &parent, NULL)
        && !memcmp(&parent, &vport_entity_header->parent, sizeof(vport_entity_header->parent)))
      pass ("VPORT_ENTITY_HEADER.parent");
    else
      {
        fail ("VPORT_ENTITY_HEADER.parent"); error++;
      }
  }
  {
    BITCODE_RS used;
    if (dwg_dynapi_entity_value(vport_entity_header, "VPORT_ENTITY_HEADER", "used", &used, NULL) &&
        used == vport_entity_header->used)
      pass ("VPORT_ENTITY_HEADER.used [RS]");
    else
      {
        fail ("VPORT_ENTITY_HEADER.used [RS] " FORMAT_RS " != " FORMAT_RS "", vport_entity_header->used, used); error++;
      }
  }
  {
    BITCODE_H vport_entity;
    if (dwg_dynapi_entity_value(vport_entity_header, "VPORT_ENTITY_HEADER", "vport_entity", &vport_entity, NULL) &&
        vport_entity == vport_entity_header->vport_entity)
      pass ("VPORT_ENTITY_HEADER.vport_entity [H]");
    else
      {
        fail ("VPORT_ENTITY_HEADER.vport_entity [H] %p != %p", vport_entity_header->vport_entity, vport_entity); error++;
      }
  }
  {
    BITCODE_H vport_entity_control;
    if (dwg_dynapi_entity_value(vport_entity_header, "VPORT_ENTITY_HEADER", "vport_entity_control", &vport_entity_control, NULL) &&
        vport_entity_control == vport_entity_header->vport_entity_control)
      pass ("VPORT_ENTITY_HEADER.vport_entity_control [H]");
    else
      {
        fail ("VPORT_ENTITY_HEADER.vport_entity_control [H] %p != %p", vport_entity_header->vport_entity_control, vport_entity_control); error++;
      }
  }
  {
    BITCODE_H xref_handle;
    if (dwg_dynapi_entity_value(vport_entity_header, "VPORT_ENTITY_HEADER", "xref_handle", &xref_handle, NULL) &&
        xref_handle == vport_entity_header->xref_handle)
      pass ("VPORT_ENTITY_HEADER.xref_handle [H]");
    else
      {
        fail ("VPORT_ENTITY_HEADER.xref_handle [H] %p != %p", vport_entity_header->xref_handle, xref_handle); error++;
      }
  }
  {
    BITCODE_B xrefdep;
    if (dwg_dynapi_entity_value(vport_entity_header, "VPORT_ENTITY_HEADER", "xrefdep", &xrefdep, NULL) &&
        xrefdep == vport_entity_header->xrefdep)
      pass ("VPORT_ENTITY_HEADER.xrefdep [B]");
    else
      {
        fail ("VPORT_ENTITY_HEADER.xrefdep [B] " FORMAT_B " != " FORMAT_B "", vport_entity_header->xrefdep, xrefdep); error++;
      }
  }
  {
    BITCODE_BS xrefindex_plus1;
    if (dwg_dynapi_entity_value(vport_entity_header, "VPORT_ENTITY_HEADER", "xrefindex_plus1", &xrefindex_plus1, NULL) &&
        xrefindex_plus1 == vport_entity_header->xrefindex_plus1)
      pass ("VPORT_ENTITY_HEADER.xrefindex_plus1 [BS]");
    else
      {
        fail ("VPORT_ENTITY_HEADER.xrefindex_plus1 [BS] %d != %d", vport_entity_header->xrefindex_plus1, xrefindex_plus1); error++;
      }
  }
  {
    BITCODE_B xrefref;
    if (dwg_dynapi_entity_value(vport_entity_header, "VPORT_ENTITY_HEADER", "xrefref", &xrefref, NULL) &&
        xrefref == vport_entity_header->xrefref)
      pass ("VPORT_ENTITY_HEADER.xrefref [B]");
    else
      {
        fail ("VPORT_ENTITY_HEADER.xrefref [B] " FORMAT_B " != " FORMAT_B "", vport_entity_header->xrefref, xrefref); error++;
      }
  }
  return error;
}
static int test_WIPEOUTVARIABLES (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_WIPEOUTVARIABLES *wipeoutvariables = obj->tio.object->tio.WIPEOUTVARIABLES;
  {
    BITCODE_BS display_frame;
    if (dwg_dynapi_entity_value(wipeoutvariables, "WIPEOUTVARIABLES", "display_frame", &display_frame, NULL) &&
        display_frame == wipeoutvariables->display_frame)
      pass ("WIPEOUTVARIABLES.display_frame [BS]");
    else
      {
        fail ("WIPEOUTVARIABLES.display_frame [BS] %d != %d", wipeoutvariables->display_frame, display_frame); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(wipeoutvariables, "WIPEOUTVARIABLES", "ownerhandle", &ownerhandle, NULL) &&
        ownerhandle == wipeoutvariables->ownerhandle)
      pass ("WIPEOUTVARIABLES.ownerhandle [H]");
    else
      {
        fail ("WIPEOUTVARIABLES.ownerhandle [H] %p != %p", wipeoutvariables->ownerhandle, ownerhandle); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(wipeoutvariables, "WIPEOUTVARIABLES", "parent", &parent, NULL)
        && !memcmp(&parent, &wipeoutvariables->parent, sizeof(wipeoutvariables->parent)))
      pass ("WIPEOUTVARIABLES.parent");
    else
      {
        fail ("WIPEOUTVARIABLES.parent"); error++;
      }
  }
  return error;
}
static int test_XRECORD (const Dwg_Object *obj)
{
  int error = 0;
  Dwg_Object_XRECORD *xrecord = obj->tio.object->tio.XRECORD;
  {
    BITCODE_BS cloning_flags;
    if (dwg_dynapi_entity_value(xrecord, "XRECORD", "cloning_flags", &cloning_flags, NULL) &&
        cloning_flags == xrecord->cloning_flags)
      pass ("XRECORD.cloning_flags [BS]");
    else
      {
        fail ("XRECORD.cloning_flags [BS] %d != %d", xrecord->cloning_flags, cloning_flags); error++;
      }
  }
  {
    BITCODE_BL num_databytes;
    if (dwg_dynapi_entity_value(xrecord, "XRECORD", "num_databytes", &num_databytes, NULL) &&
        num_databytes == xrecord->num_databytes)
      pass ("XRECORD.num_databytes [BL]");
    else
      {
        fail ("XRECORD.num_databytes [BL] %u != %u", xrecord->num_databytes, num_databytes); error++;
      }
  }
  {
    BITCODE_BL num_eed;
    if (dwg_dynapi_entity_value(xrecord, "XRECORD", "num_eed", &num_eed, NULL) &&
        num_eed == xrecord->num_eed)
      pass ("XRECORD.num_eed [BL]");
    else
      {
        fail ("XRECORD.num_eed [BL] %u != %u", xrecord->num_eed, num_eed); error++;
      }
  }
  {
    BITCODE_BL num_objid_handles;
    if (dwg_dynapi_entity_value(xrecord, "XRECORD", "num_objid_handles", &num_objid_handles, NULL) &&
        num_objid_handles == xrecord->num_objid_handles)
      pass ("XRECORD.num_objid_handles [BL]");
    else
      {
        fail ("XRECORD.num_objid_handles [BL] %u != %u", xrecord->num_objid_handles, num_objid_handles); error++;
      }
  }
  {
    BITCODE_H* objid_handles;
    if (dwg_dynapi_entity_value(xrecord, "XRECORD", "objid_handles", &objid_handles, NULL)
        && !memcmp(&objid_handles, &xrecord->objid_handles, sizeof(xrecord->objid_handles)))
      pass ("XRECORD.objid_handles");
    else
      {
        fail ("XRECORD.objid_handles"); error++;
      }
  }
  {
    BITCODE_H ownerhandle;
    if (dwg_dynapi_entity_value(xrecord, "XRECORD", "ownerhandle", &ownerhandle, NULL) &&
        ownerhandle == xrecord->ownerhandle)
      pass ("XRECORD.ownerhandle [H]");
    else
      {
        fail ("XRECORD.ownerhandle [H] %p != %p", xrecord->ownerhandle, ownerhandle); error++;
      }
  }
  {
    struct _dwg_object_object* parent;
    if (dwg_dynapi_entity_value(xrecord, "XRECORD", "parent", &parent, NULL)
        && !memcmp(&parent, &xrecord->parent, sizeof(xrecord->parent)))
      pass ("XRECORD.parent");
    else
      {
        fail ("XRECORD.parent"); error++;
      }
  }
  {
    Dwg_Resbuf* xdata;
    if (dwg_dynapi_entity_value(xrecord, "XRECORD", "xdata", &xdata, NULL)
        && !memcmp(&xdata, &xrecord->xdata, sizeof(xrecord->xdata)))
      pass ("XRECORD.xdata");
    else
      {
        fail ("XRECORD.xdata"); error++;
      }
  }
  return error;
}

#line 71 "dynapi_test.c.in"
#if 0
static int test_ARC (const Dwg_Object *obj)
{
  int error = 0;
  BITCODE_BD radius, thickness, start_angle, end_angle;
  dwg_point_3d center, ext;
  Dwg_Entity_ARC *arc = obj->tio.entity->tio.ARC;

  if (dwg_dynapi_entity_value(arc, "ARC", "radius", &radius, NULL) &&
      radius == arc->radius)
    pass ("ARC.radius");
  else
    {
      fail ("ARC.radius %g != %g", arc->radius, radius); error++;
    }
  /* ... */
  return error;
}
#endif

static int test_object (const Dwg_Data *restrict dwg, const Dwg_Object *restrict obj)
{
  int error = 0;
  if (obj->supertype == DWG_SUPERTYPE_UNKNOWN)
    return 0;
#line 27118 "dynapi_test.c"
  /* @@for if_test_OBJECT@@ */
  if (obj->fixedtype == DWG_TYPE__3DFACE)
    error += test__3DFACE(obj);
  else  if (obj->fixedtype == DWG_TYPE__3DSOLID)
    error += test__3DSOLID(obj);
  else  if (obj->fixedtype == DWG_TYPE_ARC)
    error += test_ARC(obj);
  else  if (obj->fixedtype == DWG_TYPE_ATTDEF)
    error += test_ATTDEF(obj);
  else  if (obj->fixedtype == DWG_TYPE_ATTRIB)
    error += test_ATTRIB(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCK)
    error += test_BLOCK(obj);
  else  if (obj->fixedtype == DWG_TYPE_CAMERA)
    error += test_CAMERA(obj);
  else  if (obj->fixedtype == DWG_TYPE_CIRCLE)
    error += test_CIRCLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_ALIGNED)
    error += test_DIMENSION_ALIGNED(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_ANG2LN)
    error += test_DIMENSION_ANG2LN(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_ANG3PT)
    error += test_DIMENSION_ANG3PT(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_DIAMETER)
    error += test_DIMENSION_DIAMETER(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_LINEAR)
    error += test_DIMENSION_LINEAR(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_ORDINATE)
    error += test_DIMENSION_ORDINATE(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_RADIUS)
    error += test_DIMENSION_RADIUS(obj);
  else  if (obj->fixedtype == DWG_TYPE_ELLIPSE)
    error += test_ELLIPSE(obj);
  else  if (obj->fixedtype == DWG_TYPE_ENDBLK)
    error += test_ENDBLK(obj);
  else  if (obj->fixedtype == DWG_TYPE_EXTRUDEDSURFACE)
    error += test_EXTRUDEDSURFACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_GEOPOSITIONMARKER)
    error += test_GEOPOSITIONMARKER(obj);
  else  if (obj->fixedtype == DWG_TYPE_HATCH)
    error += test_HATCH(obj);
  else  if (obj->fixedtype == DWG_TYPE_HELIX)
    error += test_HELIX(obj);
  else  if (obj->fixedtype == DWG_TYPE_IMAGE)
    error += test_IMAGE(obj);
  else  if (obj->fixedtype == DWG_TYPE_INSERT)
    error += test_INSERT(obj);
  else  if (obj->fixedtype == DWG_TYPE_LEADER)
    error += test_LEADER(obj);
  else  if (obj->fixedtype == DWG_TYPE_LIGHT)
    error += test_LIGHT(obj);
  else  if (obj->fixedtype == DWG_TYPE_LINE)
    error += test_LINE(obj);
  else  if (obj->fixedtype == DWG_TYPE_LOFTEDSURFACE)
    error += test_LOFTEDSURFACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_LWPOLYLINE)
    error += test_LWPOLYLINE(obj);
  else  if (obj->fixedtype == DWG_TYPE_MINSERT)
    error += test_MINSERT(obj);
  else  if (obj->fixedtype == DWG_TYPE_MLINE)
    error += test_MLINE(obj);
  else  if (obj->fixedtype == DWG_TYPE_MTEXT)
    error += test_MTEXT(obj);
  else  if (obj->fixedtype == DWG_TYPE_MULTILEADER)
    error += test_MULTILEADER(obj);
  else  if (obj->fixedtype == DWG_TYPE_OLE2FRAME)
    error += test_OLE2FRAME(obj);
  else  if (obj->fixedtype == DWG_TYPE_OLEFRAME)
    error += test_OLEFRAME(obj);
  else  if (obj->fixedtype == DWG_TYPE_PLANESURFACE)
    error += test_PLANESURFACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_POINT)
    error += test_POINT(obj);
  else  if (obj->fixedtype == DWG_TYPE_POLYLINE_2D)
    error += test_POLYLINE_2D(obj);
  else  if (obj->fixedtype == DWG_TYPE_POLYLINE_3D)
    error += test_POLYLINE_3D(obj);
  else  if (obj->fixedtype == DWG_TYPE_POLYLINE_MESH)
    error += test_POLYLINE_MESH(obj);
  else  if (obj->fixedtype == DWG_TYPE_POLYLINE_PFACE)
    error += test_POLYLINE_PFACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_PROXY_ENTITY)
    error += test_PROXY_ENTITY(obj);
  else  if (obj->fixedtype == DWG_TYPE_RAY)
    error += test_RAY(obj);
  else  if (obj->fixedtype == DWG_TYPE_REVOLVEDSURFACE)
    error += test_REVOLVEDSURFACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_SEQEND)
    error += test_SEQEND(obj);
  else  if (obj->fixedtype == DWG_TYPE_SHAPE)
    error += test_SHAPE(obj);
  else  if (obj->fixedtype == DWG_TYPE_SOLID)
    error += test_SOLID(obj);
  else  if (obj->fixedtype == DWG_TYPE_SPLINE)
    error += test_SPLINE(obj);
  else  if (obj->fixedtype == DWG_TYPE_SWEPTSURFACE)
    error += test_SWEPTSURFACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_TABLE)
    error += test_TABLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_TEXT)
    error += test_TEXT(obj);
  else  if (obj->fixedtype == DWG_TYPE_TOLERANCE)
    error += test_TOLERANCE(obj);
  else  if (obj->fixedtype == DWG_TYPE_TRACE)
    error += test_TRACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_UNDERLAY)
    error += test_UNDERLAY(obj);
  else  if (obj->fixedtype == DWG_TYPE_UNKNOWN_ENT)
    error += test_UNKNOWN_ENT(obj);
  else  if (obj->fixedtype == DWG_TYPE_VERTEX_2D)
    error += test_VERTEX_2D(obj);
  else  if (obj->fixedtype == DWG_TYPE_VERTEX_3D)
    error += test_VERTEX_3D(obj);
  else  if (obj->fixedtype == DWG_TYPE_VERTEX_PFACE_FACE)
    error += test_VERTEX_PFACE_FACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_VIEWPORT)
    error += test_VIEWPORT(obj);
  else  if (obj->fixedtype == DWG_TYPE_WIPEOUT)
    error += test_WIPEOUT(obj);
  else  if (obj->fixedtype == DWG_TYPE_ACDBNAVISWORKSMODELDEF)
    error += test_ACDBNAVISWORKSMODELDEF(obj);
  else  if (obj->fixedtype == DWG_TYPE_ACSH_SWEEP_CLASS)
    error += test_ACSH_SWEEP_CLASS(obj);
  else  if (obj->fixedtype == DWG_TYPE_APPID)
    error += test_APPID(obj);
  else  if (obj->fixedtype == DWG_TYPE_APPID_CONTROL)
    error += test_APPID_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOC2DCONSTRAINTGROUP)
    error += test_ASSOC2DCONSTRAINTGROUP(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCACTION)
    error += test_ASSOCACTION(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCALIGNEDDIMACTIONBODY)
    error += test_ASSOCALIGNEDDIMACTIONBODY(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCDEPENDENCY)
    error += test_ASSOCDEPENDENCY(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCNETWORK)
    error += test_ASSOCNETWORK(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCOSNAPPOINTREFACTIONPARAM)
    error += test_ASSOCOSNAPPOINTREFACTIONPARAM(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCPERSSUBENTMANAGER)
    error += test_ASSOCPERSSUBENTMANAGER(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCPLANESURFACEACTIONBODY)
    error += test_ASSOCPLANESURFACEACTIONBODY(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCK_CONTROL)
    error += test_BLOCK_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCK_HEADER)
    error += test_BLOCK_HEADER(obj);
  else  if (obj->fixedtype == DWG_TYPE_CELLSTYLEMAP)
    error += test_CELLSTYLEMAP(obj);
  else  if (obj->fixedtype == DWG_TYPE_DATATABLE)
    error += test_DATATABLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_DBCOLOR)
    error += test_DBCOLOR(obj);
  else  if (obj->fixedtype == DWG_TYPE_DICTIONARY)
    error += test_DICTIONARY(obj);
  else  if (obj->fixedtype == DWG_TYPE_DICTIONARYVAR)
    error += test_DICTIONARYVAR(obj);
  else  if (obj->fixedtype == DWG_TYPE_DICTIONARYWDFLT)
    error += test_DICTIONARYWDFLT(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMASSOC)
    error += test_DIMASSOC(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMSTYLE)
    error += test_DIMSTYLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMSTYLE_CONTROL)
    error += test_DIMSTYLE_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_DUMMY)
    error += test_DUMMY(obj);
  else  if (obj->fixedtype == DWG_TYPE_DYNAMICBLOCKPURGEPREVENTER)
    error += test_DYNAMICBLOCKPURGEPREVENTER(obj);
  else  if (obj->fixedtype == DWG_TYPE_EVALUATION_GRAPH)
    error += test_EVALUATION_GRAPH(obj);
  else  if (obj->fixedtype == DWG_TYPE_FIELD)
    error += test_FIELD(obj);
  else  if (obj->fixedtype == DWG_TYPE_FIELDLIST)
    error += test_FIELDLIST(obj);
  else  if (obj->fixedtype == DWG_TYPE_GEODATA)
    error += test_GEODATA(obj);
  else  if (obj->fixedtype == DWG_TYPE_GROUP)
    error += test_GROUP(obj);
  else  if (obj->fixedtype == DWG_TYPE_IDBUFFER)
    error += test_IDBUFFER(obj);
  else  if (obj->fixedtype == DWG_TYPE_IMAGEDEF)
    error += test_IMAGEDEF(obj);
  else  if (obj->fixedtype == DWG_TYPE_IMAGEDEF_REACTOR)
    error += test_IMAGEDEF_REACTOR(obj);
  else  if (obj->fixedtype == DWG_TYPE_LAYER)
    error += test_LAYER(obj);
  else  if (obj->fixedtype == DWG_TYPE_LAYER_CONTROL)
    error += test_LAYER_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_LAYER_INDEX)
    error += test_LAYER_INDEX(obj);
  else  if (obj->fixedtype == DWG_TYPE_LAYOUT)
    error += test_LAYOUT(obj);
  else  if (obj->fixedtype == DWG_TYPE_LIGHTLIST)
    error += test_LIGHTLIST(obj);
  else  if (obj->fixedtype == DWG_TYPE_LONG_TRANSACTION)
    error += test_LONG_TRANSACTION(obj);
  else  if (obj->fixedtype == DWG_TYPE_LTYPE)
    error += test_LTYPE(obj);
  else  if (obj->fixedtype == DWG_TYPE_LTYPE_CONTROL)
    error += test_LTYPE_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_MATERIAL)
    error += test_MATERIAL(obj);
  else  if (obj->fixedtype == DWG_TYPE_MLEADERSTYLE)
    error += test_MLEADERSTYLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_MLINESTYLE)
    error += test_MLINESTYLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_OBJECTCONTEXTDATA)
    error += test_OBJECTCONTEXTDATA(obj);
  else  if (obj->fixedtype == DWG_TYPE_OBJECT_PTR)
    error += test_OBJECT_PTR(obj);
  else  if (obj->fixedtype == DWG_TYPE_PERSSUBENTMANAGER)
    error += test_PERSSUBENTMANAGER(obj);
  else  if (obj->fixedtype == DWG_TYPE_PLACEHOLDER)
    error += test_PLACEHOLDER(obj);
  else  if (obj->fixedtype == DWG_TYPE_PLOTSETTINGS)
    error += test_PLOTSETTINGS(obj);
  else  if (obj->fixedtype == DWG_TYPE_PROXY_OBJECT)
    error += test_PROXY_OBJECT(obj);
  else  if (obj->fixedtype == DWG_TYPE_RASTERVARIABLES)
    error += test_RASTERVARIABLES(obj);
  else  if (obj->fixedtype == DWG_TYPE_SCALE)
    error += test_SCALE(obj);
  else  if (obj->fixedtype == DWG_TYPE_SORTENTSTABLE)
    error += test_SORTENTSTABLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_SPATIAL_FILTER)
    error += test_SPATIAL_FILTER(obj);
  else  if (obj->fixedtype == DWG_TYPE_SPATIAL_INDEX)
    error += test_SPATIAL_INDEX(obj);
  else  if (obj->fixedtype == DWG_TYPE_STYLE)
    error += test_STYLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_STYLE_CONTROL)
    error += test_STYLE_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_SUN)
    error += test_SUN(obj);
  else  if (obj->fixedtype == DWG_TYPE_SUNSTUDY)
    error += test_SUNSTUDY(obj);
  else  if (obj->fixedtype == DWG_TYPE_TABLECONTENT)
    error += test_TABLECONTENT(obj);
  else  if (obj->fixedtype == DWG_TYPE_TABLEGEOMETRY)
    error += test_TABLEGEOMETRY(obj);
  else  if (obj->fixedtype == DWG_TYPE_TABLESTYLE)
    error += test_TABLESTYLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_UCS)
    error += test_UCS(obj);
  else  if (obj->fixedtype == DWG_TYPE_UCS_CONTROL)
    error += test_UCS_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_UNDERLAYDEFINITION)
    error += test_UNDERLAYDEFINITION(obj);
  else  if (obj->fixedtype == DWG_TYPE_UNKNOWN_OBJ)
    error += test_UNKNOWN_OBJ(obj);
  else  if (obj->fixedtype == DWG_TYPE_VBA_PROJECT)
    error += test_VBA_PROJECT(obj);
  else  if (obj->fixedtype == DWG_TYPE_VIEW)
    error += test_VIEW(obj);
  else  if (obj->fixedtype == DWG_TYPE_VIEW_CONTROL)
    error += test_VIEW_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_VISUALSTYLE)
    error += test_VISUALSTYLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_VPORT)
    error += test_VPORT(obj);
  else  if (obj->fixedtype == DWG_TYPE_VPORT_CONTROL)
    error += test_VPORT_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_VPORT_ENTITY_CONTROL)
    error += test_VPORT_ENTITY_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_VPORT_ENTITY_HEADER)
    error += test_VPORT_ENTITY_HEADER(obj);
  else  if (obj->fixedtype == DWG_TYPE_WIPEOUTVARIABLES)
    error += test_WIPEOUTVARIABLES(obj);
  else  if (obj->fixedtype == DWG_TYPE_XRECORD)
    error += test_XRECORD(obj);
  if (obj->fixedtype == DWG_TYPE__3DFACE)
    error += test__3DFACE(obj);
  else  if (obj->fixedtype == DWG_TYPE__3DSOLID)
    error += test__3DSOLID(obj);
  else  if (obj->fixedtype == DWG_TYPE_ARC)
    error += test_ARC(obj);
  else  if (obj->fixedtype == DWG_TYPE_ATTDEF)
    error += test_ATTDEF(obj);
  else  if (obj->fixedtype == DWG_TYPE_ATTRIB)
    error += test_ATTRIB(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCK)
    error += test_BLOCK(obj);
  else  if (obj->fixedtype == DWG_TYPE_CAMERA)
    error += test_CAMERA(obj);
  else  if (obj->fixedtype == DWG_TYPE_CIRCLE)
    error += test_CIRCLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_ALIGNED)
    error += test_DIMENSION_ALIGNED(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_ANG2LN)
    error += test_DIMENSION_ANG2LN(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_ANG3PT)
    error += test_DIMENSION_ANG3PT(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_DIAMETER)
    error += test_DIMENSION_DIAMETER(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_LINEAR)
    error += test_DIMENSION_LINEAR(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_ORDINATE)
    error += test_DIMENSION_ORDINATE(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMENSION_RADIUS)
    error += test_DIMENSION_RADIUS(obj);
  else  if (obj->fixedtype == DWG_TYPE_ELLIPSE)
    error += test_ELLIPSE(obj);
  else  if (obj->fixedtype == DWG_TYPE_ENDBLK)
    error += test_ENDBLK(obj);
  else  if (obj->fixedtype == DWG_TYPE_EXTRUDEDSURFACE)
    error += test_EXTRUDEDSURFACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_GEOPOSITIONMARKER)
    error += test_GEOPOSITIONMARKER(obj);
  else  if (obj->fixedtype == DWG_TYPE_HATCH)
    error += test_HATCH(obj);
  else  if (obj->fixedtype == DWG_TYPE_HELIX)
    error += test_HELIX(obj);
  else  if (obj->fixedtype == DWG_TYPE_IMAGE)
    error += test_IMAGE(obj);
  else  if (obj->fixedtype == DWG_TYPE_INSERT)
    error += test_INSERT(obj);
  else  if (obj->fixedtype == DWG_TYPE_LEADER)
    error += test_LEADER(obj);
  else  if (obj->fixedtype == DWG_TYPE_LIGHT)
    error += test_LIGHT(obj);
  else  if (obj->fixedtype == DWG_TYPE_LINE)
    error += test_LINE(obj);
  else  if (obj->fixedtype == DWG_TYPE_LOFTEDSURFACE)
    error += test_LOFTEDSURFACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_LWPOLYLINE)
    error += test_LWPOLYLINE(obj);
  else  if (obj->fixedtype == DWG_TYPE_MINSERT)
    error += test_MINSERT(obj);
  else  if (obj->fixedtype == DWG_TYPE_MLINE)
    error += test_MLINE(obj);
  else  if (obj->fixedtype == DWG_TYPE_MTEXT)
    error += test_MTEXT(obj);
  else  if (obj->fixedtype == DWG_TYPE_MULTILEADER)
    error += test_MULTILEADER(obj);
  else  if (obj->fixedtype == DWG_TYPE_OLE2FRAME)
    error += test_OLE2FRAME(obj);
  else  if (obj->fixedtype == DWG_TYPE_OLEFRAME)
    error += test_OLEFRAME(obj);
  else  if (obj->fixedtype == DWG_TYPE_PLANESURFACE)
    error += test_PLANESURFACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_POINT)
    error += test_POINT(obj);
  else  if (obj->fixedtype == DWG_TYPE_POLYLINE_2D)
    error += test_POLYLINE_2D(obj);
  else  if (obj->fixedtype == DWG_TYPE_POLYLINE_3D)
    error += test_POLYLINE_3D(obj);
  else  if (obj->fixedtype == DWG_TYPE_POLYLINE_MESH)
    error += test_POLYLINE_MESH(obj);
  else  if (obj->fixedtype == DWG_TYPE_POLYLINE_PFACE)
    error += test_POLYLINE_PFACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_PROXY_ENTITY)
    error += test_PROXY_ENTITY(obj);
  else  if (obj->fixedtype == DWG_TYPE_RAY)
    error += test_RAY(obj);
  else  if (obj->fixedtype == DWG_TYPE_REVOLVEDSURFACE)
    error += test_REVOLVEDSURFACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_SEQEND)
    error += test_SEQEND(obj);
  else  if (obj->fixedtype == DWG_TYPE_SHAPE)
    error += test_SHAPE(obj);
  else  if (obj->fixedtype == DWG_TYPE_SOLID)
    error += test_SOLID(obj);
  else  if (obj->fixedtype == DWG_TYPE_SPLINE)
    error += test_SPLINE(obj);
  else  if (obj->fixedtype == DWG_TYPE_SWEPTSURFACE)
    error += test_SWEPTSURFACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_TABLE)
    error += test_TABLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_TEXT)
    error += test_TEXT(obj);
  else  if (obj->fixedtype == DWG_TYPE_TOLERANCE)
    error += test_TOLERANCE(obj);
  else  if (obj->fixedtype == DWG_TYPE_TRACE)
    error += test_TRACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_UNDERLAY)
    error += test_UNDERLAY(obj);
  else  if (obj->fixedtype == DWG_TYPE_UNKNOWN_ENT)
    error += test_UNKNOWN_ENT(obj);
  else  if (obj->fixedtype == DWG_TYPE_VERTEX_2D)
    error += test_VERTEX_2D(obj);
  else  if (obj->fixedtype == DWG_TYPE_VERTEX_3D)
    error += test_VERTEX_3D(obj);
  else  if (obj->fixedtype == DWG_TYPE_VERTEX_PFACE_FACE)
    error += test_VERTEX_PFACE_FACE(obj);
  else  if (obj->fixedtype == DWG_TYPE_VIEWPORT)
    error += test_VIEWPORT(obj);
  else  if (obj->fixedtype == DWG_TYPE_WIPEOUT)
    error += test_WIPEOUT(obj);
  else  if (obj->fixedtype == DWG_TYPE_ACDBNAVISWORKSMODELDEF)
    error += test_ACDBNAVISWORKSMODELDEF(obj);
  else  if (obj->fixedtype == DWG_TYPE_ACSH_SWEEP_CLASS)
    error += test_ACSH_SWEEP_CLASS(obj);
  else  if (obj->fixedtype == DWG_TYPE_APPID)
    error += test_APPID(obj);
  else  if (obj->fixedtype == DWG_TYPE_APPID_CONTROL)
    error += test_APPID_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOC2DCONSTRAINTGROUP)
    error += test_ASSOC2DCONSTRAINTGROUP(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCACTION)
    error += test_ASSOCACTION(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCALIGNEDDIMACTIONBODY)
    error += test_ASSOCALIGNEDDIMACTIONBODY(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCDEPENDENCY)
    error += test_ASSOCDEPENDENCY(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCNETWORK)
    error += test_ASSOCNETWORK(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCOSNAPPOINTREFACTIONPARAM)
    error += test_ASSOCOSNAPPOINTREFACTIONPARAM(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCPERSSUBENTMANAGER)
    error += test_ASSOCPERSSUBENTMANAGER(obj);
  else  if (obj->fixedtype == DWG_TYPE_ASSOCPLANESURFACEACTIONBODY)
    error += test_ASSOCPLANESURFACEACTIONBODY(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCK_CONTROL)
    error += test_BLOCK_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_BLOCK_HEADER)
    error += test_BLOCK_HEADER(obj);
  else  if (obj->fixedtype == DWG_TYPE_CELLSTYLEMAP)
    error += test_CELLSTYLEMAP(obj);
  else  if (obj->fixedtype == DWG_TYPE_DATATABLE)
    error += test_DATATABLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_DBCOLOR)
    error += test_DBCOLOR(obj);
  else  if (obj->fixedtype == DWG_TYPE_DICTIONARY)
    error += test_DICTIONARY(obj);
  else  if (obj->fixedtype == DWG_TYPE_DICTIONARYVAR)
    error += test_DICTIONARYVAR(obj);
  else  if (obj->fixedtype == DWG_TYPE_DICTIONARYWDFLT)
    error += test_DICTIONARYWDFLT(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMASSOC)
    error += test_DIMASSOC(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMSTYLE)
    error += test_DIMSTYLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_DIMSTYLE_CONTROL)
    error += test_DIMSTYLE_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_DUMMY)
    error += test_DUMMY(obj);
  else  if (obj->fixedtype == DWG_TYPE_DYNAMICBLOCKPURGEPREVENTER)
    error += test_DYNAMICBLOCKPURGEPREVENTER(obj);
  else  if (obj->fixedtype == DWG_TYPE_EVALUATION_GRAPH)
    error += test_EVALUATION_GRAPH(obj);
  else  if (obj->fixedtype == DWG_TYPE_FIELD)
    error += test_FIELD(obj);
  else  if (obj->fixedtype == DWG_TYPE_FIELDLIST)
    error += test_FIELDLIST(obj);
  else  if (obj->fixedtype == DWG_TYPE_GEODATA)
    error += test_GEODATA(obj);
  else  if (obj->fixedtype == DWG_TYPE_GROUP)
    error += test_GROUP(obj);
  else  if (obj->fixedtype == DWG_TYPE_IDBUFFER)
    error += test_IDBUFFER(obj);
  else  if (obj->fixedtype == DWG_TYPE_IMAGEDEF)
    error += test_IMAGEDEF(obj);
  else  if (obj->fixedtype == DWG_TYPE_IMAGEDEF_REACTOR)
    error += test_IMAGEDEF_REACTOR(obj);
  else  if (obj->fixedtype == DWG_TYPE_LAYER)
    error += test_LAYER(obj);
  else  if (obj->fixedtype == DWG_TYPE_LAYER_CONTROL)
    error += test_LAYER_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_LAYER_INDEX)
    error += test_LAYER_INDEX(obj);
  else  if (obj->fixedtype == DWG_TYPE_LAYOUT)
    error += test_LAYOUT(obj);
  else  if (obj->fixedtype == DWG_TYPE_LIGHTLIST)
    error += test_LIGHTLIST(obj);
  else  if (obj->fixedtype == DWG_TYPE_LONG_TRANSACTION)
    error += test_LONG_TRANSACTION(obj);
  else  if (obj->fixedtype == DWG_TYPE_LTYPE)
    error += test_LTYPE(obj);
  else  if (obj->fixedtype == DWG_TYPE_LTYPE_CONTROL)
    error += test_LTYPE_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_MATERIAL)
    error += test_MATERIAL(obj);
  else  if (obj->fixedtype == DWG_TYPE_MLEADERSTYLE)
    error += test_MLEADERSTYLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_MLINESTYLE)
    error += test_MLINESTYLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_OBJECTCONTEXTDATA)
    error += test_OBJECTCONTEXTDATA(obj);
  else  if (obj->fixedtype == DWG_TYPE_OBJECT_PTR)
    error += test_OBJECT_PTR(obj);
  else  if (obj->fixedtype == DWG_TYPE_PERSSUBENTMANAGER)
    error += test_PERSSUBENTMANAGER(obj);
  else  if (obj->fixedtype == DWG_TYPE_PLACEHOLDER)
    error += test_PLACEHOLDER(obj);
  else  if (obj->fixedtype == DWG_TYPE_PLOTSETTINGS)
    error += test_PLOTSETTINGS(obj);
  else  if (obj->fixedtype == DWG_TYPE_PROXY_OBJECT)
    error += test_PROXY_OBJECT(obj);
  else  if (obj->fixedtype == DWG_TYPE_RASTERVARIABLES)
    error += test_RASTERVARIABLES(obj);
  else  if (obj->fixedtype == DWG_TYPE_SCALE)
    error += test_SCALE(obj);
  else  if (obj->fixedtype == DWG_TYPE_SORTENTSTABLE)
    error += test_SORTENTSTABLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_SPATIAL_FILTER)
    error += test_SPATIAL_FILTER(obj);
  else  if (obj->fixedtype == DWG_TYPE_SPATIAL_INDEX)
    error += test_SPATIAL_INDEX(obj);
  else  if (obj->fixedtype == DWG_TYPE_STYLE)
    error += test_STYLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_STYLE_CONTROL)
    error += test_STYLE_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_SUN)
    error += test_SUN(obj);
  else  if (obj->fixedtype == DWG_TYPE_SUNSTUDY)
    error += test_SUNSTUDY(obj);
  else  if (obj->fixedtype == DWG_TYPE_TABLECONTENT)
    error += test_TABLECONTENT(obj);
  else  if (obj->fixedtype == DWG_TYPE_TABLEGEOMETRY)
    error += test_TABLEGEOMETRY(obj);
  else  if (obj->fixedtype == DWG_TYPE_TABLESTYLE)
    error += test_TABLESTYLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_UCS)
    error += test_UCS(obj);
  else  if (obj->fixedtype == DWG_TYPE_UCS_CONTROL)
    error += test_UCS_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_UNDERLAYDEFINITION)
    error += test_UNDERLAYDEFINITION(obj);
  else  if (obj->fixedtype == DWG_TYPE_UNKNOWN_OBJ)
    error += test_UNKNOWN_OBJ(obj);
  else  if (obj->fixedtype == DWG_TYPE_VBA_PROJECT)
    error += test_VBA_PROJECT(obj);
  else  if (obj->fixedtype == DWG_TYPE_VIEW)
    error += test_VIEW(obj);
  else  if (obj->fixedtype == DWG_TYPE_VIEW_CONTROL)
    error += test_VIEW_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_VISUALSTYLE)
    error += test_VISUALSTYLE(obj);
  else  if (obj->fixedtype == DWG_TYPE_VPORT)
    error += test_VPORT(obj);
  else  if (obj->fixedtype == DWG_TYPE_VPORT_CONTROL)
    error += test_VPORT_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_VPORT_ENTITY_CONTROL)
    error += test_VPORT_ENTITY_CONTROL(obj);
  else  if (obj->fixedtype == DWG_TYPE_VPORT_ENTITY_HEADER)
    error += test_VPORT_ENTITY_HEADER(obj);
  else  if (obj->fixedtype == DWG_TYPE_WIPEOUTVARIABLES)
    error += test_WIPEOUTVARIABLES(obj);
  else  if (obj->fixedtype == DWG_TYPE_XRECORD)
    error += test_XRECORD(obj);
#line 99 "dynapi_test.c.in"
  /*
  if (obj->fixedtype == DWG_TYPE_ARC)
    error += test_ARC(obj);
  */
  return error;
}

static int test_dynapi (const char *filename)
{
  int error;
  Dwg_Data dwg;
  BITCODE_BL i;

  dwg.opts = 0;
  if (dwg_read_file (filename, &dwg) >= DWG_ERR_CRITICAL)
    {
      dwg_free (&dwg);
      return 1;
    }
  error = test_header (&dwg);
  for (i=0; i<dwg.num_objects; i++)
    {
      error += test_object(&dwg, &dwg.object[i]);
    }
  dwg_free (&dwg);
  /* This value is the return value for `main',
     so clamp it to either 0 or 1.  */
  return error ? 1 : 0;
}

int
main (int argc, char *argv[])
{
  char *input = getenv ("INPUT");

  if (input == NULL)
    {
      struct stat attrib;
      input = (char*)"example_2000.dwg";
      if (stat(input, &attrib))
        {
          fprintf (stderr, "Env var INPUT not defined, %s not found\n", input);
          return EXIT_FAILURE;
        }
    }
  return test_dynapi (input);
}
