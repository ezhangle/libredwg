/*****************************************************************************/
/*  LibreDWG - free implementation of the DWG file format                    */
/*                                                                           */
/*  Copyright (C) 2019 Free Software Foundation, Inc.                        */
/*                                                                           */
/*  This library is free software, licensed under the terms of the GNU       */
/*  General Public License as published by the Free Software Foundation,     */
/*  either version 3 of the License, or (at your option) any later version.  */
/*  You should have received a copy of the GNU General Public License        */
/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.    */
/*****************************************************************************/
/* dynapi coverage tests, generated by gen-dynapi.pl from dynapi_test.c.in
   do not modify */
/* written by: Reini Urban */

#line 16 "dynapi_test.c.in"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <math.h>
#include <sys/stat.h>

#define DWG_LOGLEVEL DWG_LOGLEVEL_NONE
#include "dwg.h"
#include "dwg_api.h"
#include "../../src/dynapi.h"
#include <dejagnu.h>

/* for all objects/entities/header_vars:
   compare direct api vs dynapi values
*/
static int test_header (const Dwg_Data *dwg)
{
  int error = 0;
  BITCODE_RL rl;
  BITCODE_RC rc;
  BITCODE_BLL bll;
  BITCODE_BD bd;
  BITCODE_TV tv;

  /*for (i=0; i<ARRAY_SIZE(_dwg_header_variables_fields)-1; i++) {
    const Dwg_DYNAPI_field *f = &_dwg_header_variables_fields[0];
    const char *name = f->name;
  }*/
#if 0
  if (dwg_dynapi_header_value(dwg, "unknown_0", &bd, NULL) &&
      dwg->header_vars.unknown_0 == bd) {
    pass ("HEADER.unknown_0");
  }  else {
    fail ("HEADER.unknown_0 %g != %g", dwg->header_vars.unknown_0, bd); error++;
  }
  if (dwg_dynapi_header_value(dwg, "unknown_text1", &tv, NULL) &&
      tv && dwg->header_vars.unknown_text1 &&
      !strcmp(dwg->header_vars.unknown_text1, tv)) {
    pass ("HEADER.unknown_text1");
  } else {
    fail ("HEADER.unknown_0 %s != %s", dwg->header_vars.unknown_text1, tv); error++;
  }
#endif
  /* ... */
#line 63 "dynapi_test.c"
  /* @@for test_HEADER@@ */
#line 64 "dynapi_test.c.in"
  return error;
}

#line 3619 "dynapi_test.c"
/* @@for test_OBJECT@@ */

#line 71 "dynapi_test.c.in"
#if 0
static int test_ARC (const Dwg_Object *obj)
{
  int error = 0;
  BITCODE_BD radius, thickness, start_angle, end_angle;
  dwg_point_3d center, ext;
  Dwg_Entity_ARC *arc = obj->tio.entity->tio.ARC;

  if (dwg_dynapi_entity_value(arc, "ARC", "radius", &radius, NULL) &&
      radius == arc->radius)
    pass ("ARC.radius");
  else
    {
      fail ("ARC.radius %g != %g", arc->radius, radius); error++;
    }
  /* ... */
  return error;
}
#endif

static int test_object (const Dwg_Data *restrict dwg, const Dwg_Object *restrict obj)
{
  int error = 0;
  if (obj->supertype == DWG_SUPERTYPE_UNKNOWN)
    return 0;
#line 27118 "dynapi_test.c"
  /* @@for if_test_OBJECT@@ */
#line 99 "dynapi_test.c.in"
  /*
  if (obj->fixedtype == DWG_TYPE_ARC)
    error += test_ARC(obj);
  */
  return error;
}

static int test_dynapi (const char *filename)
{
  int error;
  Dwg_Data dwg;
  BITCODE_BL i;

  dwg.opts = 0;
  if (dwg_read_file (filename, &dwg) >= DWG_ERR_CRITICAL)
    {
      dwg_free (&dwg);
      return 1;
    }
  error = test_header (&dwg);
  for (i=0; i<dwg.num_objects; i++)
    {
      error += test_object(&dwg, &dwg.object[i]);
    }
  dwg_free (&dwg);
  /* This value is the return value for `main',
     so clamp it to either 0 or 1.  */
  return error ? 1 : 0;
}

int
main (int argc, char *argv[])
{
  char *input = getenv ("INPUT");

  if (input == NULL)
    {
      struct stat attrib;
      input = (char*)"example_2000.dwg";
      if (stat(input, &attrib))
        {
          fprintf (stderr, "Env var INPUT not defined, %s not found\n", input);
          return EXIT_FAILURE;
        }
    }
  return test_dynapi (input);
}
